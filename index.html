<html>
    <head>
        <script type="text/javascript" charset="utf-8">
            /**
             * matter-js 0.9.1 by @liabru 2016-02-15
             * http://brm.io/matter-js/
             * License MIT
             */

            /**
             * The MIT License (MIT)
             *
             * Copyright (c) 2014 Liam Brummitt
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in
             * all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             * THE SOFTWARE.
             */

            (function (f) {
                if (
                    typeof exports === "object" &&
                    typeof module !== "undefined"
                ) {
                    module.exports = f();
                } else if (typeof define === "function" && define.amd) {
                    define([], f);
                } else {
                    var g;
                    if (typeof window !== "undefined") {
                        g = window;
                    } else if (typeof global !== "undefined") {
                        g = global;
                    } else if (typeof self !== "undefined") {
                        g = self;
                    } else {
                        g = this;
                    }
                    g.Matter = f();
                }
            })(function () {
                var define, module, exports;
                return (function e(t, n, r) {
                    function s(o, u) {
                        if (!n[o]) {
                            if (!t[o]) {
                                var a = typeof require == "function" && require;
                                if (!u && a) return a(o, !0);
                                if (i) return i(o, !0);
                                var f = new Error(
                                    "Cannot find module '" + o + "'"
                                );
                                throw ((f.code = "MODULE_NOT_FOUND"), f);
                            }
                            var l = (n[o] = { exports: {} });
                            t[o][0].call(
                                l.exports,
                                function (e) {
                                    var n = t[o][1][e];
                                    return s(n ? n : e);
                                },
                                l,
                                l.exports,
                                e,
                                t,
                                n,
                                r
                            );
                        }
                        return n[o].exports;
                    }
                    var i = typeof require == "function" && require;
                    for (var o = 0; o < r.length; o++) s(r[o]);
                    return s;
                })(
                    {
                        1: [
                            function (require, module, exports) {
                                /**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/

                                var Body = {};

                                module.exports = Body;

                                var Vertices = require("../geometry/Vertices");
                                var Vector = require("../geometry/Vector");
                                var Sleeping = require("../core/Sleeping");
                                var Render = require("../render/Render");
                                var Common = require("../core/Common");
                                var Bounds = require("../geometry/Bounds");
                                var Axes = require("../geometry/Axes");

                                (function () {
                                    Body._inertiaScale = 4;
                                    Body._nextCollidingGroupId = 1;
                                    Body._nextNonCollidingGroupId = -1;
                                    Body._nextCategory = 0x0001;

                                    /**
                                     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * All properties have default values, and many are pre-calculated automatically based on other properties.
                                     * See the properties section below for detailed information on what you can pass via the `options` object.
                                     * @method create
                                     * @param {} options
                                     * @return {body} body
                                     */
                                    Body.create = function (options) {
                                        var defaults = {
                                            id: Common.nextId(),
                                            type: "body",
                                            label: "Body",
                                            parts: [],
                                            angle: 0,
                                            vertices: Vertices.fromPath(
                                                "L 0 0 L 40 0 L 40 40 L 0 40"
                                            ),
                                            position: { x: 0, y: 0 },
                                            force: { x: 0, y: 0 },
                                            torque: 0,
                                            positionImpulse: { x: 0, y: 0 },
                                            constraintImpulse: {
                                                x: 0,
                                                y: 0,
                                                angle: 0,
                                            },
                                            totalContacts: 0,
                                            speed: 0,
                                            angularSpeed: 0,
                                            velocity: { x: 0, y: 0 },
                                            angularVelocity: 0,
                                            isStatic: false,
                                            isSleeping: false,
                                            motion: 0,
                                            sleepThreshold: 60,
                                            density: 0.001,
                                            restitution: 0,
                                            friction: 0.1,
                                            frictionStatic: 0.5,
                                            frictionAir: 0.01,
                                            collisionFilter: {
                                                category: 0x0001,
                                                mask: 0xffffffff,
                                                group: 0,
                                            },
                                            slop: 0.05,
                                            timeScale: 1,
                                            render: {
                                                visible: true,
                                                opacity: 1,
                                                sprite: {
                                                    xScale: 1,
                                                    yScale: 1,
                                                    xOffset: 0,
                                                    yOffset: 0,
                                                },
                                                lineWidth: 1.5,
                                            },
                                        };

                                        var body = Common.extend(
                                            defaults,
                                            options
                                        );

                                        _initProperties(body, options);

                                        return body;
                                    };

                                    /**
                                     * Returns the next unique group index for which bodies will collide.
                                     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
                                     * See `body.collisionFilter` for more information.
                                     * @method nextGroup
                                     * @param {bool} [isNonColliding=false]
                                     * @return {Number} Unique group index
                                     */
                                    Body.nextGroup = function (isNonColliding) {
                                        if (isNonColliding)
                                            return Body._nextNonCollidingGroupId--;

                                        return Body._nextCollidingGroupId++;
                                    };

                                    /**
                                     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
                                     * There are 32 available. See `body.collisionFilter` for more information.
                                     * @method nextCategory
                                     * @return {Number} Unique category bitfield
                                     */
                                    Body.nextCategory = function () {
                                        Body._nextCategory =
                                            Body._nextCategory << 1;
                                        return Body._nextCategory;
                                    };

                                    /**
                                     * Initialises body properties.
                                     * @method _initProperties
                                     * @private
                                     * @param {body} body
                                     * @param {} options
                                     */
                                    var _initProperties = function (
                                        body,
                                        options
                                    ) {
                                        // init required properties (order is important)
                                        Body.set(body, {
                                            bounds:
                                                body.bounds ||
                                                Bounds.create(body.vertices),
                                            positionPrev:
                                                body.positionPrev ||
                                                Vector.clone(body.position),
                                            anglePrev:
                                                body.anglePrev || body.angle,
                                            vertices: body.vertices,
                                            parts: body.parts || [body],
                                            isStatic: body.isStatic,
                                            isSleeping: body.isSleeping,
                                            parent: body.parent || body,
                                        });

                                        Vertices.rotate(
                                            body.vertices,
                                            body.angle,
                                            body.position
                                        );
                                        Axes.rotate(body.axes, body.angle);
                                        Bounds.update(
                                            body.bounds,
                                            body.vertices,
                                            body.velocity
                                        );

                                        // allow options to override the automatically calculated properties
                                        Body.set(body, {
                                            axes: options.axes || body.axes,
                                            area: options.area || body.area,
                                            mass: options.mass || body.mass,
                                            inertia:
                                                options.inertia || body.inertia,
                                        });

                                        // render properties
                                        var defaultFillStyle = body.isStatic
                                                ? "#eeeeee"
                                                : Common.choose([
                                                      "#556270",
                                                      "#4ECDC4",
                                                      "#C7F464",
                                                      "#FF6B6B",
                                                      "#C44D58",
                                                  ]),
                                            defaultStrokeStyle =
                                                Common.shadeColor(
                                                    defaultFillStyle,
                                                    -20
                                                );
                                        body.render.fillStyle =
                                            body.render.fillStyle ||
                                            defaultFillStyle;
                                        body.render.strokeStyle =
                                            body.render.strokeStyle ||
                                            defaultStrokeStyle;
                                        body.render.sprite.xOffset +=
                                            -(
                                                body.bounds.min.x -
                                                body.position.x
                                            ) /
                                            (body.bounds.max.x -
                                                body.bounds.min.x);
                                        body.render.sprite.yOffset +=
                                            -(
                                                body.bounds.min.y -
                                                body.position.y
                                            ) /
                                            (body.bounds.max.y -
                                                body.bounds.min.y);
                                    };

                                    /**
                                     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
                                     * Prefer to use the actual setter functions in performance critical situations.
                                     * @method set
                                     * @param {body} body
                                     * @param {} settings A property name (or map of properties and values) to set on the body.
                                     * @param {} value The value to set if `settings` is a single property name.
                                     */
                                    Body.set = function (
                                        body,
                                        settings,
                                        value
                                    ) {
                                        var property;

                                        if (typeof settings === "string") {
                                            property = settings;
                                            settings = {};
                                            settings[property] = value;
                                        }

                                        for (property in settings) {
                                            value = settings[property];

                                            if (
                                                !settings.hasOwnProperty(
                                                    property
                                                )
                                            )
                                                continue;

                                            switch (property) {
                                                case "isStatic":
                                                    Body.setStatic(body, value);
                                                    break;
                                                case "isSleeping":
                                                    Sleeping.set(body, value);
                                                    break;
                                                case "mass":
                                                    Body.setMass(body, value);
                                                    break;
                                                case "density":
                                                    Body.setDensity(
                                                        body,
                                                        value
                                                    );
                                                    break;
                                                case "inertia":
                                                    Body.setInertia(
                                                        body,
                                                        value
                                                    );
                                                    break;
                                                case "vertices":
                                                    Body.setVertices(
                                                        body,
                                                        value
                                                    );
                                                    break;
                                                case "position":
                                                    Body.setPosition(
                                                        body,
                                                        value
                                                    );
                                                    break;
                                                case "angle":
                                                    Body.setAngle(body, value);
                                                    break;
                                                case "velocity":
                                                    Body.setVelocity(
                                                        body,
                                                        value
                                                    );
                                                    break;
                                                case "angularVelocity":
                                                    Body.setAngularVelocity(
                                                        body,
                                                        value
                                                    );
                                                    break;
                                                case "parts":
                                                    Body.setParts(body, value);
                                                    break;
                                                default:
                                                    body[property] = value;
                                            }
                                        }
                                    };

                                    /**
                                     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
                                     * @method setStatic
                                     * @param {body} body
                                     * @param {bool} isStatic
                                     */
                                    Body.setStatic = function (body, isStatic) {
                                        for (
                                            var i = 0;
                                            i < body.parts.length;
                                            i++
                                        ) {
                                            var part = body.parts[i];
                                            part.isStatic = isStatic;

                                            if (isStatic) {
                                                part.restitution = 0;
                                                part.friction = 1;
                                                part.mass =
                                                    part.inertia =
                                                    part.density =
                                                        Infinity;
                                                part.inverseMass =
                                                    part.inverseInertia = 0;

                                                part.positionPrev.x =
                                                    part.position.x;
                                                part.positionPrev.y =
                                                    part.position.y;
                                                part.anglePrev = part.angle;
                                                part.angularVelocity = 0;
                                                part.speed = 0;
                                                part.angularSpeed = 0;
                                                part.motion = 0;
                                            }
                                        }
                                    };

                                    /**
                                     * Sets the mass of the body. Inverse mass and density are automatically updated to reflect the change.
                                     * @method setMass
                                     * @param {body} body
                                     * @param {number} mass
                                     */
                                    Body.setMass = function (body, mass) {
                                        body.mass = mass;
                                        body.inverseMass = 1 / body.mass;
                                        body.density = body.mass / body.area;
                                    };

                                    /**
                                     * Sets the density of the body. Mass is automatically updated to reflect the change.
                                     * @method setDensity
                                     * @param {body} body
                                     * @param {number} density
                                     */
                                    Body.setDensity = function (body, density) {
                                        Body.setMass(body, density * body.area);
                                        body.density = density;
                                    };

                                    /**
                                     * Sets the moment of inertia (i.e. second moment of area) of the body of the body.
                                     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
                                     * @method setInertia
                                     * @param {body} body
                                     * @param {number} inertia
                                     */
                                    Body.setInertia = function (body, inertia) {
                                        body.inertia = inertia;
                                        body.inverseInertia = 1 / body.inertia;
                                    };

                                    /**
                                     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
                                     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
                                     * They are then automatically translated to world space based on `body.position`.
                                     *
                                     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
                                     * Vertices must form a convex hull, concave hulls are not supported.
                                     *
                                     * @method setVertices
                                     * @param {body} body
                                     * @param {vector[]} vertices
                                     */
                                    Body.setVertices = function (
                                        body,
                                        vertices
                                    ) {
                                        // change vertices
                                        if (vertices[0].body === body) {
                                            body.vertices = vertices;
                                        } else {
                                            body.vertices = Vertices.create(
                                                vertices,
                                                body
                                            );
                                        }

                                        // update properties
                                        body.axes = Axes.fromVertices(
                                            body.vertices
                                        );
                                        body.area = Vertices.area(
                                            body.vertices
                                        );
                                        Body.setMass(
                                            body,
                                            body.density * body.area
                                        );

                                        // orient vertices around the centre of mass at origin (0, 0)
                                        var centre = Vertices.centre(
                                            body.vertices
                                        );
                                        Vertices.translate(
                                            body.vertices,
                                            centre,
                                            -1
                                        );

                                        // update inertia while vertices are at origin (0, 0)
                                        Body.setInertia(
                                            body,
                                            Body._inertiaScale *
                                                Vertices.inertia(
                                                    body.vertices,
                                                    body.mass
                                                )
                                        );

                                        // update geometry
                                        Vertices.translate(
                                            body.vertices,
                                            body.position
                                        );
                                        Bounds.update(
                                            body.bounds,
                                            body.vertices,
                                            body.velocity
                                        );
                                    };

                                    /**
                                     * Sets the parts of the `body` and updates mass, inertia and centroid.
                                     * Each part will have its parent set to `body`.
                                     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
                                     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
                                     * @method setParts
                                     * @param {body} body
                                     * @param [body] parts
                                     * @param {bool} [autoHull=true]
                                     */
                                    Body.setParts = function (
                                        body,
                                        parts,
                                        autoHull
                                    ) {
                                        var i;

                                        // add all the parts, ensuring that the first part is always the parent body
                                        parts = parts.slice(0);
                                        body.parts.length = 0;
                                        body.parts.push(body);
                                        body.parent = body;

                                        for (i = 0; i < parts.length; i++) {
                                            var part = parts[i];
                                            if (part !== body) {
                                                part.parent = body;
                                                body.parts.push(part);
                                            }
                                        }

                                        if (body.parts.length === 1) return;

                                        autoHull =
                                            typeof autoHull !== "undefined"
                                                ? autoHull
                                                : true;

                                        // find the convex hull of all parts to set on the parent body
                                        if (autoHull) {
                                            var vertices = [];
                                            for (i = 0; i < parts.length; i++) {
                                                vertices = vertices.concat(
                                                    parts[i].vertices
                                                );
                                            }

                                            Vertices.clockwiseSort(vertices);

                                            var hull = Vertices.hull(vertices),
                                                hullCentre =
                                                    Vertices.centre(hull);

                                            Body.setVertices(body, hull);
                                            Vertices.translate(
                                                body.vertices,
                                                hullCentre
                                            );
                                        }

                                        // sum the properties of all compound parts of the parent body
                                        var total = _totalProperties(body);

                                        body.area = total.area;
                                        body.parent = body;
                                        body.position.x = total.centre.x;
                                        body.position.y = total.centre.y;
                                        body.positionPrev.x = total.centre.x;
                                        body.positionPrev.y = total.centre.y;

                                        Body.setMass(body, total.mass);
                                        Body.setInertia(body, total.inertia);
                                        Body.setPosition(body, total.centre);
                                    };

                                    /**
                                     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
                                     * @method setPosition
                                     * @param {body} body
                                     * @param {vector} position
                                     */
                                    Body.setPosition = function (
                                        body,
                                        position
                                    ) {
                                        var delta = Vector.sub(
                                            position,
                                            body.position
                                        );
                                        body.positionPrev.x += delta.x;
                                        body.positionPrev.y += delta.y;

                                        for (
                                            var i = 0;
                                            i < body.parts.length;
                                            i++
                                        ) {
                                            var part = body.parts[i];
                                            part.position.x += delta.x;
                                            part.position.y += delta.y;
                                            Vertices.translate(
                                                part.vertices,
                                                delta
                                            );
                                            Bounds.update(
                                                part.bounds,
                                                part.vertices,
                                                body.velocity
                                            );
                                        }
                                    };

                                    /**
                                     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
                                     * @method setAngle
                                     * @param {body} body
                                     * @param {number} angle
                                     */
                                    Body.setAngle = function (body, angle) {
                                        var delta = angle - body.angle;
                                        body.anglePrev += delta;

                                        for (
                                            var i = 0;
                                            i < body.parts.length;
                                            i++
                                        ) {
                                            var part = body.parts[i];
                                            part.angle += delta;
                                            Vertices.rotate(
                                                part.vertices,
                                                delta,
                                                body.position
                                            );
                                            Axes.rotate(part.axes, delta);
                                            Bounds.update(
                                                part.bounds,
                                                part.vertices,
                                                body.velocity
                                            );
                                            if (i > 0) {
                                                Vector.rotateAbout(
                                                    part.position,
                                                    delta,
                                                    body.position,
                                                    part.position
                                                );
                                            }
                                        }
                                    };

                                    /**
                                     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
                                     * @method setVelocity
                                     * @param {body} body
                                     * @param {vector} velocity
                                     */
                                    Body.setVelocity = function (
                                        body,
                                        velocity
                                    ) {
                                        body.positionPrev.x =
                                            body.position.x - velocity.x;
                                        body.positionPrev.y =
                                            body.position.y - velocity.y;
                                        body.velocity.x = velocity.x;
                                        body.velocity.y = velocity.y;
                                        body.speed = Vector.magnitude(
                                            body.velocity
                                        );
                                    };

                                    /**
                                     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
                                     * @method setAngularVelocity
                                     * @param {body} body
                                     * @param {number} velocity
                                     */
                                    Body.setAngularVelocity = function (
                                        body,
                                        velocity
                                    ) {
                                        body.anglePrev = body.angle - velocity;
                                        body.angularVelocity = velocity;
                                        body.angularSpeed = Math.abs(
                                            body.angularVelocity
                                        );
                                    };

                                    /**
                                     * Moves a body by a given vector relative to its current position, without imparting any velocity.
                                     * @method translate
                                     * @param {body} body
                                     * @param {vector} translation
                                     */
                                    Body.translate = function (
                                        body,
                                        translation
                                    ) {
                                        Body.setPosition(
                                            body,
                                            Vector.add(
                                                body.position,
                                                translation
                                            )
                                        );
                                    };

                                    /**
                                     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
                                     * @method rotate
                                     * @param {body} body
                                     * @param {number} rotation
                                     */
                                    Body.rotate = function (body, rotation) {
                                        Body.setAngle(
                                            body,
                                            body.angle + rotation
                                        );
                                    };

                                    /**
                                     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
                                     * @method scale
                                     * @param {body} body
                                     * @param {number} scaleX
                                     * @param {number} scaleY
                                     * @param {vector} [point]
                                     */
                                    Body.scale = function (
                                        body,
                                        scaleX,
                                        scaleY,
                                        point
                                    ) {
                                        for (
                                            var i = 0;
                                            i < body.parts.length;
                                            i++
                                        ) {
                                            var part = body.parts[i];

                                            // scale vertices
                                            Vertices.scale(
                                                part.vertices,
                                                scaleX,
                                                scaleY,
                                                body.position
                                            );

                                            // update properties
                                            part.axes = Axes.fromVertices(
                                                part.vertices
                                            );

                                            if (!body.isStatic) {
                                                part.area = Vertices.area(
                                                    part.vertices
                                                );
                                                Body.setMass(
                                                    part,
                                                    body.density * part.area
                                                );

                                                // update inertia (requires vertices to be at origin)
                                                Vertices.translate(
                                                    part.vertices,
                                                    {
                                                        x: -part.position.x,
                                                        y: -part.position.y,
                                                    }
                                                );
                                                Body.setInertia(
                                                    part,
                                                    Vertices.inertia(
                                                        part.vertices,
                                                        part.mass
                                                    )
                                                );
                                                Vertices.translate(
                                                    part.vertices,
                                                    {
                                                        x: part.position.x,
                                                        y: part.position.y,
                                                    }
                                                );
                                            }

                                            // update bounds
                                            Bounds.update(
                                                part.bounds,
                                                part.vertices,
                                                body.velocity
                                            );
                                        }

                                        if (!body.isStatic) {
                                            var total = _totalProperties(body);
                                            body.area = total.area;
                                            Body.setMass(body, total.mass);
                                            Body.setInertia(
                                                body,
                                                total.inertia
                                            );
                                        }
                                    };

                                    /**
                                     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
                                     * @method update
                                     * @param {body} body
                                     * @param {number} deltaTime
                                     * @param {number} timeScale
                                     * @param {number} correction
                                     */
                                    Body.update = function (
                                        body,
                                        deltaTime,
                                        timeScale,
                                        correction
                                    ) {
                                        var deltaTimeSquared = Math.pow(
                                            deltaTime *
                                                timeScale *
                                                body.timeScale,
                                            2
                                        );

                                        // from the previous step
                                        var frictionAir =
                                                1 -
                                                body.frictionAir *
                                                    timeScale *
                                                    body.timeScale,
                                            velocityPrevX =
                                                body.position.x -
                                                body.positionPrev.x,
                                            velocityPrevY =
                                                body.position.y -
                                                body.positionPrev.y;

                                        // update velocity with Verlet integration
                                        body.velocity.x =
                                            velocityPrevX *
                                                frictionAir *
                                                correction +
                                            (body.force.x / body.mass) *
                                                deltaTimeSquared;
                                        body.velocity.y =
                                            velocityPrevY *
                                                frictionAir *
                                                correction +
                                            (body.force.y / body.mass) *
                                                deltaTimeSquared;

                                        body.positionPrev.x = body.position.x;
                                        body.positionPrev.y = body.position.y;
                                        body.position.x += body.velocity.x;
                                        body.position.y += body.velocity.y;

                                        // update angular velocity with Verlet integration
                                        body.angularVelocity =
                                            (body.angle - body.anglePrev) *
                                                frictionAir *
                                                correction +
                                            (body.torque / body.inertia) *
                                                deltaTimeSquared;
                                        body.anglePrev = body.angle;
                                        body.angle += body.angularVelocity;

                                        // track speed and acceleration
                                        body.speed = Vector.magnitude(
                                            body.velocity
                                        );
                                        body.angularSpeed = Math.abs(
                                            body.angularVelocity
                                        );

                                        // transform the body geometry
                                        for (
                                            var i = 0;
                                            i < body.parts.length;
                                            i++
                                        ) {
                                            var part = body.parts[i];

                                            Vertices.translate(
                                                part.vertices,
                                                body.velocity
                                            );

                                            if (i > 0) {
                                                part.position.x +=
                                                    body.velocity.x;
                                                part.position.y +=
                                                    body.velocity.y;
                                            }

                                            if (body.angularVelocity !== 0) {
                                                Vertices.rotate(
                                                    part.vertices,
                                                    body.angularVelocity,
                                                    body.position
                                                );
                                                Axes.rotate(
                                                    part.axes,
                                                    body.angularVelocity
                                                );
                                                if (i > 0) {
                                                    Vector.rotateAbout(
                                                        part.position,
                                                        body.angularVelocity,
                                                        body.position,
                                                        part.position
                                                    );
                                                }
                                            }

                                            Bounds.update(
                                                part.bounds,
                                                part.vertices,
                                                body.velocity
                                            );
                                        }
                                    };

                                    /**
                                     * Applies a force to a body from a given world-space position, including resulting torque.
                                     * @method applyForce
                                     * @param {body} body
                                     * @param {vector} position
                                     * @param {vector} force
                                     */
                                    Body.applyForce = function (
                                        body,
                                        position,
                                        force
                                    ) {
                                        body.force.x += force.x;
                                        body.force.y += force.y;
                                        var offset = {
                                            x: position.x - body.position.x,
                                            y: position.y - body.position.y,
                                        };
                                        body.torque +=
                                            offset.x * force.y -
                                            offset.y * force.x;
                                    };

                                    /**
                                     * Returns the sums of the properties of all compound parts of the parent body.
                                     * @method _totalProperties
                                     * @private
                                     * @param {body} body
                                     * @return {}
                                     */
                                    var _totalProperties = function (body) {
                                        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory
                                        // http://output.to/sideway/default.asp?qno=121100087

                                        var properties = {
                                            mass: 0,
                                            area: 0,
                                            inertia: 0,
                                            centre: { x: 0, y: 0 },
                                        };

                                        // sum the properties of all compound parts of the parent body
                                        for (
                                            var i =
                                                body.parts.length === 1 ? 0 : 1;
                                            i < body.parts.length;
                                            i++
                                        ) {
                                            var part = body.parts[i];
                                            properties.mass += part.mass;
                                            properties.area += part.area;
                                            properties.inertia += part.inertia;
                                            properties.centre = Vector.add(
                                                properties.centre,
                                                Vector.mult(
                                                    part.position,
                                                    part.mass !== Infinity
                                                        ? part.mass
                                                        : 1
                                                )
                                            );
                                        }

                                        properties.centre = Vector.div(
                                            properties.centre,
                                            properties.mass !== Infinity
                                                ? properties.mass
                                                : body.parts.length
                                        );

                                        return properties;
                                    };

                                    /*
                                     *
                                     *  Events Documentation
                                     *
                                     */

                                    /**
                                     * Fired when a body starts sleeping (where `this` is the body).
                                     *
                                     * @event sleepStart
                                     * @this {body} The body that has started sleeping
                                     * @param {} event An event object
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when a body ends sleeping (where `this` is the body).
                                     *
                                     * @event sleepEnd
                                     * @this {body} The body that has ended sleeping
                                     * @param {} event An event object
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
                                     *
                                     * @property id
                                     * @type number
                                     */

                                    /**
                                     * A `String` denoting the type of object.
                                     *
                                     * @property type
                                     * @type string
                                     * @default "body"
                                     */

                                    /**
                                     * An arbitrary `String` name to help the user identify and manage bodies.
                                     *
                                     * @property label
                                     * @type string
                                     * @default "Body"
                                     */

                                    /**
                                     * An array of bodies that make up this body.
                                     * The first body in the array must always be a self reference to the current body instance.
                                     * All bodies in the `parts` array together form a single rigid compound body.
                                     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.
                                     * Parts themselves should never be added to a `World`, only the parent body should be.
                                     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.
                                     *
                                     * @property parts
                                     * @type body[]
                                     */

                                    /**
                                     * A self reference if the body is _not_ a part of another body.
                                     * Otherwise this is a reference to the body that this is a part of.
                                     * See `body.parts`.
                                     *
                                     * @property parent
                                     * @type body
                                     */

                                    /**
                                     * A `Number` specifying the angle of the body, in radians.
                                     *
                                     * @property angle
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * An array of `Vector` objects that specify the convex hull of the rigid body.
                                     * These should be provided about the origin `(0, 0)`. E.g.
                                     *
                                     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
                                     *
                                     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
                                     * The `Vector` objects are also augmented with additional properties required for efficient collision detection.
                                     *
                                     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
                                     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
                                     *
                                     * @property vertices
                                     * @type vector[]
                                     */

                                    /**
                                     * A `Vector` that specifies the current world-space position of the body.
                                     *
                                     * @property position
                                     * @type vector
                                     * @default { x: 0, y: 0 }
                                     */

                                    /**
                                     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
                                     *
                                     * @property force
                                     * @type vector
                                     * @default { x: 0, y: 0 }
                                     */

                                    /**
                                     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
                                     *
                                     * @property torque
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
                                     *
                                     * @readOnly
                                     * @property speed
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
                                     *
                                     * @readOnly
                                     * @property angularSpeed
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only.
                                     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
                                     *
                                     * @readOnly
                                     * @property velocity
                                     * @type vector
                                     * @default { x: 0, y: 0 }
                                     */

                                    /**
                                     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only.
                                     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
                                     *
                                     * @readOnly
                                     * @property angularVelocity
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
                                     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
                                     *
                                     * @property isStatic
                                     * @type boolean
                                     * @default false
                                     */

                                    /**
                                     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
                                     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
                                     *
                                     * @property isSleeping
                                     * @type boolean
                                     * @default false
                                     */

                                    /**
                                     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
                                     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
                                     *
                                     * @readOnly
                                     * @property motion
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
                                     *
                                     * @property sleepThreshold
                                     * @type number
                                     * @default 60
                                     */

                                    /**
                                     * A `Number` that defines the density of the body, that is its mass per unit area.
                                     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
                                     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
                                     *
                                     * @property density
                                     * @type number
                                     * @default 0.001
                                     */

                                    /**
                                     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
                                     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
                                     *
                                     * @property mass
                                     * @type number
                                     */

                                    /**
                                     * A `Number` that defines the inverse mass of the body (`1 / mass`).
                                     * If you modify this value, you must also modify the `body.mass` property.
                                     *
                                     * @property inverseMass
                                     * @type number
                                     */

                                    /**
                                     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
                                     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
                                     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
                                     *
                                     * @property inertia
                                     * @type number
                                     */

                                    /**
                                     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
                                     * If you modify this value, you must also modify the `body.inertia` property.
                                     *
                                     * @property inverseInertia
                                     * @type number
                                     */

                                    /**
                                     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
                                     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur.
                                     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
                                     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:
                                     *
                                     *     Math.max(bodyA.restitution, bodyB.restitution)
                                     *
                                     * @property restitution
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
                                     * A value of `0` means that the body may slide indefinitely.
                                     * A value of `1` means the body may come to a stop almost instantly after a force is applied.
                                     *
                                     * The effects of the value may be non-linear.
                                     * High values may be unstable depending on the body.
                                     * The engine uses a Coulomb friction model including static and kinetic friction.
                                     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:
                                     *
                                     *     Math.min(bodyA.friction, bodyB.friction)
                                     *
                                     * @property friction
                                     * @type number
                                     * @default 0.1
                                     */

                                    /**
                                     * A `Number` that defines the static friction of the body (in the Coulomb friction model).
                                     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
                                     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
                                     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
                                     *
                                     * @property frictionStatic
                                     * @type number
                                     * @default 0.5
                                     */

                                    /**
                                     * A `Number` that defines the air friction of the body (air resistance).
                                     * A value of `0` means the body will never slow as it moves through space.
                                     * The higher the value, the faster a body slows when moving through space.
                                     * The effects of the value are non-linear.
                                     *
                                     * @property frictionAir
                                     * @type number
                                     * @default 0.01
                                     */

                                    /**
                                     * An `Object` that specifies the collision filtering properties of this body.
                                     *
                                     * Collisions between two bodies will obey the following rules:
                                     * - If the two bodies have the same non-zero value of `collisionFilter.group`,
                                     *   they will always collide if the value is positive, and they will never collide
                                     *   if the value is negative.
                                     * - If the two bodies have different values of `collisionFilter.group` or if one
                                     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:
                                     *
                                     * Each body belongs to a collision category, given by `collisionFilter.category`. This
                                     * value is used as a bit field and the category should have only one bit set, meaning that
                                     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
                                     * different collision categories available.
                                     *
                                     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
                                     * the categories it collides with (the value is the bitwise AND value of all these categories).
                                     *
                                     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
                                     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
                                     * are both true.
                                     *
                                     * @property collisionFilter
                                     * @type object
                                     */

                                    /**
                                     * An Integer `Number`, that specifies the collision group this body belongs to.
                                     * See `body.collisionFilter` for more information.
                                     *
                                     * @property collisionFilter.group
                                     * @type object
                                     * @default 0
                                     */

                                    /**
                                     * A bit field that specifies the collision category this body belongs to.
                                     * The category value should have only one bit set, for example `0x0001`.
                                     * This means there are up to 32 unique collision categories available.
                                     * See `body.collisionFilter` for more information.
                                     *
                                     * @property collisionFilter.category
                                     * @type object
                                     * @default 1
                                     */

                                    /**
                                     * A bit mask that specifies the collision categories this body may collide with.
                                     * See `body.collisionFilter` for more information.
                                     *
                                     * @property collisionFilter.mask
                                     * @type object
                                     * @default -1
                                     */

                                    /**
                                     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
                                     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
                                     * The default should generally suffice, although very large bodies may require larger values for stable stacking.
                                     *
                                     * @property slop
                                     * @type number
                                     * @default 0.05
                                     */

                                    /**
                                     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
                                     *
                                     * @property timeScale
                                     * @type number
                                     * @default 1
                                     */

                                    /**
                                     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
                                     *
                                     * @property render
                                     * @type object
                                     */

                                    /**
                                     * A flag that indicates if the body should be rendered.
                                     *
                                     * @property render.visible
                                     * @type boolean
                                     * @default true
                                     */

                                    /**
                                     * Sets the opacity to use when rendering.
                                     *
                                     * @property render.opacity
                                     * @type number
                                     * @default 1
                                     */

                                    /**
                                     * An `Object` that defines the sprite properties to use when rendering, if any.
                                     *
                                     * @property render.sprite
                                     * @type object
                                     */

                                    /**
                                     * An `String` that defines the path to the image to use as the sprite texture, if any.
                                     *
                                     * @property render.sprite.texture
                                     * @type string
                                     */

                                    /**
                                     * A `Number` that defines the scaling in the x-axis for the sprite, if any.
                                     *
                                     * @property render.sprite.xScale
                                     * @type number
                                     * @default 1
                                     */

                                    /**
                                     * A `Number` that defines the scaling in the y-axis for the sprite, if any.
                                     *
                                     * @property render.sprite.yScale
                                     * @type number
                                     * @default 1
                                     */

                                    /**
                                     * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).
                                     *
                                     * @property render.sprite.xOffset
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).
                                     *
                                     * @property render.sprite.yOffset
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).
                                     * A value of `0` means no outline will be rendered.
                                     *
                                     * @property render.lineWidth
                                     * @type number
                                     * @default 1.5
                                     */

                                    /**
                                     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).
                                     * It is the same as when using a canvas, so it accepts CSS style property values.
                                     *
                                     * @property render.fillStyle
                                     * @type string
                                     * @default a random colour
                                     */

                                    /**
                                     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).
                                     * It is the same as when using a canvas, so it accepts CSS style property values.
                                     *
                                     * @property render.strokeStyle
                                     * @type string
                                     * @default a random colour
                                     */

                                    /**
                                     * An array of unique axis vectors (edge normals) used for collision detection.
                                     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
                                     * They are constantly updated by `Body.update` during the simulation.
                                     *
                                     * @property axes
                                     * @type vector[]
                                     */

                                    /**
                                     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
                                     *
                                     * @property area
                                     * @type string
                                     * @default
                                     */

                                    /**
                                     * A `Bounds` object that defines the AABB region for the body.
                                     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
                                     *
                                     * @property bounds
                                     * @type bounds
                                     */
                                })();
                            },
                            {
                                "../core/Common": 14,
                                "../core/Sleeping": 20,
                                "../geometry/Axes": 23,
                                "../geometry/Bounds": 24,
                                "../geometry/Vector": 26,
                                "../geometry/Vertices": 27,
                                "../render/Render": 29,
                            },
                        ],
                        2: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
                                 * A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
                                 * It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
                                 * Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Composite
                                 */

                                var Composite = {};

                                module.exports = Composite;

                                var Events = require("../core/Events");
                                var Common = require("../core/Common");
                                var Body = require("./Body");

                                (function () {
                                    /**
                                     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * See the properites section below for detailed information on what you can pass via the `options` object.
                                     * @method create
                                     * @param {} [options]
                                     * @return {composite} A new composite
                                     */
                                    Composite.create = function (options) {
                                        return Common.extend(
                                            {
                                                id: Common.nextId(),
                                                type: "composite",
                                                parent: null,
                                                isModified: false,
                                                bodies: [],
                                                constraints: [],
                                                composites: [],
                                                label: "Composite",
                                            },
                                            options
                                        );
                                    };

                                    /**
                                     * Sets the composite's `isModified` flag.
                                     * If `updateParents` is true, all parents will be set (default: false).
                                     * If `updateChildren` is true, all children will be set (default: false).
                                     * @method setModified
                                     * @param {composite} composite
                                     * @param {boolean} isModified
                                     * @param {boolean} [updateParents=false]
                                     * @param {boolean} [updateChildren=false]
                                     */
                                    Composite.setModified = function (
                                        composite,
                                        isModified,
                                        updateParents,
                                        updateChildren
                                    ) {
                                        composite.isModified = isModified;

                                        if (updateParents && composite.parent) {
                                            Composite.setModified(
                                                composite.parent,
                                                isModified,
                                                updateParents,
                                                updateChildren
                                            );
                                        }

                                        if (updateChildren) {
                                            for (
                                                var i = 0;
                                                i < composite.composites.length;
                                                i++
                                            ) {
                                                var childComposite =
                                                    composite.composites[i];
                                                Composite.setModified(
                                                    childComposite,
                                                    isModified,
                                                    updateParents,
                                                    updateChildren
                                                );
                                            }
                                        }
                                    };

                                    /**
                                     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
                                     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
                                     * @method add
                                     * @param {composite} composite
                                     * @param {} object
                                     * @return {composite} The original composite with the objects added
                                     */
                                    Composite.add = function (
                                        composite,
                                        object
                                    ) {
                                        var objects = [].concat(object);

                                        Events.trigger(composite, "beforeAdd", {
                                            object: object,
                                        });

                                        for (
                                            var i = 0;
                                            i < objects.length;
                                            i++
                                        ) {
                                            var obj = objects[i];

                                            switch (obj.type) {
                                                case "body":
                                                    // skip adding compound parts
                                                    if (obj.parent !== obj) {
                                                        Common.log(
                                                            "Composite.add: skipped adding a compound body part (you must add its parent instead)",
                                                            "warn"
                                                        );
                                                        break;
                                                    }

                                                    Composite.addBody(
                                                        composite,
                                                        obj
                                                    );
                                                    break;
                                                case "constraint":
                                                    Composite.addConstraint(
                                                        composite,
                                                        obj
                                                    );
                                                    break;
                                                case "composite":
                                                    Composite.addComposite(
                                                        composite,
                                                        obj
                                                    );
                                                    break;
                                                case "mouseConstraint":
                                                    Composite.addConstraint(
                                                        composite,
                                                        obj.constraint
                                                    );
                                                    break;
                                            }
                                        }

                                        Events.trigger(composite, "afterAdd", {
                                            object: object,
                                        });

                                        return composite;
                                    };

                                    /**
                                     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
                                     * Optionally searching its children recursively.
                                     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
                                     * @method remove
                                     * @param {composite} composite
                                     * @param {} object
                                     * @param {boolean} [deep=false]
                                     * @return {composite} The original composite with the objects removed
                                     */
                                    Composite.remove = function (
                                        composite,
                                        object,
                                        deep
                                    ) {
                                        var objects = [].concat(object);

                                        Events.trigger(
                                            composite,
                                            "beforeRemove",
                                            { object: object }
                                        );

                                        for (
                                            var i = 0;
                                            i < objects.length;
                                            i++
                                        ) {
                                            var obj = objects[i];

                                            switch (obj.type) {
                                                case "body":
                                                    Composite.removeBody(
                                                        composite,
                                                        obj,
                                                        deep
                                                    );
                                                    break;
                                                case "constraint":
                                                    Composite.removeConstraint(
                                                        composite,
                                                        obj,
                                                        deep
                                                    );
                                                    break;
                                                case "composite":
                                                    Composite.removeComposite(
                                                        composite,
                                                        obj,
                                                        deep
                                                    );
                                                    break;
                                                case "mouseConstraint":
                                                    Composite.removeConstraint(
                                                        composite,
                                                        obj.constraint
                                                    );
                                                    break;
                                            }
                                        }

                                        Events.trigger(
                                            composite,
                                            "afterRemove",
                                            { object: object }
                                        );

                                        return composite;
                                    };

                                    /**
                                     * Adds a composite to the given composite.
                                     * @private
                                     * @method addComposite
                                     * @param {composite} compositeA
                                     * @param {composite} compositeB
                                     * @return {composite} The original compositeA with the objects from compositeB added
                                     */
                                    Composite.addComposite = function (
                                        compositeA,
                                        compositeB
                                    ) {
                                        compositeA.composites.push(compositeB);
                                        compositeB.parent = compositeA;
                                        Composite.setModified(
                                            compositeA,
                                            true,
                                            true,
                                            false
                                        );
                                        return compositeA;
                                    };

                                    /**
                                     * Removes a composite from the given composite, and optionally searching its children recursively.
                                     * @private
                                     * @method removeComposite
                                     * @param {composite} compositeA
                                     * @param {composite} compositeB
                                     * @param {boolean} [deep=false]
                                     * @return {composite} The original compositeA with the composite removed
                                     */
                                    Composite.removeComposite = function (
                                        compositeA,
                                        compositeB,
                                        deep
                                    ) {
                                        var position = Common.indexOf(
                                            compositeA.composites,
                                            compositeB
                                        );
                                        if (position !== -1) {
                                            Composite.removeCompositeAt(
                                                compositeA,
                                                position
                                            );
                                            Composite.setModified(
                                                compositeA,
                                                true,
                                                true,
                                                false
                                            );
                                        }

                                        if (deep) {
                                            for (
                                                var i = 0;
                                                i <
                                                compositeA.composites.length;
                                                i++
                                            ) {
                                                Composite.removeComposite(
                                                    compositeA.composites[i],
                                                    compositeB,
                                                    true
                                                );
                                            }
                                        }

                                        return compositeA;
                                    };

                                    /**
                                     * Removes a composite from the given composite.
                                     * @private
                                     * @method removeCompositeAt
                                     * @param {composite} composite
                                     * @param {number} position
                                     * @return {composite} The original composite with the composite removed
                                     */
                                    Composite.removeCompositeAt = function (
                                        composite,
                                        position
                                    ) {
                                        composite.composites.splice(
                                            position,
                                            1
                                        );
                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );
                                        return composite;
                                    };

                                    /**
                                     * Adds a body to the given composite.
                                     * @private
                                     * @method addBody
                                     * @param {composite} composite
                                     * @param {body} body
                                     * @return {composite} The original composite with the body added
                                     */
                                    Composite.addBody = function (
                                        composite,
                                        body
                                    ) {
                                        composite.bodies.push(body);
                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );
                                        return composite;
                                    };

                                    /**
                                     * Removes a body from the given composite, and optionally searching its children recursively.
                                     * @private
                                     * @method removeBody
                                     * @param {composite} composite
                                     * @param {body} body
                                     * @param {boolean} [deep=false]
                                     * @return {composite} The original composite with the body removed
                                     */
                                    Composite.removeBody = function (
                                        composite,
                                        body,
                                        deep
                                    ) {
                                        var position = Common.indexOf(
                                            composite.bodies,
                                            body
                                        );
                                        if (position !== -1) {
                                            Composite.removeBodyAt(
                                                composite,
                                                position
                                            );
                                            Composite.setModified(
                                                composite,
                                                true,
                                                true,
                                                false
                                            );
                                        }

                                        if (deep) {
                                            for (
                                                var i = 0;
                                                i < composite.composites.length;
                                                i++
                                            ) {
                                                Composite.removeBody(
                                                    composite.composites[i],
                                                    body,
                                                    true
                                                );
                                            }
                                        }

                                        return composite;
                                    };

                                    /**
                                     * Removes a body from the given composite.
                                     * @private
                                     * @method removeBodyAt
                                     * @param {composite} composite
                                     * @param {number} position
                                     * @return {composite} The original composite with the body removed
                                     */
                                    Composite.removeBodyAt = function (
                                        composite,
                                        position
                                    ) {
                                        composite.bodies.splice(position, 1);
                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );
                                        return composite;
                                    };

                                    /**
                                     * Adds a constraint to the given composite.
                                     * @private
                                     * @method addConstraint
                                     * @param {composite} composite
                                     * @param {constraint} constraint
                                     * @return {composite} The original composite with the constraint added
                                     */
                                    Composite.addConstraint = function (
                                        composite,
                                        constraint
                                    ) {
                                        composite.constraints.push(constraint);
                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );
                                        return composite;
                                    };

                                    /**
                                     * Removes a constraint from the given composite, and optionally searching its children recursively.
                                     * @private
                                     * @method removeConstraint
                                     * @param {composite} composite
                                     * @param {constraint} constraint
                                     * @param {boolean} [deep=false]
                                     * @return {composite} The original composite with the constraint removed
                                     */
                                    Composite.removeConstraint = function (
                                        composite,
                                        constraint,
                                        deep
                                    ) {
                                        var position = Common.indexOf(
                                            composite.constraints,
                                            constraint
                                        );
                                        if (position !== -1) {
                                            Composite.removeConstraintAt(
                                                composite,
                                                position
                                            );
                                        }

                                        if (deep) {
                                            for (
                                                var i = 0;
                                                i < composite.composites.length;
                                                i++
                                            ) {
                                                Composite.removeConstraint(
                                                    composite.composites[i],
                                                    constraint,
                                                    true
                                                );
                                            }
                                        }

                                        return composite;
                                    };

                                    /**
                                     * Removes a body from the given composite.
                                     * @private
                                     * @method removeConstraintAt
                                     * @param {composite} composite
                                     * @param {number} position
                                     * @return {composite} The original composite with the constraint removed
                                     */
                                    Composite.removeConstraintAt = function (
                                        composite,
                                        position
                                    ) {
                                        composite.constraints.splice(
                                            position,
                                            1
                                        );
                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );
                                        return composite;
                                    };

                                    /**
                                     * Removes all bodies, constraints and composites from the given composite.
                                     * Optionally clearing its children recursively.
                                     * @method clear
                                     * @param {composite} composite
                                     * @param {boolean} keepStatic
                                     * @param {boolean} [deep=false]
                                     */
                                    Composite.clear = function (
                                        composite,
                                        keepStatic,
                                        deep
                                    ) {
                                        if (deep) {
                                            for (
                                                var i = 0;
                                                i < composite.composites.length;
                                                i++
                                            ) {
                                                Composite.clear(
                                                    composite.composites[i],
                                                    keepStatic,
                                                    true
                                                );
                                            }
                                        }

                                        if (keepStatic) {
                                            composite.bodies =
                                                composite.bodies.filter(
                                                    function (body) {
                                                        return body.isStatic;
                                                    }
                                                );
                                        } else {
                                            composite.bodies.length = 0;
                                        }

                                        composite.constraints.length = 0;
                                        composite.composites.length = 0;
                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );

                                        return composite;
                                    };

                                    /**
                                     * Returns all bodies in the given composite, including all bodies in its children, recursively.
                                     * @method allBodies
                                     * @param {composite} composite
                                     * @return {body[]} All the bodies
                                     */
                                    Composite.allBodies = function (composite) {
                                        var bodies = [].concat(
                                            composite.bodies
                                        );

                                        for (
                                            var i = 0;
                                            i < composite.composites.length;
                                            i++
                                        )
                                            bodies = bodies.concat(
                                                Composite.allBodies(
                                                    composite.composites[i]
                                                )
                                            );

                                        return bodies;
                                    };

                                    /**
                                     * Returns all constraints in the given composite, including all constraints in its children, recursively.
                                     * @method allConstraints
                                     * @param {composite} composite
                                     * @return {constraint[]} All the constraints
                                     */
                                    Composite.allConstraints = function (
                                        composite
                                    ) {
                                        var constraints = [].concat(
                                            composite.constraints
                                        );

                                        for (
                                            var i = 0;
                                            i < composite.composites.length;
                                            i++
                                        )
                                            constraints = constraints.concat(
                                                Composite.allConstraints(
                                                    composite.composites[i]
                                                )
                                            );

                                        return constraints;
                                    };

                                    /**
                                     * Returns all composites in the given composite, including all composites in its children, recursively.
                                     * @method allComposites
                                     * @param {composite} composite
                                     * @return {composite[]} All the composites
                                     */
                                    Composite.allComposites = function (
                                        composite
                                    ) {
                                        var composites = [].concat(
                                            composite.composites
                                        );

                                        for (
                                            var i = 0;
                                            i < composite.composites.length;
                                            i++
                                        )
                                            composites = composites.concat(
                                                Composite.allComposites(
                                                    composite.composites[i]
                                                )
                                            );

                                        return composites;
                                    };

                                    /**
                                     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
                                     * @method get
                                     * @param {composite} composite
                                     * @param {number} id
                                     * @param {string} type
                                     * @return {object} The requested object, if found
                                     */
                                    Composite.get = function (
                                        composite,
                                        id,
                                        type
                                    ) {
                                        var objects, object;

                                        switch (type) {
                                            case "body":
                                                objects =
                                                    Composite.allBodies(
                                                        composite
                                                    );
                                                break;
                                            case "constraint":
                                                objects =
                                                    Composite.allConstraints(
                                                        composite
                                                    );
                                                break;
                                            case "composite":
                                                objects =
                                                    Composite.allComposites(
                                                        composite
                                                    ).concat(composite);
                                                break;
                                        }

                                        if (!objects) return null;

                                        object = objects.filter(function (
                                            object
                                        ) {
                                            return (
                                                object.id.toString() ===
                                                id.toString()
                                            );
                                        });

                                        return object.length === 0
                                            ? null
                                            : object[0];
                                    };

                                    /**
                                     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
                                     * @method move
                                     * @param {compositeA} compositeA
                                     * @param {object[]} objects
                                     * @param {compositeB} compositeB
                                     * @return {composite} Returns compositeA
                                     */
                                    Composite.move = function (
                                        compositeA,
                                        objects,
                                        compositeB
                                    ) {
                                        Composite.remove(compositeA, objects);
                                        Composite.add(compositeB, objects);
                                        return compositeA;
                                    };

                                    /**
                                     * Assigns new ids for all objects in the composite, recursively.
                                     * @method rebase
                                     * @param {composite} composite
                                     * @return {composite} Returns composite
                                     */
                                    Composite.rebase = function (composite) {
                                        var objects = Composite.allBodies(
                                            composite
                                        )
                                            .concat(
                                                Composite.allConstraints(
                                                    composite
                                                )
                                            )
                                            .concat(
                                                Composite.allComposites(
                                                    composite
                                                )
                                            );

                                        for (
                                            var i = 0;
                                            i < objects.length;
                                            i++
                                        ) {
                                            objects[i].id = Common.nextId();
                                        }

                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );

                                        return composite;
                                    };

                                    /**
                                     * Translates all children in the composite by a given vector relative to their current positions,
                                     * without imparting any velocity.
                                     * @method translate
                                     * @param {composite} composite
                                     * @param {vector} translation
                                     * @param {bool} [recursive=true]
                                     */
                                    Composite.translate = function (
                                        composite,
                                        translation,
                                        recursive
                                    ) {
                                        var bodies = recursive
                                            ? Composite.allBodies(composite)
                                            : composite.bodies;

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            Body.translate(
                                                bodies[i],
                                                translation
                                            );
                                        }

                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );

                                        return composite;
                                    };

                                    /**
                                     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
                                     * @method rotate
                                     * @param {composite} composite
                                     * @param {number} rotation
                                     * @param {vector} point
                                     * @param {bool} [recursive=true]
                                     */
                                    Composite.rotate = function (
                                        composite,
                                        rotation,
                                        point,
                                        recursive
                                    ) {
                                        var cos = Math.cos(rotation),
                                            sin = Math.sin(rotation),
                                            bodies = recursive
                                                ? Composite.allBodies(composite)
                                                : composite.bodies;

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i],
                                                dx = body.position.x - point.x,
                                                dy = body.position.y - point.y;

                                            Body.setPosition(body, {
                                                x:
                                                    point.x +
                                                    (dx * cos - dy * sin),
                                                y:
                                                    point.y +
                                                    (dx * sin + dy * cos),
                                            });

                                            Body.rotate(body, rotation);
                                        }

                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );

                                        return composite;
                                    };

                                    /**
                                     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
                                     * @method scale
                                     * @param {composite} composite
                                     * @param {number} scaleX
                                     * @param {number} scaleY
                                     * @param {vector} point
                                     * @param {bool} [recursive=true]
                                     */
                                    Composite.scale = function (
                                        composite,
                                        scaleX,
                                        scaleY,
                                        point,
                                        recursive
                                    ) {
                                        var bodies = recursive
                                            ? Composite.allBodies(composite)
                                            : composite.bodies;

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i],
                                                dx = body.position.x - point.x,
                                                dy = body.position.y - point.y;

                                            Body.setPosition(body, {
                                                x: point.x + dx * scaleX,
                                                y: point.y + dy * scaleY,
                                            });

                                            Body.scale(body, scaleX, scaleY);
                                        }

                                        Composite.setModified(
                                            composite,
                                            true,
                                            true,
                                            false
                                        );

                                        return composite;
                                    };

                                    /*
                                     *
                                     *  Events Documentation
                                     *
                                     */

                                    /**
                                     * Fired when a call to `Composite.add` is made, before objects have been added.
                                     *
                                     * @event beforeAdd
                                     * @param {} event An event object
                                     * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when a call to `Composite.add` is made, after objects have been added.
                                     *
                                     * @event afterAdd
                                     * @param {} event An event object
                                     * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when a call to `Composite.remove` is made, before objects have been removed.
                                     *
                                     * @event beforeRemove
                                     * @param {} event An event object
                                     * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when a call to `Composite.remove` is made, after objects have been removed.
                                     *
                                     * @event afterRemove
                                     * @param {} event An event object
                                     * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
                                     *
                                     * @property id
                                     * @type number
                                     */

                                    /**
                                     * A `String` denoting the type of object.
                                     *
                                     * @property type
                                     * @type string
                                     * @default "composite"
                                     */

                                    /**
                                     * An arbitrary `String` name to help the user identify and manage composites.
                                     *
                                     * @property label
                                     * @type string
                                     * @default "Composite"
                                     */

                                    /**
                                     * A flag that specifies whether the composite has been modified during the current step.
                                     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
                                     * If you need to change it manually, you should use the `Composite.setModified` method.
                                     *
                                     * @property isModified
                                     * @type boolean
                                     * @default false
                                     */

                                    /**
                                     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
                                     *
                                     * @property parent
                                     * @type composite
                                     * @default null
                                     */

                                    /**
                                     * An array of `Body` that are _direct_ children of this composite.
                                     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
                                     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
                                     *
                                     * @property bodies
                                     * @type body[]
                                     * @default []
                                     */

                                    /**
                                     * An array of `Constraint` that are _direct_ children of this composite.
                                     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
                                     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
                                     *
                                     * @property constraints
                                     * @type constraint[]
                                     * @default []
                                     */

                                    /**
                                     * An array of `Composite` that are _direct_ children of this composite.
                                     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
                                     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
                                     *
                                     * @property composites
                                     * @type composite[]
                                     * @default []
                                     */
                                })();
                            },
                            {
                                "../core/Common": 14,
                                "../core/Events": 16,
                                "./Body": 1,
                            },
                        ],
                        3: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.World` module contains methods for creating and manipulating the world composite.
                                 * A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
                                 * A `Matter.World` has a few additional properties including `gravity` and `bounds`.
                                 * It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
                                 * There are also a few methods here that alias those in `Matter.Composite` for easier readability.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class World
                                 * @extends Composite
                                 */

                                var World = {};

                                module.exports = World;

                                var Composite = require("./Composite");
                                var Constraint = require("../constraint/Constraint");
                                var Common = require("../core/Common");

                                (function () {
                                    /**
                                     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * See the properties section below for detailed information on what you can pass via the `options` object.
                                     * @method create
                                     * @constructor
                                     * @param {} options
                                     * @return {world} A new world
                                     */
                                    World.create = function (options) {
                                        var composite = Composite.create();

                                        var defaults = {
                                            label: "World",
                                            gravity: {
                                                x: 0,
                                                y: 1,
                                                scale: 0.001,
                                            },
                                            bounds: {
                                                min: {
                                                    x: -Infinity,
                                                    y: -Infinity,
                                                },
                                                max: {
                                                    x: Infinity,
                                                    y: Infinity,
                                                },
                                            },
                                        };

                                        return Common.extend(
                                            composite,
                                            defaults,
                                            options
                                        );
                                    };

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * The gravity to apply on the world.
                                     *
                                     * @property gravity
                                     * @type object
                                     */

                                    /**
                                     * The gravity x component.
                                     *
                                     * @property gravity.x
                                     * @type object
                                     * @default 0
                                     */

                                    /**
                                     * The gravity y component.
                                     *
                                     * @property gravity.y
                                     * @type object
                                     * @default 1
                                     */

                                    /**
                                     * The gravity scale factor.
                                     *
                                     * @property gravity.scale
                                     * @type object
                                     * @default 0.001
                                     */

                                    // World is a Composite body
                                    // see src/module/Outro.js for these aliases:

                                    /**
                                     * An alias for Composite.clear
                                     * @method clear
                                     * @param {world} world
                                     * @param {boolean} keepStatic
                                     */

                                    /**
                                     * An alias for Composite.add
                                     * @method addComposite
                                     * @param {world} world
                                     * @param {composite} composite
                                     * @return {world} The original world with the objects from composite added
                                     */

                                    /**
                                     * An alias for Composite.addBody
                                     * @method addBody
                                     * @param {world} world
                                     * @param {body} body
                                     * @return {world} The original world with the body added
                                     */

                                    /**
                                     * An alias for Composite.addConstraint
                                     * @method addConstraint
                                     * @param {world} world
                                     * @param {constraint} constraint
                                     * @return {world} The original world with the constraint added
                                     */
                                })();
                            },
                            {
                                "../constraint/Constraint": 12,
                                "../core/Common": 14,
                                "./Composite": 2,
                            },
                        ],
                        4: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
                                 *
                                 * @class Contact
                                 */

                                var Contact = {};

                                module.exports = Contact;

                                (function () {
                                    /**
                                     * Creates a new contact.
                                     * @method create
                                     * @param {vertex} vertex
                                     * @return {contact} A new contact
                                     */
                                    Contact.create = function (vertex) {
                                        return {
                                            id: Contact.id(vertex),
                                            vertex: vertex,
                                            normalImpulse: 0,
                                            tangentImpulse: 0,
                                        };
                                    };

                                    /**
                                     * Generates a contact id.
                                     * @method id
                                     * @param {vertex} vertex
                                     * @return {string} Unique contactID
                                     */
                                    Contact.id = function (vertex) {
                                        return (
                                            vertex.body.id + "_" + vertex.index
                                        );
                                    };
                                })();
                            },
                            {},
                        ],
                        5: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
                                 *
                                 * @class Detector
                                 */

                                // TODO: speculative contacts

                                var Detector = {};

                                module.exports = Detector;

                                var SAT = require("./SAT");
                                var Pair = require("./Pair");
                                var Bounds = require("../geometry/Bounds");

                                (function () {
                                    /**
                                     * Finds all collisions given a list of pairs.
                                     * @method collisions
                                     * @param {pair[]} broadphasePairs
                                     * @param {engine} engine
                                     * @return {array} collisions
                                     */
                                    Detector.collisions = function (
                                        broadphasePairs,
                                        engine
                                    ) {
                                        var collisions = [],
                                            pairsTable = engine.pairs.table;

                                        for (
                                            var i = 0;
                                            i < broadphasePairs.length;
                                            i++
                                        ) {
                                            var bodyA = broadphasePairs[i][0],
                                                bodyB = broadphasePairs[i][1];

                                            if (
                                                (bodyA.isStatic ||
                                                    bodyA.isSleeping) &&
                                                (bodyB.isStatic ||
                                                    bodyB.isSleeping)
                                            )
                                                continue;

                                            if (
                                                !Detector.canCollide(
                                                    bodyA.collisionFilter,
                                                    bodyB.collisionFilter
                                                )
                                            )
                                                continue;

                                            // mid phase
                                            if (
                                                Bounds.overlaps(
                                                    bodyA.bounds,
                                                    bodyB.bounds
                                                )
                                            ) {
                                                for (
                                                    var j =
                                                        bodyA.parts.length > 1
                                                            ? 1
                                                            : 0;
                                                    j < bodyA.parts.length;
                                                    j++
                                                ) {
                                                    var partA = bodyA.parts[j];

                                                    for (
                                                        var k =
                                                            bodyB.parts.length >
                                                            1
                                                                ? 1
                                                                : 0;
                                                        k < bodyB.parts.length;
                                                        k++
                                                    ) {
                                                        var partB =
                                                            bodyB.parts[k];

                                                        if (
                                                            (partA === bodyA &&
                                                                partB ===
                                                                    bodyB) ||
                                                            Bounds.overlaps(
                                                                partA.bounds,
                                                                partB.bounds
                                                            )
                                                        ) {
                                                            // find a previous collision we could reuse
                                                            var pairId =
                                                                    Pair.id(
                                                                        partA,
                                                                        partB
                                                                    ),
                                                                pair =
                                                                    pairsTable[
                                                                        pairId
                                                                    ],
                                                                previousCollision;

                                                            if (
                                                                pair &&
                                                                pair.isActive
                                                            ) {
                                                                previousCollision =
                                                                    pair.collision;
                                                            } else {
                                                                previousCollision =
                                                                    null;
                                                            }

                                                            // narrow phase
                                                            var collision =
                                                                SAT.collides(
                                                                    partA,
                                                                    partB,
                                                                    previousCollision
                                                                );

                                                            if (
                                                                collision.collided
                                                            ) {
                                                                collisions.push(
                                                                    collision
                                                                );
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        return collisions;
                                    };

                                    /**
                                     * Returns `true` if both supplied collision filters will allow a collision to occur.
                                     * See `body.collisionFilter` for more information.
                                     * @method canCollide
                                     * @param {} filterA
                                     * @param {} filterB
                                     * @return {bool} `true` if collision can occur
                                     */
                                    Detector.canCollide = function (
                                        filterA,
                                        filterB
                                    ) {
                                        if (
                                            filterA.group === filterB.group &&
                                            filterA.group !== 0
                                        )
                                            return filterA.group > 0;

                                        return (
                                            (filterA.mask &
                                                filterB.category) !==
                                                0 &&
                                            (filterB.mask &
                                                filterA.category) !==
                                                0
                                        );
                                    };
                                })();
                            },
                            {
                                "../geometry/Bounds": 24,
                                "./Pair": 7,
                                "./SAT": 11,
                            },
                        ],
                        6: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
                                 *
                                 * @class Grid
                                 */

                                var Grid = {};

                                module.exports = Grid;

                                var Pair = require("./Pair");
                                var Detector = require("./Detector");
                                var Common = require("../core/Common");

                                (function () {
                                    /**
                                     * Creates a new grid.
                                     * @method create
                                     * @param {} options
                                     * @return {grid} A new grid
                                     */
                                    Grid.create = function (options) {
                                        var defaults = {
                                            controller: Grid,
                                            detector: Detector.collisions,
                                            buckets: {},
                                            pairs: {},
                                            pairsList: [],
                                            bucketWidth: 48,
                                            bucketHeight: 48,
                                        };

                                        return Common.extend(defaults, options);
                                    };

                                    /**
                                     * Updates the grid.
                                     * @method update
                                     * @param {grid} grid
                                     * @param {body[]} bodies
                                     * @param {engine} engine
                                     * @param {boolean} forceUpdate
                                     */
                                    Grid.update = function (
                                        grid,
                                        bodies,
                                        engine,
                                        forceUpdate
                                    ) {
                                        var i,
                                            col,
                                            row,
                                            world = engine.world,
                                            buckets = grid.buckets,
                                            bucket,
                                            bucketId,
                                            gridChanged = false;

                                        for (i = 0; i < bodies.length; i++) {
                                            var body = bodies[i];

                                            if (body.isSleeping && !forceUpdate)
                                                continue;

                                            // don't update out of world bodies
                                            if (
                                                body.bounds.max.x < 0 ||
                                                body.bounds.min.x >
                                                    world.bounds.width ||
                                                body.bounds.max.y < 0 ||
                                                body.bounds.min.y >
                                                    world.bounds.height
                                            )
                                                continue;

                                            var newRegion = _getRegion(
                                                grid,
                                                body
                                            );

                                            // if the body has changed grid region
                                            if (
                                                !body.region ||
                                                newRegion.id !==
                                                    body.region.id ||
                                                forceUpdate
                                            ) {
                                                if (!body.region || forceUpdate)
                                                    body.region = newRegion;

                                                var union = _regionUnion(
                                                    newRegion,
                                                    body.region
                                                );

                                                // update grid buckets affected by region change
                                                // iterate over the union of both regions
                                                for (
                                                    col = union.startCol;
                                                    col <= union.endCol;
                                                    col++
                                                ) {
                                                    for (
                                                        row = union.startRow;
                                                        row <= union.endRow;
                                                        row++
                                                    ) {
                                                        bucketId = _getBucketId(
                                                            col,
                                                            row
                                                        );
                                                        bucket =
                                                            buckets[bucketId];

                                                        var isInsideNewRegion =
                                                            col >=
                                                                newRegion.startCol &&
                                                            col <=
                                                                newRegion.endCol &&
                                                            row >=
                                                                newRegion.startRow &&
                                                            row <=
                                                                newRegion.endRow;

                                                        var isInsideOldRegion =
                                                            col >=
                                                                body.region
                                                                    .startCol &&
                                                            col <=
                                                                body.region
                                                                    .endCol &&
                                                            row >=
                                                                body.region
                                                                    .startRow &&
                                                            row <=
                                                                body.region
                                                                    .endRow;

                                                        // remove from old region buckets
                                                        if (
                                                            !isInsideNewRegion &&
                                                            isInsideOldRegion
                                                        ) {
                                                            if (
                                                                isInsideOldRegion
                                                            ) {
                                                                if (bucket)
                                                                    _bucketRemoveBody(
                                                                        grid,
                                                                        bucket,
                                                                        body
                                                                    );
                                                            }
                                                        }

                                                        // add to new region buckets
                                                        if (
                                                            body.region ===
                                                                newRegion ||
                                                            (isInsideNewRegion &&
                                                                !isInsideOldRegion) ||
                                                            forceUpdate
                                                        ) {
                                                            if (!bucket)
                                                                bucket =
                                                                    _createBucket(
                                                                        buckets,
                                                                        bucketId
                                                                    );
                                                            _bucketAddBody(
                                                                grid,
                                                                bucket,
                                                                body
                                                            );
                                                        }
                                                    }
                                                }

                                                // set the new region
                                                body.region = newRegion;

                                                // flag changes so we can update pairs
                                                gridChanged = true;
                                            }
                                        }

                                        // update pairs list only if pairs changed (i.e. a body changed region)
                                        if (gridChanged)
                                            grid.pairsList =
                                                _createActivePairsList(grid);
                                    };

                                    /**
                                     * Clears the grid.
                                     * @method clear
                                     * @param {grid} grid
                                     */
                                    Grid.clear = function (grid) {
                                        grid.buckets = {};
                                        grid.pairs = {};
                                        grid.pairsList = [];
                                    };

                                    /**
                                     * Finds the union of two regions.
                                     * @method _regionUnion
                                     * @private
                                     * @param {} regionA
                                     * @param {} regionB
                                     * @return {} region
                                     */
                                    var _regionUnion = function (
                                        regionA,
                                        regionB
                                    ) {
                                        var startCol = Math.min(
                                                regionA.startCol,
                                                regionB.startCol
                                            ),
                                            endCol = Math.max(
                                                regionA.endCol,
                                                regionB.endCol
                                            ),
                                            startRow = Math.min(
                                                regionA.startRow,
                                                regionB.startRow
                                            ),
                                            endRow = Math.max(
                                                regionA.endRow,
                                                regionB.endRow
                                            );

                                        return _createRegion(
                                            startCol,
                                            endCol,
                                            startRow,
                                            endRow
                                        );
                                    };

                                    /**
                                     * Gets the region a given body falls in for a given grid.
                                     * @method _getRegion
                                     * @private
                                     * @param {} grid
                                     * @param {} body
                                     * @return {} region
                                     */
                                    var _getRegion = function (grid, body) {
                                        var bounds = body.bounds,
                                            startCol = Math.floor(
                                                bounds.min.x / grid.bucketWidth
                                            ),
                                            endCol = Math.floor(
                                                bounds.max.x / grid.bucketWidth
                                            ),
                                            startRow = Math.floor(
                                                bounds.min.y / grid.bucketHeight
                                            ),
                                            endRow = Math.floor(
                                                bounds.max.y / grid.bucketHeight
                                            );

                                        return _createRegion(
                                            startCol,
                                            endCol,
                                            startRow,
                                            endRow
                                        );
                                    };

                                    /**
                                     * Creates a region.
                                     * @method _createRegion
                                     * @private
                                     * @param {} startCol
                                     * @param {} endCol
                                     * @param {} startRow
                                     * @param {} endRow
                                     * @return {} region
                                     */
                                    var _createRegion = function (
                                        startCol,
                                        endCol,
                                        startRow,
                                        endRow
                                    ) {
                                        return {
                                            id:
                                                startCol +
                                                "," +
                                                endCol +
                                                "," +
                                                startRow +
                                                "," +
                                                endRow,
                                            startCol: startCol,
                                            endCol: endCol,
                                            startRow: startRow,
                                            endRow: endRow,
                                        };
                                    };

                                    /**
                                     * Gets the bucket id at the given position.
                                     * @method _getBucketId
                                     * @private
                                     * @param {} column
                                     * @param {} row
                                     * @return {string} bucket id
                                     */
                                    var _getBucketId = function (column, row) {
                                        return column + "," + row;
                                    };

                                    /**
                                     * Creates a bucket.
                                     * @method _createBucket
                                     * @private
                                     * @param {} buckets
                                     * @param {} bucketId
                                     * @return {} bucket
                                     */
                                    var _createBucket = function (
                                        buckets,
                                        bucketId
                                    ) {
                                        var bucket = (buckets[bucketId] = []);
                                        return bucket;
                                    };

                                    /**
                                     * Adds a body to a bucket.
                                     * @method _bucketAddBody
                                     * @private
                                     * @param {} grid
                                     * @param {} bucket
                                     * @param {} body
                                     */
                                    var _bucketAddBody = function (
                                        grid,
                                        bucket,
                                        body
                                    ) {
                                        // add new pairs
                                        for (
                                            var i = 0;
                                            i < bucket.length;
                                            i++
                                        ) {
                                            var bodyB = bucket[i];

                                            if (
                                                body.id === bodyB.id ||
                                                (body.isStatic &&
                                                    bodyB.isStatic)
                                            )
                                                continue;

                                            // keep track of the number of buckets the pair exists in
                                            // important for Grid.update to work
                                            var pairId = Pair.id(body, bodyB),
                                                pair = grid.pairs[pairId];

                                            if (pair) {
                                                pair[2] += 1;
                                            } else {
                                                grid.pairs[pairId] = [
                                                    body,
                                                    bodyB,
                                                    1,
                                                ];
                                            }
                                        }

                                        // add to bodies (after pairs, otherwise pairs with self)
                                        bucket.push(body);
                                    };

                                    /**
                                     * Removes a body from a bucket.
                                     * @method _bucketRemoveBody
                                     * @private
                                     * @param {} grid
                                     * @param {} bucket
                                     * @param {} body
                                     */
                                    var _bucketRemoveBody = function (
                                        grid,
                                        bucket,
                                        body
                                    ) {
                                        // remove from bucket
                                        bucket.splice(
                                            Common.indexOf(bucket, body),
                                            1
                                        );

                                        // update pair counts
                                        for (
                                            var i = 0;
                                            i < bucket.length;
                                            i++
                                        ) {
                                            // keep track of the number of buckets the pair exists in
                                            // important for _createActivePairsList to work
                                            var bodyB = bucket[i],
                                                pairId = Pair.id(body, bodyB),
                                                pair = grid.pairs[pairId];

                                            if (pair) pair[2] -= 1;
                                        }
                                    };

                                    /**
                                     * Generates a list of the active pairs in the grid.
                                     * @method _createActivePairsList
                                     * @private
                                     * @param {} grid
                                     * @return [] pairs
                                     */
                                    var _createActivePairsList = function (
                                        grid
                                    ) {
                                        var pairKeys,
                                            pair,
                                            pairs = [];

                                        // grid.pairs is used as a hashmap
                                        pairKeys = Common.keys(grid.pairs);

                                        // iterate over grid.pairs
                                        for (
                                            var k = 0;
                                            k < pairKeys.length;
                                            k++
                                        ) {
                                            pair = grid.pairs[pairKeys[k]];

                                            // if pair exists in at least one bucket
                                            // it is a pair that needs further collision testing so push it
                                            if (pair[2] > 0) {
                                                pairs.push(pair);
                                            } else {
                                                delete grid.pairs[pairKeys[k]];
                                            }
                                        }

                                        return pairs;
                                    };
                                })();
                            },
                            {
                                "../core/Common": 14,
                                "./Detector": 5,
                                "./Pair": 7,
                            },
                        ],
                        7: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
                                 *
                                 * @class Pair
                                 */

                                var Pair = {};

                                module.exports = Pair;

                                var Contact = require("./Contact");

                                (function () {
                                    /**
                                     * Creates a pair.
                                     * @method create
                                     * @param {collision} collision
                                     * @param {number} timestamp
                                     * @return {pair} A new pair
                                     */
                                    Pair.create = function (
                                        collision,
                                        timestamp
                                    ) {
                                        var bodyA = collision.bodyA,
                                            bodyB = collision.bodyB,
                                            parentA = collision.parentA,
                                            parentB = collision.parentB;

                                        var pair = {
                                            id: Pair.id(bodyA, bodyB),
                                            bodyA: bodyA,
                                            bodyB: bodyB,
                                            contacts: {},
                                            activeContacts: [],
                                            separation: 0,
                                            isActive: true,
                                            timeCreated: timestamp,
                                            timeUpdated: timestamp,
                                            inverseMass:
                                                parentA.inverseMass +
                                                parentB.inverseMass,
                                            friction: Math.min(
                                                parentA.friction,
                                                parentB.friction
                                            ),
                                            frictionStatic: Math.max(
                                                parentA.frictionStatic,
                                                parentB.frictionStatic
                                            ),
                                            restitution: Math.max(
                                                parentA.restitution,
                                                parentB.restitution
                                            ),
                                            slop: Math.max(
                                                parentA.slop,
                                                parentB.slop
                                            ),
                                        };

                                        Pair.update(pair, collision, timestamp);

                                        return pair;
                                    };

                                    /**
                                     * Updates a pair given a collision.
                                     * @method update
                                     * @param {pair} pair
                                     * @param {collision} collision
                                     * @param {number} timestamp
                                     */
                                    Pair.update = function (
                                        pair,
                                        collision,
                                        timestamp
                                    ) {
                                        var contacts = pair.contacts,
                                            supports = collision.supports,
                                            activeContacts =
                                                pair.activeContacts,
                                            parentA = collision.parentA,
                                            parentB = collision.parentB;

                                        pair.collision = collision;
                                        pair.inverseMass =
                                            parentA.inverseMass +
                                            parentB.inverseMass;
                                        pair.friction = Math.min(
                                            parentA.friction,
                                            parentB.friction
                                        );
                                        pair.frictionStatic = Math.max(
                                            parentA.frictionStatic,
                                            parentB.frictionStatic
                                        );
                                        pair.restitution = Math.max(
                                            parentA.restitution,
                                            parentB.restitution
                                        );
                                        pair.slop = Math.max(
                                            parentA.slop,
                                            parentB.slop
                                        );
                                        activeContacts.length = 0;

                                        if (collision.collided) {
                                            for (
                                                var i = 0;
                                                i < supports.length;
                                                i++
                                            ) {
                                                var support = supports[i],
                                                    contactId =
                                                        Contact.id(support),
                                                    contact =
                                                        contacts[contactId];

                                                if (contact) {
                                                    activeContacts.push(
                                                        contact
                                                    );
                                                } else {
                                                    activeContacts.push(
                                                        (contacts[contactId] =
                                                            Contact.create(
                                                                support
                                                            ))
                                                    );
                                                }
                                            }

                                            pair.separation = collision.depth;
                                            Pair.setActive(
                                                pair,
                                                true,
                                                timestamp
                                            );
                                        } else {
                                            if (pair.isActive === true)
                                                Pair.setActive(
                                                    pair,
                                                    false,
                                                    timestamp
                                                );
                                        }
                                    };

                                    /**
                                     * Set a pair as active or inactive.
                                     * @method setActive
                                     * @param {pair} pair
                                     * @param {bool} isActive
                                     * @param {number} timestamp
                                     */
                                    Pair.setActive = function (
                                        pair,
                                        isActive,
                                        timestamp
                                    ) {
                                        if (isActive) {
                                            pair.isActive = true;
                                            pair.timeUpdated = timestamp;
                                        } else {
                                            pair.isActive = false;
                                            pair.activeContacts.length = 0;
                                        }
                                    };

                                    /**
                                     * Get the id for the given pair.
                                     * @method id
                                     * @param {body} bodyA
                                     * @param {body} bodyB
                                     * @return {string} Unique pairId
                                     */
                                    Pair.id = function (bodyA, bodyB) {
                                        if (bodyA.id < bodyB.id) {
                                            return bodyA.id + "_" + bodyB.id;
                                        } else {
                                            return bodyB.id + "_" + bodyA.id;
                                        }
                                    };
                                })();
                            },
                            { "./Contact": 4 },
                        ],
                        8: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
                                 *
                                 * @class Pairs
                                 */

                                var Pairs = {};

                                module.exports = Pairs;

                                var Pair = require("./Pair");
                                var Common = require("../core/Common");

                                (function () {
                                    var _pairMaxIdleLife = 1000;

                                    /**
                                     * Creates a new pairs structure.
                                     * @method create
                                     * @param {object} options
                                     * @return {pairs} A new pairs structure
                                     */
                                    Pairs.create = function (options) {
                                        return Common.extend(
                                            {
                                                table: {},
                                                list: [],
                                                collisionStart: [],
                                                collisionActive: [],
                                                collisionEnd: [],
                                            },
                                            options
                                        );
                                    };

                                    /**
                                     * Updates pairs given a list of collisions.
                                     * @method update
                                     * @param {object} pairs
                                     * @param {collision[]} collisions
                                     * @param {number} timestamp
                                     */
                                    Pairs.update = function (
                                        pairs,
                                        collisions,
                                        timestamp
                                    ) {
                                        var pairsList = pairs.list,
                                            pairsTable = pairs.table,
                                            collisionStart =
                                                pairs.collisionStart,
                                            collisionEnd = pairs.collisionEnd,
                                            collisionActive =
                                                pairs.collisionActive,
                                            activePairIds = [],
                                            collision,
                                            pairId,
                                            pair,
                                            i;

                                        // clear collision state arrays, but maintain old reference
                                        collisionStart.length = 0;
                                        collisionEnd.length = 0;
                                        collisionActive.length = 0;

                                        for (
                                            i = 0;
                                            i < collisions.length;
                                            i++
                                        ) {
                                            collision = collisions[i];

                                            if (collision.collided) {
                                                pairId = Pair.id(
                                                    collision.bodyA,
                                                    collision.bodyB
                                                );
                                                activePairIds.push(pairId);

                                                pair = pairsTable[pairId];

                                                if (pair) {
                                                    // pair already exists (but may or may not be active)
                                                    if (pair.isActive) {
                                                        // pair exists and is active
                                                        collisionActive.push(
                                                            pair
                                                        );
                                                    } else {
                                                        // pair exists but was inactive, so a collision has just started again
                                                        collisionStart.push(
                                                            pair
                                                        );
                                                    }

                                                    // update the pair
                                                    Pair.update(
                                                        pair,
                                                        collision,
                                                        timestamp
                                                    );
                                                } else {
                                                    // pair did not exist, create a new pair
                                                    pair = Pair.create(
                                                        collision,
                                                        timestamp
                                                    );
                                                    pairsTable[pairId] = pair;

                                                    // push the new pair
                                                    collisionStart.push(pair);
                                                    pairsList.push(pair);
                                                }
                                            }
                                        }

                                        // deactivate previously active pairs that are now inactive
                                        for (i = 0; i < pairsList.length; i++) {
                                            pair = pairsList[i];
                                            if (
                                                pair.isActive &&
                                                Common.indexOf(
                                                    activePairIds,
                                                    pair.id
                                                ) === -1
                                            ) {
                                                Pair.setActive(
                                                    pair,
                                                    false,
                                                    timestamp
                                                );
                                                collisionEnd.push(pair);
                                            }
                                        }
                                    };

                                    /**
                                     * Finds and removes pairs that have been inactive for a set amount of time.
                                     * @method removeOld
                                     * @param {object} pairs
                                     * @param {number} timestamp
                                     */
                                    Pairs.removeOld = function (
                                        pairs,
                                        timestamp
                                    ) {
                                        var pairsList = pairs.list,
                                            pairsTable = pairs.table,
                                            indexesToRemove = [],
                                            pair,
                                            collision,
                                            pairIndex,
                                            i;

                                        for (i = 0; i < pairsList.length; i++) {
                                            pair = pairsList[i];
                                            collision = pair.collision;

                                            // never remove sleeping pairs
                                            if (
                                                collision.bodyA.isSleeping ||
                                                collision.bodyB.isSleeping
                                            ) {
                                                pair.timeUpdated = timestamp;
                                                continue;
                                            }

                                            // if pair is inactive for too long, mark it to be removed
                                            if (
                                                timestamp - pair.timeUpdated >
                                                _pairMaxIdleLife
                                            ) {
                                                indexesToRemove.push(i);
                                            }
                                        }

                                        // remove marked pairs
                                        for (
                                            i = 0;
                                            i < indexesToRemove.length;
                                            i++
                                        ) {
                                            pairIndex = indexesToRemove[i] - i;
                                            pair = pairsList[pairIndex];
                                            delete pairsTable[pair.id];
                                            pairsList.splice(pairIndex, 1);
                                        }
                                    };

                                    /**
                                     * Clears the given pairs structure.
                                     * @method clear
                                     * @param {pairs} pairs
                                     * @return {pairs} pairs
                                     */
                                    Pairs.clear = function (pairs) {
                                        pairs.table = {};
                                        pairs.list.length = 0;
                                        pairs.collisionStart.length = 0;
                                        pairs.collisionActive.length = 0;
                                        pairs.collisionEnd.length = 0;
                                        return pairs;
                                    };
                                })();
                            },
                            { "../core/Common": 14, "./Pair": 7 },
                        ],
                        9: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Query` module contains methods for performing collision queries.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Query
                                 */

                                var Query = {};

                                module.exports = Query;

                                var Vector = require("../geometry/Vector");
                                var SAT = require("./SAT");
                                var Bounds = require("../geometry/Bounds");
                                var Bodies = require("../factory/Bodies");
                                var Vertices = require("../geometry/Vertices");

                                (function () {
                                    /**
                                     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
                                     * @method ray
                                     * @param {body[]} bodies
                                     * @param {vector} startPoint
                                     * @param {vector} endPoint
                                     * @param {number} [rayWidth]
                                     * @return {object[]} Collisions
                                     */
                                    Query.ray = function (
                                        bodies,
                                        startPoint,
                                        endPoint,
                                        rayWidth
                                    ) {
                                        rayWidth = rayWidth || 1e-100;

                                        var rayAngle = Vector.angle(
                                                startPoint,
                                                endPoint
                                            ),
                                            rayLength = Vector.magnitude(
                                                Vector.sub(startPoint, endPoint)
                                            ),
                                            rayX =
                                                (endPoint.x + startPoint.x) *
                                                0.5,
                                            rayY =
                                                (endPoint.y + startPoint.y) *
                                                0.5,
                                            ray = Bodies.rectangle(
                                                rayX,
                                                rayY,
                                                rayLength,
                                                rayWidth,
                                                { angle: rayAngle }
                                            ),
                                            collisions = [];

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var bodyA = bodies[i];

                                            if (
                                                Bounds.overlaps(
                                                    bodyA.bounds,
                                                    ray.bounds
                                                )
                                            ) {
                                                for (
                                                    var j =
                                                        bodyA.parts.length === 1
                                                            ? 0
                                                            : 1;
                                                    j < bodyA.parts.length;
                                                    j++
                                                ) {
                                                    var part = bodyA.parts[j];

                                                    if (
                                                        Bounds.overlaps(
                                                            part.bounds,
                                                            ray.bounds
                                                        )
                                                    ) {
                                                        var collision =
                                                            SAT.collides(
                                                                part,
                                                                ray
                                                            );
                                                        if (
                                                            collision.collided
                                                        ) {
                                                            collision.body =
                                                                collision.bodyA =
                                                                collision.bodyB =
                                                                    bodyA;
                                                            collisions.push(
                                                                collision
                                                            );
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        return collisions;
                                    };

                                    /**
                                     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
                                     * @method region
                                     * @param {body[]} bodies
                                     * @param {bounds} bounds
                                     * @param {bool} [outside=false]
                                     * @return {body[]} The bodies matching the query
                                     */
                                    Query.region = function (
                                        bodies,
                                        bounds,
                                        outside
                                    ) {
                                        var result = [];

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i],
                                                overlaps = Bounds.overlaps(
                                                    body.bounds,
                                                    bounds
                                                );
                                            if (
                                                (overlaps && !outside) ||
                                                (!overlaps && outside)
                                            )
                                                result.push(body);
                                        }

                                        return result;
                                    };

                                    /**
                                     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
                                     * @method point
                                     * @param {body[]} bodies
                                     * @param {vector} point
                                     * @return {body[]} The bodies matching the query
                                     */
                                    Query.point = function (bodies, point) {
                                        var result = [];

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            if (
                                                Bounds.contains(
                                                    body.bounds,
                                                    point
                                                )
                                            ) {
                                                for (
                                                    var j =
                                                        body.parts.length === 1
                                                            ? 0
                                                            : 1;
                                                    j < body.parts.length;
                                                    j++
                                                ) {
                                                    var part = body.parts[j];

                                                    if (
                                                        Bounds.contains(
                                                            part.bounds,
                                                            point
                                                        ) &&
                                                        Vertices.contains(
                                                            part.vertices,
                                                            point
                                                        )
                                                    ) {
                                                        result.push(body);
                                                        break;
                                                    }
                                                }
                                            }
                                        }

                                        return result;
                                    };
                                })();
                            },
                            {
                                "../factory/Bodies": 21,
                                "../geometry/Bounds": 24,
                                "../geometry/Vector": 26,
                                "../geometry/Vertices": 27,
                                "./SAT": 11,
                            },
                        ],
                        10: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Resolver` module contains methods for resolving collision pairs.
                                 *
                                 * @class Resolver
                                 */

                                var Resolver = {};

                                module.exports = Resolver;

                                var Vertices = require("../geometry/Vertices");
                                var Vector = require("../geometry/Vector");
                                var Common = require("../core/Common");
                                var Bounds = require("../geometry/Bounds");

                                (function () {
                                    Resolver._restingThresh = 4;
                                    Resolver._restingThreshTangent = 6;
                                    Resolver._positionDampen = 0.9;
                                    Resolver._positionWarming = 0.8;
                                    Resolver._frictionNormalMultiplier = 5;

                                    /**
                                     * Prepare pairs for position solving.
                                     * @method preSolvePosition
                                     * @param {pair[]} pairs
                                     */
                                    Resolver.preSolvePosition = function (
                                        pairs
                                    ) {
                                        var i, pair, activeCount;

                                        // find total contacts on each body
                                        for (i = 0; i < pairs.length; i++) {
                                            pair = pairs[i];

                                            if (!pair.isActive) continue;

                                            activeCount =
                                                pair.activeContacts.length;
                                            pair.collision.parentA.totalContacts +=
                                                activeCount;
                                            pair.collision.parentB.totalContacts +=
                                                activeCount;
                                        }
                                    };

                                    /**
                                     * Find a solution for pair positions.
                                     * @method solvePosition
                                     * @param {pair[]} pairs
                                     * @param {number} timeScale
                                     */
                                    Resolver.solvePosition = function (
                                        pairs,
                                        timeScale
                                    ) {
                                        var i,
                                            pair,
                                            collision,
                                            bodyA,
                                            bodyB,
                                            normal,
                                            bodyBtoA,
                                            contactShare,
                                            positionImpulse,
                                            contactCount = {},
                                            tempA = Vector._temp[0],
                                            tempB = Vector._temp[1],
                                            tempC = Vector._temp[2],
                                            tempD = Vector._temp[3];

                                        // find impulses required to resolve penetration
                                        for (i = 0; i < pairs.length; i++) {
                                            pair = pairs[i];

                                            if (!pair.isActive) continue;

                                            collision = pair.collision;
                                            bodyA = collision.parentA;
                                            bodyB = collision.parentB;
                                            normal = collision.normal;

                                            // get current separation between body edges involved in collision
                                            bodyBtoA = Vector.sub(
                                                Vector.add(
                                                    bodyB.positionImpulse,
                                                    bodyB.position,
                                                    tempA
                                                ),
                                                Vector.add(
                                                    bodyA.positionImpulse,
                                                    Vector.sub(
                                                        bodyB.position,
                                                        collision.penetration,
                                                        tempB
                                                    ),
                                                    tempC
                                                ),
                                                tempD
                                            );

                                            pair.separation = Vector.dot(
                                                normal,
                                                bodyBtoA
                                            );
                                        }

                                        for (i = 0; i < pairs.length; i++) {
                                            pair = pairs[i];

                                            if (
                                                !pair.isActive ||
                                                pair.separation < 0
                                            )
                                                continue;

                                            collision = pair.collision;
                                            bodyA = collision.parentA;
                                            bodyB = collision.parentB;
                                            normal = collision.normal;
                                            positionImpulse =
                                                (pair.separation - pair.slop) *
                                                timeScale;

                                            if (
                                                bodyA.isStatic ||
                                                bodyB.isStatic
                                            )
                                                positionImpulse *= 2;

                                            if (
                                                !(
                                                    bodyA.isStatic ||
                                                    bodyA.isSleeping
                                                )
                                            ) {
                                                contactShare =
                                                    Resolver._positionDampen /
                                                    bodyA.totalContacts;
                                                bodyA.positionImpulse.x +=
                                                    normal.x *
                                                    positionImpulse *
                                                    contactShare;
                                                bodyA.positionImpulse.y +=
                                                    normal.y *
                                                    positionImpulse *
                                                    contactShare;
                                            }

                                            if (
                                                !(
                                                    bodyB.isStatic ||
                                                    bodyB.isSleeping
                                                )
                                            ) {
                                                contactShare =
                                                    Resolver._positionDampen /
                                                    bodyB.totalContacts;
                                                bodyB.positionImpulse.x -=
                                                    normal.x *
                                                    positionImpulse *
                                                    contactShare;
                                                bodyB.positionImpulse.y -=
                                                    normal.y *
                                                    positionImpulse *
                                                    contactShare;
                                            }
                                        }
                                    };

                                    /**
                                     * Apply position resolution.
                                     * @method postSolvePosition
                                     * @param {body[]} bodies
                                     */
                                    Resolver.postSolvePosition = function (
                                        bodies
                                    ) {
                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            // reset contact count
                                            body.totalContacts = 0;

                                            if (
                                                body.positionImpulse.x !== 0 ||
                                                body.positionImpulse.y !== 0
                                            ) {
                                                // update body geometry
                                                for (
                                                    var j = 0;
                                                    j < body.parts.length;
                                                    j++
                                                ) {
                                                    var part = body.parts[j];
                                                    Vertices.translate(
                                                        part.vertices,
                                                        body.positionImpulse
                                                    );
                                                    Bounds.update(
                                                        part.bounds,
                                                        part.vertices,
                                                        body.velocity
                                                    );
                                                    part.position.x +=
                                                        body.positionImpulse.x;
                                                    part.position.y +=
                                                        body.positionImpulse.y;
                                                }

                                                // move the body without changing velocity
                                                body.positionPrev.x +=
                                                    body.positionImpulse.x;
                                                body.positionPrev.y +=
                                                    body.positionImpulse.y;

                                                if (
                                                    Vector.dot(
                                                        body.positionImpulse,
                                                        body.velocity
                                                    ) < 0
                                                ) {
                                                    // reset cached impulse if the body has velocity along it
                                                    body.positionImpulse.x = 0;
                                                    body.positionImpulse.y = 0;
                                                } else {
                                                    // warm the next iteration
                                                    body.positionImpulse.x *=
                                                        Resolver._positionWarming;
                                                    body.positionImpulse.y *=
                                                        Resolver._positionWarming;
                                                }
                                            }
                                        }
                                    };

                                    /**
                                     * Prepare pairs for velocity solving.
                                     * @method preSolveVelocity
                                     * @param {pair[]} pairs
                                     */
                                    Resolver.preSolveVelocity = function (
                                        pairs
                                    ) {
                                        var i,
                                            j,
                                            pair,
                                            contacts,
                                            collision,
                                            bodyA,
                                            bodyB,
                                            normal,
                                            tangent,
                                            contact,
                                            contactVertex,
                                            normalImpulse,
                                            tangentImpulse,
                                            offset,
                                            impulse = Vector._temp[0],
                                            tempA = Vector._temp[1];

                                        for (i = 0; i < pairs.length; i++) {
                                            pair = pairs[i];

                                            if (!pair.isActive) continue;

                                            contacts = pair.activeContacts;
                                            collision = pair.collision;
                                            bodyA = collision.parentA;
                                            bodyB = collision.parentB;
                                            normal = collision.normal;
                                            tangent = collision.tangent;

                                            // resolve each contact
                                            for (
                                                j = 0;
                                                j < contacts.length;
                                                j++
                                            ) {
                                                contact = contacts[j];
                                                contactVertex = contact.vertex;
                                                normalImpulse =
                                                    contact.normalImpulse;
                                                tangentImpulse =
                                                    contact.tangentImpulse;

                                                if (
                                                    normalImpulse !== 0 ||
                                                    tangentImpulse !== 0
                                                ) {
                                                    // total impulse from contact
                                                    impulse.x =
                                                        normal.x *
                                                            normalImpulse +
                                                        tangent.x *
                                                            tangentImpulse;
                                                    impulse.y =
                                                        normal.y *
                                                            normalImpulse +
                                                        tangent.y *
                                                            tangentImpulse;

                                                    // apply impulse from contact
                                                    if (
                                                        !(
                                                            bodyA.isStatic ||
                                                            bodyA.isSleeping
                                                        )
                                                    ) {
                                                        offset = Vector.sub(
                                                            contactVertex,
                                                            bodyA.position,
                                                            tempA
                                                        );
                                                        bodyA.positionPrev.x +=
                                                            impulse.x *
                                                            bodyA.inverseMass;
                                                        bodyA.positionPrev.y +=
                                                            impulse.y *
                                                            bodyA.inverseMass;
                                                        bodyA.anglePrev +=
                                                            Vector.cross(
                                                                offset,
                                                                impulse
                                                            ) *
                                                            bodyA.inverseInertia;
                                                    }

                                                    if (
                                                        !(
                                                            bodyB.isStatic ||
                                                            bodyB.isSleeping
                                                        )
                                                    ) {
                                                        offset = Vector.sub(
                                                            contactVertex,
                                                            bodyB.position,
                                                            tempA
                                                        );
                                                        bodyB.positionPrev.x -=
                                                            impulse.x *
                                                            bodyB.inverseMass;
                                                        bodyB.positionPrev.y -=
                                                            impulse.y *
                                                            bodyB.inverseMass;
                                                        bodyB.anglePrev -=
                                                            Vector.cross(
                                                                offset,
                                                                impulse
                                                            ) *
                                                            bodyB.inverseInertia;
                                                    }
                                                }
                                            }
                                        }
                                    };

                                    /**
                                     * Find a solution for pair velocities.
                                     * @method solveVelocity
                                     * @param {pair[]} pairs
                                     * @param {number} timeScale
                                     */
                                    Resolver.solveVelocity = function (
                                        pairs,
                                        timeScale
                                    ) {
                                        var timeScaleSquared =
                                                timeScale * timeScale,
                                            impulse = Vector._temp[0],
                                            tempA = Vector._temp[1],
                                            tempB = Vector._temp[2],
                                            tempC = Vector._temp[3],
                                            tempD = Vector._temp[4],
                                            tempE = Vector._temp[5];

                                        for (var i = 0; i < pairs.length; i++) {
                                            var pair = pairs[i];

                                            if (!pair.isActive) continue;

                                            var collision = pair.collision,
                                                bodyA = collision.parentA,
                                                bodyB = collision.parentB,
                                                normal = collision.normal,
                                                tangent = collision.tangent,
                                                contacts = pair.activeContacts,
                                                contactShare =
                                                    1 / contacts.length;

                                            // update body velocities
                                            bodyA.velocity.x =
                                                bodyA.position.x -
                                                bodyA.positionPrev.x;
                                            bodyA.velocity.y =
                                                bodyA.position.y -
                                                bodyA.positionPrev.y;
                                            bodyB.velocity.x =
                                                bodyB.position.x -
                                                bodyB.positionPrev.x;
                                            bodyB.velocity.y =
                                                bodyB.position.y -
                                                bodyB.positionPrev.y;
                                            bodyA.angularVelocity =
                                                bodyA.angle - bodyA.anglePrev;
                                            bodyB.angularVelocity =
                                                bodyB.angle - bodyB.anglePrev;

                                            // resolve each contact
                                            for (
                                                var j = 0;
                                                j < contacts.length;
                                                j++
                                            ) {
                                                var contact = contacts[j],
                                                    contactVertex =
                                                        contact.vertex,
                                                    offsetA = Vector.sub(
                                                        contactVertex,
                                                        bodyA.position,
                                                        tempA
                                                    ),
                                                    offsetB = Vector.sub(
                                                        contactVertex,
                                                        bodyB.position,
                                                        tempB
                                                    ),
                                                    velocityPointA = Vector.add(
                                                        bodyA.velocity,
                                                        Vector.mult(
                                                            Vector.perp(
                                                                offsetA
                                                            ),
                                                            bodyA.angularVelocity
                                                        ),
                                                        tempC
                                                    ),
                                                    velocityPointB = Vector.add(
                                                        bodyB.velocity,
                                                        Vector.mult(
                                                            Vector.perp(
                                                                offsetB
                                                            ),
                                                            bodyB.angularVelocity
                                                        ),
                                                        tempD
                                                    ),
                                                    relativeVelocity =
                                                        Vector.sub(
                                                            velocityPointA,
                                                            velocityPointB,
                                                            tempE
                                                        ),
                                                    normalVelocity = Vector.dot(
                                                        normal,
                                                        relativeVelocity
                                                    );

                                                var tangentVelocity =
                                                        Vector.dot(
                                                            tangent,
                                                            relativeVelocity
                                                        ),
                                                    tangentSpeed =
                                                        Math.abs(
                                                            tangentVelocity
                                                        ),
                                                    tangentVelocityDirection =
                                                        Common.sign(
                                                            tangentVelocity
                                                        );

                                                // raw impulses
                                                var normalImpulse =
                                                        (1 + pair.restitution) *
                                                        normalVelocity,
                                                    normalForce =
                                                        Common.clamp(
                                                            pair.separation +
                                                                normalVelocity,
                                                            0,
                                                            1
                                                        ) *
                                                        Resolver._frictionNormalMultiplier;

                                                // coulomb friction
                                                var tangentImpulse =
                                                        tangentVelocity,
                                                    maxFriction = Infinity;

                                                if (
                                                    tangentSpeed >
                                                    pair.friction *
                                                        pair.frictionStatic *
                                                        normalForce *
                                                        timeScaleSquared
                                                ) {
                                                    maxFriction = tangentSpeed;
                                                    tangentImpulse =
                                                        Common.clamp(
                                                            pair.friction *
                                                                tangentVelocityDirection *
                                                                timeScaleSquared,
                                                            -maxFriction,
                                                            maxFriction
                                                        );
                                                }

                                                // modify impulses accounting for mass, inertia and offset
                                                var oAcN = Vector.cross(
                                                        offsetA,
                                                        normal
                                                    ),
                                                    oBcN = Vector.cross(
                                                        offsetB,
                                                        normal
                                                    ),
                                                    share =
                                                        contactShare /
                                                        (bodyA.inverseMass +
                                                            bodyB.inverseMass +
                                                            bodyA.inverseInertia *
                                                                oAcN *
                                                                oAcN +
                                                            bodyB.inverseInertia *
                                                                oBcN *
                                                                oBcN);

                                                normalImpulse *= share;
                                                tangentImpulse *= share;

                                                // handle high velocity and resting collisions separately
                                                if (
                                                    normalVelocity < 0 &&
                                                    normalVelocity *
                                                        normalVelocity >
                                                        Resolver._restingThresh *
                                                            timeScaleSquared
                                                ) {
                                                    // high normal velocity so clear cached contact normal impulse
                                                    contact.normalImpulse = 0;
                                                } else {
                                                    // solve resting collision constraints using Erin Catto's method (GDC08)
                                                    // impulse constraint tends to 0
                                                    var contactNormalImpulse =
                                                        contact.normalImpulse;
                                                    contact.normalImpulse =
                                                        Math.min(
                                                            contact.normalImpulse +
                                                                normalImpulse,
                                                            0
                                                        );
                                                    normalImpulse =
                                                        contact.normalImpulse -
                                                        contactNormalImpulse;
                                                }

                                                // handle high velocity and resting collisions separately
                                                if (
                                                    tangentVelocity *
                                                        tangentVelocity >
                                                    Resolver._restingThreshTangent *
                                                        timeScaleSquared
                                                ) {
                                                    // high tangent velocity so clear cached contact tangent impulse
                                                    contact.tangentImpulse = 0;
                                                } else {
                                                    // solve resting collision constraints using Erin Catto's method (GDC08)
                                                    // tangent impulse tends to -tangentSpeed or +tangentSpeed
                                                    var contactTangentImpulse =
                                                        contact.tangentImpulse;
                                                    contact.tangentImpulse =
                                                        Common.clamp(
                                                            contact.tangentImpulse +
                                                                tangentImpulse,
                                                            -maxFriction,
                                                            maxFriction
                                                        );
                                                    tangentImpulse =
                                                        contact.tangentImpulse -
                                                        contactTangentImpulse;
                                                }

                                                // total impulse from contact
                                                impulse.x =
                                                    normal.x * normalImpulse +
                                                    tangent.x * tangentImpulse;
                                                impulse.y =
                                                    normal.y * normalImpulse +
                                                    tangent.y * tangentImpulse;

                                                // apply impulse from contact
                                                if (
                                                    !(
                                                        bodyA.isStatic ||
                                                        bodyA.isSleeping
                                                    )
                                                ) {
                                                    bodyA.positionPrev.x +=
                                                        impulse.x *
                                                        bodyA.inverseMass;
                                                    bodyA.positionPrev.y +=
                                                        impulse.y *
                                                        bodyA.inverseMass;
                                                    bodyA.anglePrev +=
                                                        Vector.cross(
                                                            offsetA,
                                                            impulse
                                                        ) *
                                                        bodyA.inverseInertia;
                                                }

                                                if (
                                                    !(
                                                        bodyB.isStatic ||
                                                        bodyB.isSleeping
                                                    )
                                                ) {
                                                    bodyB.positionPrev.x -=
                                                        impulse.x *
                                                        bodyB.inverseMass;
                                                    bodyB.positionPrev.y -=
                                                        impulse.y *
                                                        bodyB.inverseMass;
                                                    bodyB.anglePrev -=
                                                        Vector.cross(
                                                            offsetB,
                                                            impulse
                                                        ) *
                                                        bodyB.inverseInertia;
                                                }
                                            }
                                        }
                                    };
                                })();
                            },
                            {
                                "../core/Common": 14,
                                "../geometry/Bounds": 24,
                                "../geometry/Vector": 26,
                                "../geometry/Vertices": 27,
                            },
                        ],
                        11: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
                                 *
                                 * @class SAT
                                 */

                                // TODO: true circles and curves

                                var SAT = {};

                                module.exports = SAT;

                                var Vertices = require("../geometry/Vertices");
                                var Vector = require("../geometry/Vector");

                                (function () {
                                    /**
                                     * Detect collision between two bodies using the Separating Axis Theorem.
                                     * @method collides
                                     * @param {body} bodyA
                                     * @param {body} bodyB
                                     * @param {collision} previousCollision
                                     * @return {collision} collision
                                     */
                                    SAT.collides = function (
                                        bodyA,
                                        bodyB,
                                        previousCollision
                                    ) {
                                        var overlapAB,
                                            overlapBA,
                                            minOverlap,
                                            collision,
                                            prevCol = previousCollision,
                                            canReusePrevCol = false;

                                        if (prevCol) {
                                            // estimate total motion
                                            var parentA = bodyA.parent,
                                                parentB = bodyB.parent,
                                                motion =
                                                    parentA.speed *
                                                        parentA.speed +
                                                    parentA.angularSpeed *
                                                        parentA.angularSpeed +
                                                    parentB.speed *
                                                        parentB.speed +
                                                    parentB.angularSpeed *
                                                        parentB.angularSpeed;

                                            // we may be able to (partially) reuse collision result
                                            // but only safe if collision was resting
                                            canReusePrevCol =
                                                prevCol &&
                                                prevCol.collided &&
                                                motion < 0.2;

                                            // reuse collision object
                                            collision = prevCol;
                                        } else {
                                            collision = {
                                                collided: false,
                                                bodyA: bodyA,
                                                bodyB: bodyB,
                                            };
                                        }

                                        if (prevCol && canReusePrevCol) {
                                            // if we can reuse the collision result
                                            // we only need to test the previously found axis
                                            var axisBodyA = collision.axisBody,
                                                axisBodyB =
                                                    axisBodyA === bodyA
                                                        ? bodyB
                                                        : bodyA,
                                                axes = [
                                                    axisBodyA.axes[
                                                        prevCol.axisNumber
                                                    ],
                                                ];

                                            minOverlap = _overlapAxes(
                                                axisBodyA.vertices,
                                                axisBodyB.vertices,
                                                axes
                                            );
                                            collision.reused = true;

                                            if (minOverlap.overlap <= 0) {
                                                collision.collided = false;
                                                return collision;
                                            }
                                        } else {
                                            // if we can't reuse a result, perform a full SAT test

                                            overlapAB = _overlapAxes(
                                                bodyA.vertices,
                                                bodyB.vertices,
                                                bodyA.axes
                                            );

                                            if (overlapAB.overlap <= 0) {
                                                collision.collided = false;
                                                return collision;
                                            }

                                            overlapBA = _overlapAxes(
                                                bodyB.vertices,
                                                bodyA.vertices,
                                                bodyB.axes
                                            );

                                            if (overlapBA.overlap <= 0) {
                                                collision.collided = false;
                                                return collision;
                                            }

                                            if (
                                                overlapAB.overlap <
                                                overlapBA.overlap
                                            ) {
                                                minOverlap = overlapAB;
                                                collision.axisBody = bodyA;
                                            } else {
                                                minOverlap = overlapBA;
                                                collision.axisBody = bodyB;
                                            }

                                            // important for reuse later
                                            collision.axisNumber =
                                                minOverlap.axisNumber;
                                        }

                                        collision.bodyA =
                                            bodyA.id < bodyB.id ? bodyA : bodyB;
                                        collision.bodyB =
                                            bodyA.id < bodyB.id ? bodyB : bodyA;
                                        collision.collided = true;
                                        collision.normal = minOverlap.axis;
                                        collision.depth = minOverlap.overlap;
                                        collision.parentA =
                                            collision.bodyA.parent;
                                        collision.parentB =
                                            collision.bodyB.parent;

                                        bodyA = collision.bodyA;
                                        bodyB = collision.bodyB;

                                        // ensure normal is facing away from bodyA
                                        if (
                                            Vector.dot(
                                                collision.normal,
                                                Vector.sub(
                                                    bodyB.position,
                                                    bodyA.position
                                                )
                                            ) > 0
                                        )
                                            collision.normal = Vector.neg(
                                                collision.normal
                                            );

                                        collision.tangent = Vector.perp(
                                            collision.normal
                                        );

                                        collision.penetration = {
                                            x:
                                                collision.normal.x *
                                                collision.depth,
                                            y:
                                                collision.normal.y *
                                                collision.depth,
                                        };

                                        // find support points, there is always either exactly one or two
                                        var verticesB = _findSupports(
                                                bodyA,
                                                bodyB,
                                                collision.normal
                                            ),
                                            supports = collision.supports || [];
                                        supports.length = 0;

                                        // find the supports from bodyB that are inside bodyA
                                        if (
                                            Vertices.contains(
                                                bodyA.vertices,
                                                verticesB[0]
                                            )
                                        )
                                            supports.push(verticesB[0]);

                                        if (
                                            Vertices.contains(
                                                bodyA.vertices,
                                                verticesB[1]
                                            )
                                        )
                                            supports.push(verticesB[1]);

                                        // find the supports from bodyA that are inside bodyB
                                        if (supports.length < 2) {
                                            var verticesA = _findSupports(
                                                bodyB,
                                                bodyA,
                                                Vector.neg(collision.normal)
                                            );

                                            if (
                                                Vertices.contains(
                                                    bodyB.vertices,
                                                    verticesA[0]
                                                )
                                            )
                                                supports.push(verticesA[0]);

                                            if (
                                                supports.length < 2 &&
                                                Vertices.contains(
                                                    bodyB.vertices,
                                                    verticesA[1]
                                                )
                                            )
                                                supports.push(verticesA[1]);
                                        }

                                        // account for the edge case of overlapping but no vertex containment
                                        if (supports.length < 1)
                                            supports = [verticesB[0]];

                                        collision.supports = supports;

                                        return collision;
                                    };

                                    /**
                                     * Find the overlap between two sets of vertices.
                                     * @method _overlapAxes
                                     * @private
                                     * @param {} verticesA
                                     * @param {} verticesB
                                     * @param {} axes
                                     * @return result
                                     */
                                    var _overlapAxes = function (
                                        verticesA,
                                        verticesB,
                                        axes
                                    ) {
                                        var projectionA = Vector._temp[0],
                                            projectionB = Vector._temp[1],
                                            result = {
                                                overlap: Number.MAX_VALUE,
                                            },
                                            overlap,
                                            axis;

                                        for (var i = 0; i < axes.length; i++) {
                                            axis = axes[i];

                                            _projectToAxis(
                                                projectionA,
                                                verticesA,
                                                axis
                                            );
                                            _projectToAxis(
                                                projectionB,
                                                verticesB,
                                                axis
                                            );

                                            overlap = Math.min(
                                                projectionA.max -
                                                    projectionB.min,
                                                projectionB.max -
                                                    projectionA.min
                                            );

                                            if (overlap <= 0) {
                                                result.overlap = overlap;
                                                return result;
                                            }

                                            if (overlap < result.overlap) {
                                                result.overlap = overlap;
                                                result.axis = axis;
                                                result.axisNumber = i;
                                            }
                                        }

                                        return result;
                                    };

                                    /**
                                     * Projects vertices on an axis and returns an interval.
                                     * @method _projectToAxis
                                     * @private
                                     * @param {} projection
                                     * @param {} vertices
                                     * @param {} axis
                                     */
                                    var _projectToAxis = function (
                                        projection,
                                        vertices,
                                        axis
                                    ) {
                                        var min = Vector.dot(vertices[0], axis),
                                            max = min;

                                        for (
                                            var i = 1;
                                            i < vertices.length;
                                            i += 1
                                        ) {
                                            var dot = Vector.dot(
                                                vertices[i],
                                                axis
                                            );

                                            if (dot > max) {
                                                max = dot;
                                            } else if (dot < min) {
                                                min = dot;
                                            }
                                        }

                                        projection.min = min;
                                        projection.max = max;
                                    };

                                    /**
                                     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
                                     * @method _findSupports
                                     * @private
                                     * @param {} bodyA
                                     * @param {} bodyB
                                     * @param {} normal
                                     * @return [vector]
                                     */
                                    var _findSupports = function (
                                        bodyA,
                                        bodyB,
                                        normal
                                    ) {
                                        var nearestDistance = Number.MAX_VALUE,
                                            vertexToBody = Vector._temp[0],
                                            vertices = bodyB.vertices,
                                            bodyAPosition = bodyA.position,
                                            distance,
                                            vertex,
                                            vertexA,
                                            vertexB;

                                        // find closest vertex on bodyB
                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            vertex = vertices[i];
                                            vertexToBody.x =
                                                vertex.x - bodyAPosition.x;
                                            vertexToBody.y =
                                                vertex.y - bodyAPosition.y;
                                            distance = -Vector.dot(
                                                normal,
                                                vertexToBody
                                            );

                                            if (distance < nearestDistance) {
                                                nearestDistance = distance;
                                                vertexA = vertex;
                                            }
                                        }

                                        // find next closest vertex using the two connected to it
                                        var prevIndex =
                                            vertexA.index - 1 >= 0
                                                ? vertexA.index - 1
                                                : vertices.length - 1;
                                        vertex = vertices[prevIndex];
                                        vertexToBody.x =
                                            vertex.x - bodyAPosition.x;
                                        vertexToBody.y =
                                            vertex.y - bodyAPosition.y;
                                        nearestDistance = -Vector.dot(
                                            normal,
                                            vertexToBody
                                        );
                                        vertexB = vertex;

                                        var nextIndex =
                                            (vertexA.index + 1) %
                                            vertices.length;
                                        vertex = vertices[nextIndex];
                                        vertexToBody.x =
                                            vertex.x - bodyAPosition.x;
                                        vertexToBody.y =
                                            vertex.y - bodyAPosition.y;
                                        distance = -Vector.dot(
                                            normal,
                                            vertexToBody
                                        );
                                        if (distance < nearestDistance) {
                                            vertexB = vertex;
                                        }

                                        return [vertexA, vertexB];
                                    };
                                })();
                            },
                            {
                                "../geometry/Vector": 26,
                                "../geometry/Vertices": 27,
                            },
                        ],
                        12: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Constraint` module contains methods for creating and manipulating constraints.
                                 * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
                                 * The stiffness of constraints can be modified to create springs or elastic.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Constraint
                                 */

                                // TODO: fix instability issues with torque
                                // TODO: linked constraints
                                // TODO: breakable constraints
                                // TODO: collision constraints
                                // TODO: allow constrained bodies to sleep
                                // TODO: handle 0 length constraints properly
                                // TODO: impulse caching and warming

                                var Constraint = {};

                                module.exports = Constraint;

                                var Vertices = require("../geometry/Vertices");
                                var Vector = require("../geometry/Vector");
                                var Sleeping = require("../core/Sleeping");
                                var Bounds = require("../geometry/Bounds");
                                var Axes = require("../geometry/Axes");
                                var Common = require("../core/Common");

                                (function () {
                                    var _minLength = 0.000001,
                                        _minDifference = 0.001;

                                    /**
                                     * Creates a new constraint.
                                     * All properties have default values, and many are pre-calculated automatically based on other properties.
                                     * See the properties section below for detailed information on what you can pass via the `options` object.
                                     * @method create
                                     * @param {} options
                                     * @return {constraint} constraint
                                     */
                                    Constraint.create = function (options) {
                                        var constraint = options;

                                        // if bodies defined but no points, use body centre
                                        if (
                                            constraint.bodyA &&
                                            !constraint.pointA
                                        )
                                            constraint.pointA = { x: 0, y: 0 };
                                        if (
                                            constraint.bodyB &&
                                            !constraint.pointB
                                        )
                                            constraint.pointB = { x: 0, y: 0 };

                                        // calculate static length using initial world space points
                                        var initialPointA = constraint.bodyA
                                                ? Vector.add(
                                                      constraint.bodyA.position,
                                                      constraint.pointA
                                                  )
                                                : constraint.pointA,
                                            initialPointB = constraint.bodyB
                                                ? Vector.add(
                                                      constraint.bodyB.position,
                                                      constraint.pointB
                                                  )
                                                : constraint.pointB,
                                            length = Vector.magnitude(
                                                Vector.sub(
                                                    initialPointA,
                                                    initialPointB
                                                )
                                            );

                                        constraint.length =
                                            constraint.length ||
                                            length ||
                                            _minLength;

                                        // render
                                        var render = {
                                            visible: true,
                                            lineWidth: 2,
                                            strokeStyle: "#666",
                                        };

                                        constraint.render = Common.extend(
                                            render,
                                            constraint.render
                                        );

                                        // option defaults
                                        constraint.id =
                                            constraint.id || Common.nextId();
                                        constraint.label =
                                            constraint.label || "Constraint";
                                        constraint.type = "constraint";
                                        constraint.stiffness =
                                            constraint.stiffness || 1;
                                        constraint.angularStiffness =
                                            constraint.angularStiffness || 0;
                                        constraint.angleA = constraint.bodyA
                                            ? constraint.bodyA.angle
                                            : constraint.angleA;
                                        constraint.angleB = constraint.bodyB
                                            ? constraint.bodyB.angle
                                            : constraint.angleB;

                                        return constraint;
                                    };

                                    /**
                                     * Solves all constraints in a list of collisions.
                                     * @private
                                     * @method solveAll
                                     * @param {constraint[]} constraints
                                     * @param {number} timeScale
                                     */
                                    Constraint.solveAll = function (
                                        constraints,
                                        timeScale
                                    ) {
                                        for (
                                            var i = 0;
                                            i < constraints.length;
                                            i++
                                        ) {
                                            Constraint.solve(
                                                constraints[i],
                                                timeScale
                                            );
                                        }
                                    };

                                    /**
                                     * Solves a distance constraint with Gauss-Siedel method.
                                     * @private
                                     * @method solve
                                     * @param {constraint} constraint
                                     * @param {number} timeScale
                                     */
                                    Constraint.solve = function (
                                        constraint,
                                        timeScale
                                    ) {
                                        var bodyA = constraint.bodyA,
                                            bodyB = constraint.bodyB,
                                            pointA = constraint.pointA,
                                            pointB = constraint.pointB;

                                        // update reference angle
                                        if (bodyA && !bodyA.isStatic) {
                                            constraint.pointA = Vector.rotate(
                                                pointA,
                                                bodyA.angle - constraint.angleA
                                            );
                                            constraint.angleA = bodyA.angle;
                                        }

                                        // update reference angle
                                        if (bodyB && !bodyB.isStatic) {
                                            constraint.pointB = Vector.rotate(
                                                pointB,
                                                bodyB.angle - constraint.angleB
                                            );
                                            constraint.angleB = bodyB.angle;
                                        }

                                        var pointAWorld = pointA,
                                            pointBWorld = pointB;

                                        if (bodyA)
                                            pointAWorld = Vector.add(
                                                bodyA.position,
                                                pointA
                                            );
                                        if (bodyB)
                                            pointBWorld = Vector.add(
                                                bodyB.position,
                                                pointB
                                            );

                                        if (!pointAWorld || !pointBWorld)
                                            return;

                                        var delta = Vector.sub(
                                                pointAWorld,
                                                pointBWorld
                                            ),
                                            currentLength =
                                                Vector.magnitude(delta);

                                        // prevent singularity
                                        if (currentLength === 0)
                                            currentLength = _minLength;

                                        // solve distance constraint with Gauss-Siedel method
                                        var difference =
                                                (currentLength -
                                                    constraint.length) /
                                                currentLength,
                                            normal = Vector.div(
                                                delta,
                                                currentLength
                                            ),
                                            force = Vector.mult(
                                                delta,
                                                difference *
                                                    0.5 *
                                                    constraint.stiffness *
                                                    timeScale *
                                                    timeScale
                                            );

                                        // if difference is very small, we can skip
                                        if (
                                            Math.abs(
                                                1 -
                                                    currentLength /
                                                        constraint.length
                                            ) <
                                            _minDifference * timeScale
                                        )
                                            return;

                                        var velocityPointA,
                                            velocityPointB,
                                            offsetA,
                                            offsetB,
                                            oAn,
                                            oBn,
                                            bodyADenom,
                                            bodyBDenom;

                                        if (bodyA && !bodyA.isStatic) {
                                            // point body offset
                                            offsetA = {
                                                x:
                                                    pointAWorld.x -
                                                    bodyA.position.x +
                                                    force.x,
                                                y:
                                                    pointAWorld.y -
                                                    bodyA.position.y +
                                                    force.y,
                                            };

                                            // update velocity
                                            bodyA.velocity.x =
                                                bodyA.position.x -
                                                bodyA.positionPrev.x;
                                            bodyA.velocity.y =
                                                bodyA.position.y -
                                                bodyA.positionPrev.y;
                                            bodyA.angularVelocity =
                                                bodyA.angle - bodyA.anglePrev;

                                            // find point velocity and body mass
                                            velocityPointA = Vector.add(
                                                bodyA.velocity,
                                                Vector.mult(
                                                    Vector.perp(offsetA),
                                                    bodyA.angularVelocity
                                                )
                                            );
                                            oAn = Vector.dot(offsetA, normal);
                                            bodyADenom =
                                                bodyA.inverseMass +
                                                bodyA.inverseInertia *
                                                    oAn *
                                                    oAn;
                                        } else {
                                            velocityPointA = { x: 0, y: 0 };
                                            bodyADenom = bodyA
                                                ? bodyA.inverseMass
                                                : 0;
                                        }

                                        if (bodyB && !bodyB.isStatic) {
                                            // point body offset
                                            offsetB = {
                                                x:
                                                    pointBWorld.x -
                                                    bodyB.position.x -
                                                    force.x,
                                                y:
                                                    pointBWorld.y -
                                                    bodyB.position.y -
                                                    force.y,
                                            };

                                            // update velocity
                                            bodyB.velocity.x =
                                                bodyB.position.x -
                                                bodyB.positionPrev.x;
                                            bodyB.velocity.y =
                                                bodyB.position.y -
                                                bodyB.positionPrev.y;
                                            bodyB.angularVelocity =
                                                bodyB.angle - bodyB.anglePrev;

                                            // find point velocity and body mass
                                            velocityPointB = Vector.add(
                                                bodyB.velocity,
                                                Vector.mult(
                                                    Vector.perp(offsetB),
                                                    bodyB.angularVelocity
                                                )
                                            );
                                            oBn = Vector.dot(offsetB, normal);
                                            bodyBDenom =
                                                bodyB.inverseMass +
                                                bodyB.inverseInertia *
                                                    oBn *
                                                    oBn;
                                        } else {
                                            velocityPointB = { x: 0, y: 0 };
                                            bodyBDenom = bodyB
                                                ? bodyB.inverseMass
                                                : 0;
                                        }

                                        var relativeVelocity = Vector.sub(
                                                velocityPointB,
                                                velocityPointA
                                            ),
                                            normalImpulse =
                                                Vector.dot(
                                                    normal,
                                                    relativeVelocity
                                                ) /
                                                (bodyADenom + bodyBDenom);

                                        if (normalImpulse > 0)
                                            normalImpulse = 0;

                                        var normalVelocity = {
                                            x: normal.x * normalImpulse,
                                            y: normal.y * normalImpulse,
                                        };

                                        var torque;

                                        if (bodyA && !bodyA.isStatic) {
                                            torque =
                                                Vector.cross(
                                                    offsetA,
                                                    normalVelocity
                                                ) *
                                                bodyA.inverseInertia *
                                                (1 -
                                                    constraint.angularStiffness);

                                            // keep track of applied impulses for post solving
                                            bodyA.constraintImpulse.x -=
                                                force.x;
                                            bodyA.constraintImpulse.y -=
                                                force.y;
                                            bodyA.constraintImpulse.angle +=
                                                torque;

                                            // apply forces
                                            bodyA.position.x -= force.x;
                                            bodyA.position.y -= force.y;
                                            bodyA.angle += torque;
                                        }

                                        if (bodyB && !bodyB.isStatic) {
                                            torque =
                                                Vector.cross(
                                                    offsetB,
                                                    normalVelocity
                                                ) *
                                                bodyB.inverseInertia *
                                                (1 -
                                                    constraint.angularStiffness);

                                            // keep track of applied impulses for post solving
                                            bodyB.constraintImpulse.x +=
                                                force.x;
                                            bodyB.constraintImpulse.y +=
                                                force.y;
                                            bodyB.constraintImpulse.angle -=
                                                torque;

                                            // apply forces
                                            bodyB.position.x += force.x;
                                            bodyB.position.y += force.y;
                                            bodyB.angle -= torque;
                                        }
                                    };

                                    /**
                                     * Performs body updates required after solving constraints.
                                     * @private
                                     * @method postSolveAll
                                     * @param {body[]} bodies
                                     */
                                    Constraint.postSolveAll = function (
                                        bodies
                                    ) {
                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i],
                                                impulse =
                                                    body.constraintImpulse;

                                            if (
                                                impulse.x === 0 &&
                                                impulse.y === 0 &&
                                                impulse.angle === 0
                                            ) {
                                                continue;
                                            }

                                            Sleeping.set(body, false);

                                            // update geometry and reset
                                            for (
                                                var j = 0;
                                                j < body.parts.length;
                                                j++
                                            ) {
                                                var part = body.parts[j];

                                                Vertices.translate(
                                                    part.vertices,
                                                    impulse
                                                );

                                                if (j > 0) {
                                                    part.position.x +=
                                                        impulse.x;
                                                    part.position.y +=
                                                        impulse.y;
                                                }

                                                if (impulse.angle !== 0) {
                                                    Vertices.rotate(
                                                        part.vertices,
                                                        impulse.angle,
                                                        body.position
                                                    );
                                                    Axes.rotate(
                                                        part.axes,
                                                        impulse.angle
                                                    );
                                                    if (j > 0) {
                                                        Vector.rotateAbout(
                                                            part.position,
                                                            impulse.angle,
                                                            body.position,
                                                            part.position
                                                        );
                                                    }
                                                }

                                                Bounds.update(
                                                    part.bounds,
                                                    part.vertices,
                                                    body.velocity
                                                );
                                            }

                                            impulse.angle = 0;
                                            impulse.x = 0;
                                            impulse.y = 0;
                                        }
                                    };

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
                                     *
                                     * @property id
                                     * @type number
                                     */

                                    /**
                                     * A `String` denoting the type of object.
                                     *
                                     * @property type
                                     * @type string
                                     * @default "constraint"
                                     */

                                    /**
                                     * An arbitrary `String` name to help the user identify and manage bodies.
                                     *
                                     * @property label
                                     * @type string
                                     * @default "Constraint"
                                     */

                                    /**
                                     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
                                     *
                                     * @property render
                                     * @type object
                                     */

                                    /**
                                     * A flag that indicates if the constraint should be rendered.
                                     *
                                     * @property render.visible
                                     * @type boolean
                                     * @default true
                                     */

                                    /**
                                     * A `Number` that defines the line width to use when rendering the constraint outline.
                                     * A value of `0` means no outline will be rendered.
                                     *
                                     * @property render.lineWidth
                                     * @type number
                                     * @default 2
                                     */

                                    /**
                                     * A `String` that defines the stroke style to use when rendering the constraint outline.
                                     * It is the same as when using a canvas, so it accepts CSS style property values.
                                     *
                                     * @property render.strokeStyle
                                     * @type string
                                     * @default a random colour
                                     */

                                    /**
                                     * The first possible `Body` that this constraint is attached to.
                                     *
                                     * @property bodyA
                                     * @type body
                                     * @default null
                                     */

                                    /**
                                     * The second possible `Body` that this constraint is attached to.
                                     *
                                     * @property bodyB
                                     * @type body
                                     * @default null
                                     */

                                    /**
                                     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
                                     *
                                     * @property pointA
                                     * @type vector
                                     * @default { x: 0, y: 0 }
                                     */

                                    /**
                                     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
                                     *
                                     * @property pointB
                                     * @type vector
                                     * @default { x: 0, y: 0 }
                                     */

                                    /**
                                     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
                                     * A value of `1` means the constraint should be very stiff.
                                     * A value of `0.2` means the constraint acts like a soft spring.
                                     *
                                     * @property stiffness
                                     * @type number
                                     * @default 1
                                     */

                                    /**
                                     * A `Number` that specifies the target resting length of the constraint.
                                     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
                                     *
                                     * @property length
                                     * @type number
                                     */
                                })();
                            },
                            {
                                "../core/Common": 14,
                                "../core/Sleeping": 20,
                                "../geometry/Axes": 23,
                                "../geometry/Bounds": 24,
                                "../geometry/Vector": 26,
                                "../geometry/Vertices": 27,
                            },
                        ],
                        13: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
                                 * Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class MouseConstraint
                                 */

                                var MouseConstraint = {};

                                module.exports = MouseConstraint;

                                var Vertices = require("../geometry/Vertices");
                                var Sleeping = require("../core/Sleeping");
                                var Mouse = require("../core/Mouse");
                                var Events = require("../core/Events");
                                var Detector = require("../collision/Detector");
                                var Constraint = require("./Constraint");
                                var Composite = require("../body/Composite");
                                var Common = require("../core/Common");
                                var Bounds = require("../geometry/Bounds");

                                (function () {
                                    /**
                                     * Creates a new mouse constraint.
                                     * All properties have default values, and many are pre-calculated automatically based on other properties.
                                     * See the properties section below for detailed information on what you can pass via the `options` object.
                                     * @method create
                                     * @param {engine} engine
                                     * @param {} options
                                     * @return {MouseConstraint} A new MouseConstraint
                                     */
                                    MouseConstraint.create = function (
                                        engine,
                                        options
                                    ) {
                                        var mouse =
                                            (engine ? engine.mouse : null) ||
                                            (options ? options.mouse : null);

                                        if (!mouse) {
                                            if (
                                                engine &&
                                                engine.render &&
                                                engine.render.canvas
                                            ) {
                                                mouse = Mouse.create(
                                                    engine.render.canvas
                                                );
                                            } else {
                                                mouse = Mouse.create();
                                                Common.log(
                                                    "MouseConstraint.create: options.mouse was undefined, engine.render.canvas was undefined, may not function as expected",
                                                    "warn"
                                                );
                                            }
                                        }

                                        var constraint = Constraint.create({
                                            label: "Mouse Constraint",
                                            pointA: mouse.position,
                                            pointB: { x: 0, y: 0 },
                                            length: 0.01,
                                            stiffness: 0.1,
                                            angularStiffness: 1,
                                            render: {
                                                strokeStyle: "#90EE90",
                                                lineWidth: 3,
                                            },
                                        });

                                        var defaults = {
                                            type: "mouseConstraint",
                                            mouse: mouse,
                                            body: null,
                                            constraint: constraint,
                                            collisionFilter: {
                                                category: 0x0001,
                                                mask: 0xffffffff,
                                                group: 0,
                                            },
                                        };

                                        var mouseConstraint = Common.extend(
                                            defaults,
                                            options
                                        );

                                        Events.on(engine, "tick", function () {
                                            var allBodies = Composite.allBodies(
                                                engine.world
                                            );
                                            MouseConstraint.update(
                                                mouseConstraint,
                                                allBodies
                                            );
                                            _triggerEvents(mouseConstraint);
                                        });

                                        return mouseConstraint;
                                    };

                                    /**
                                     * Updates the given mouse constraint.
                                     * @private
                                     * @method update
                                     * @param {MouseConstraint} mouseConstraint
                                     * @param {body[]} bodies
                                     */
                                    MouseConstraint.update = function (
                                        mouseConstraint,
                                        bodies
                                    ) {
                                        var mouse = mouseConstraint.mouse,
                                            constraint =
                                                mouseConstraint.constraint,
                                            body = mouseConstraint.body;

                                        if (mouse.button === 0) {
                                            if (!constraint.bodyB) {
                                                for (
                                                    var i = 0;
                                                    i < bodies.length;
                                                    i++
                                                ) {
                                                    body = bodies[i];
                                                    if (
                                                        Bounds.contains(
                                                            body.bounds,
                                                            mouse.position
                                                        ) &&
                                                        Detector.canCollide(
                                                            body.collisionFilter,
                                                            mouseConstraint.collisionFilter
                                                        )
                                                    ) {
                                                        for (
                                                            var j =
                                                                body.parts
                                                                    .length > 1
                                                                    ? 1
                                                                    : 0;
                                                            j <
                                                            body.parts.length;
                                                            j++
                                                        ) {
                                                            var part =
                                                                body.parts[j];
                                                            if (
                                                                Vertices.contains(
                                                                    part.vertices,
                                                                    mouse.position
                                                                )
                                                            ) {
                                                                constraint.pointA =
                                                                    mouse.position;
                                                                constraint.bodyB =
                                                                    mouseConstraint.body =
                                                                        body;
                                                                constraint.pointB =
                                                                    {
                                                                        x:
                                                                            mouse
                                                                                .position
                                                                                .x -
                                                                            body
                                                                                .position
                                                                                .x,
                                                                        y:
                                                                            mouse
                                                                                .position
                                                                                .y -
                                                                            body
                                                                                .position
                                                                                .y,
                                                                    };
                                                                constraint.angleB =
                                                                    body.angle;

                                                                Sleeping.set(
                                                                    body,
                                                                    false
                                                                );
                                                                Events.trigger(
                                                                    mouseConstraint,
                                                                    "startdrag",
                                                                    {
                                                                        mouse: mouse,
                                                                        body: body,
                                                                    }
                                                                );

                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                Sleeping.set(
                                                    constraint.bodyB,
                                                    false
                                                );
                                                constraint.pointA =
                                                    mouse.position;
                                            }
                                        } else {
                                            constraint.bodyB =
                                                mouseConstraint.body = null;
                                            constraint.pointB = null;

                                            if (body)
                                                Events.trigger(
                                                    mouseConstraint,
                                                    "enddrag",
                                                    { mouse: mouse, body: body }
                                                );
                                        }
                                    };

                                    /**
                                     * Triggers mouse constraint events.
                                     * @method _triggerEvents
                                     * @private
                                     * @param {mouse} mouseConstraint
                                     */
                                    var _triggerEvents = function (
                                        mouseConstraint
                                    ) {
                                        var mouse = mouseConstraint.mouse,
                                            mouseEvents = mouse.sourceEvents;

                                        if (mouseEvents.mousemove)
                                            Events.trigger(
                                                mouseConstraint,
                                                "mousemove",
                                                { mouse: mouse }
                                            );

                                        if (mouseEvents.mousedown)
                                            Events.trigger(
                                                mouseConstraint,
                                                "mousedown",
                                                { mouse: mouse }
                                            );

                                        if (mouseEvents.mouseup)
                                            Events.trigger(
                                                mouseConstraint,
                                                "mouseup",
                                                { mouse: mouse }
                                            );

                                        // reset the mouse state ready for the next step
                                        Mouse.clearSourceEvents(mouse);
                                    };

                                    /*
                                     *
                                     *  Events Documentation
                                     *
                                     */

                                    /**
                                     * Fired when the mouse has moved (or a touch moves) during the last step
                                     *
                                     * @event mousemove
                                     * @param {} event An event object
                                     * @param {mouse} event.mouse The engine's mouse instance
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when the mouse is down (or a touch has started) during the last step
                                     *
                                     * @event mousedown
                                     * @param {} event An event object
                                     * @param {mouse} event.mouse The engine's mouse instance
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when the mouse is up (or a touch has ended) during the last step
                                     *
                                     * @event mouseup
                                     * @param {} event An event object
                                     * @param {mouse} event.mouse The engine's mouse instance
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when the user starts dragging a body
                                     *
                                     * @event startdrag
                                     * @param {} event An event object
                                     * @param {mouse} event.mouse The engine's mouse instance
                                     * @param {body} event.body The body being dragged
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired when the user ends dragging a body
                                     *
                                     * @event enddrag
                                     * @param {} event An event object
                                     * @param {mouse} event.mouse The engine's mouse instance
                                     * @param {body} event.body The body that has stopped being dragged
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * A `String` denoting the type of object.
                                     *
                                     * @property type
                                     * @type string
                                     * @default "constraint"
                                     */

                                    /**
                                     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
                                     *
                                     * @property mouse
                                     * @type mouse
                                     * @default mouse
                                     */

                                    /**
                                     * The `Body` that is currently being moved by the user, or `null` if no body.
                                     *
                                     * @property body
                                     * @type body
                                     * @default null
                                     */

                                    /**
                                     * The `Constraint` object that is used to move the body during interaction.
                                     *
                                     * @property constraint
                                     * @type constraint
                                     */

                                    /**
                                     * An `Object` that specifies the collision filter properties.
                                     * The collision filter allows the user to define which types of body this mouse constraint can interact with.
                                     * See `body.collisionFilter` for more information.
                                     *
                                     * @property collisionFilter
                                     * @type object
                                     */
                                })();
                            },
                            {
                                "../body/Composite": 2,
                                "../collision/Detector": 5,
                                "../core/Common": 14,
                                "../core/Events": 16,
                                "../core/Mouse": 18,
                                "../core/Sleeping": 20,
                                "../geometry/Bounds": 24,
                                "../geometry/Vertices": 27,
                                "./Constraint": 12,
                            },
                        ],
                        14: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Common` module contains utility functions that are common to all modules.
                                 *
                                 * @class Common
                                 */

                                var Common = {};

                                module.exports = Common;

                                (function () {
                                    Common._nextId = 0;
                                    Common._seed = 0;

                                    /**
                                     * Extends the object in the first argument using the object in the second argument.
                                     * @method extend
                                     * @param {} obj
                                     * @param {boolean} deep
                                     * @return {} obj extended
                                     */
                                    Common.extend = function (obj, deep) {
                                        var argsStart, args, deepClone;

                                        if (typeof deep === "boolean") {
                                            argsStart = 2;
                                            deepClone = deep;
                                        } else {
                                            argsStart = 1;
                                            deepClone = true;
                                        }

                                        args = Array.prototype.slice.call(
                                            arguments,
                                            argsStart
                                        );

                                        for (var i = 0; i < args.length; i++) {
                                            var source = args[i];

                                            if (source) {
                                                for (var prop in source) {
                                                    if (
                                                        deepClone &&
                                                        source[prop] &&
                                                        source[prop]
                                                            .constructor ===
                                                            Object
                                                    ) {
                                                        if (
                                                            !obj[prop] ||
                                                            obj[prop]
                                                                .constructor ===
                                                                Object
                                                        ) {
                                                            obj[prop] =
                                                                obj[prop] || {};
                                                            Common.extend(
                                                                obj[prop],
                                                                deepClone,
                                                                source[prop]
                                                            );
                                                        } else {
                                                            obj[prop] =
                                                                source[prop];
                                                        }
                                                    } else {
                                                        obj[prop] =
                                                            source[prop];
                                                    }
                                                }
                                            }
                                        }

                                        return obj;
                                    };

                                    /**
                                     * Creates a new clone of the object, if deep is true references will also be cloned.
                                     * @method clone
                                     * @param {} obj
                                     * @param {bool} deep
                                     * @return {} obj cloned
                                     */
                                    Common.clone = function (obj, deep) {
                                        return Common.extend({}, deep, obj);
                                    };

                                    /**
                                     * Returns the list of keys for the given object.
                                     * @method keys
                                     * @param {} obj
                                     * @return {string[]} keys
                                     */
                                    Common.keys = function (obj) {
                                        if (Object.keys)
                                            return Object.keys(obj);

                                        // avoid hasOwnProperty for performance
                                        var keys = [];
                                        for (var key in obj) keys.push(key);
                                        return keys;
                                    };

                                    /**
                                     * Returns the list of values for the given object.
                                     * @method values
                                     * @param {} obj
                                     * @return {array} Array of the objects property values
                                     */
                                    Common.values = function (obj) {
                                        var values = [];

                                        if (Object.keys) {
                                            var keys = Object.keys(obj);
                                            for (
                                                var i = 0;
                                                i < keys.length;
                                                i++
                                            ) {
                                                values.push(obj[keys[i]]);
                                            }
                                            return values;
                                        }

                                        // avoid hasOwnProperty for performance
                                        for (var key in obj)
                                            values.push(obj[key]);
                                        return values;
                                    };

                                    /**
                                     * Returns a hex colour string made by lightening or darkening color by percent.
                                     * @method shadeColor
                                     * @param {string} color
                                     * @param {number} percent
                                     * @return {string} A hex colour
                                     */
                                    Common.shadeColor = function (
                                        color,
                                        percent
                                    ) {
                                        // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color
                                        var colorInteger = parseInt(
                                                color.slice(1),
                                                16
                                            ),
                                            amount = Math.round(2.55 * percent),
                                            R = (colorInteger >> 16) + amount,
                                            B =
                                                ((colorInteger >> 8) & 0x00ff) +
                                                amount,
                                            G =
                                                (colorInteger & 0x0000ff) +
                                                amount;
                                        return (
                                            "#" +
                                            (
                                                0x1000000 +
                                                (R < 255
                                                    ? R < 1
                                                        ? 0
                                                        : R
                                                    : 255) *
                                                    0x10000 +
                                                (B < 255
                                                    ? B < 1
                                                        ? 0
                                                        : B
                                                    : 255) *
                                                    0x100 +
                                                (G < 255
                                                    ? G < 1
                                                        ? 0
                                                        : G
                                                    : 255)
                                            )
                                                .toString(16)
                                                .slice(1)
                                        );
                                    };

                                    /**
                                     * Shuffles the given array in-place.
                                     * The function uses a seeded random generator.
                                     * @method shuffle
                                     * @param {array} array
                                     * @return {array} array shuffled randomly
                                     */
                                    Common.shuffle = function (array) {
                                        for (
                                            var i = array.length - 1;
                                            i > 0;
                                            i--
                                        ) {
                                            var j = Math.floor(
                                                Common.random() * (i + 1)
                                            );
                                            var temp = array[i];
                                            array[i] = array[j];
                                            array[j] = temp;
                                        }
                                        return array;
                                    };

                                    /**
                                     * Randomly chooses a value from a list with equal probability.
                                     * The function uses a seeded random generator.
                                     * @method choose
                                     * @param {array} choices
                                     * @return {object} A random choice object from the array
                                     */
                                    Common.choose = function (choices) {
                                        return choices[
                                            Math.floor(
                                                Common.random() * choices.length
                                            )
                                        ];
                                    };

                                    /**
                                     * Returns true if the object is a HTMLElement, otherwise false.
                                     * @method isElement
                                     * @param {object} obj
                                     * @return {boolean} True if the object is a HTMLElement, otherwise false
                                     */
                                    Common.isElement = function (obj) {
                                        // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
                                        try {
                                            return obj instanceof HTMLElement;
                                        } catch (e) {
                                            return (
                                                typeof obj === "object" &&
                                                obj.nodeType === 1 &&
                                                typeof obj.style === "object" &&
                                                typeof obj.ownerDocument ===
                                                    "object"
                                            );
                                        }
                                    };

                                    /**
                                     * Returns true if the object is an array.
                                     * @method isArray
                                     * @param {object} obj
                                     * @return {boolean} True if the object is an array, otherwise false
                                     */
                                    Common.isArray = function (obj) {
                                        return (
                                            Object.prototype.toString.call(
                                                obj
                                            ) === "[object Array]"
                                        );
                                    };

                                    /**
                                     * Returns the given value clamped between a minimum and maximum value.
                                     * @method clamp
                                     * @param {number} value
                                     * @param {number} min
                                     * @param {number} max
                                     * @return {number} The value clamped between min and max inclusive
                                     */
                                    Common.clamp = function (value, min, max) {
                                        if (value < min) return min;
                                        if (value > max) return max;
                                        return value;
                                    };

                                    /**
                                     * Returns the sign of the given value.
                                     * @method sign
                                     * @param {number} value
                                     * @return {number} -1 if negative, +1 if 0 or positive
                                     */
                                    Common.sign = function (value) {
                                        return value < 0 ? -1 : 1;
                                    };

                                    /**
                                     * Returns the current timestamp (high-res if available).
                                     * @method now
                                     * @return {number} the current timestamp (high-res if available)
                                     */
                                    Common.now = function () {
                                        // http://stackoverflow.com/questions/221294/how-do-you-get-a-timestamp-in-javascript
                                        // https://gist.github.com/davidwaterston/2982531

                                        var performance =
                                            window.performance || {};

                                        performance.now = (function () {
                                            return (
                                                performance.now ||
                                                performance.webkitNow ||
                                                performance.msNow ||
                                                performance.oNow ||
                                                performance.mozNow ||
                                                function () {
                                                    return +new Date();
                                                }
                                            );
                                        })();

                                        return performance.now();
                                    };

                                    /**
                                     * Returns a random value between a minimum and a maximum value inclusive.
                                     * The function uses a seeded random generator.
                                     * @method random
                                     * @param {number} min
                                     * @param {number} max
                                     * @return {number} A random number between min and max inclusive
                                     */
                                    Common.random = function (min, max) {
                                        min =
                                            typeof min !== "undefined"
                                                ? min
                                                : 0;
                                        max =
                                            typeof max !== "undefined"
                                                ? max
                                                : 1;
                                        return (
                                            min + _seededRandom() * (max - min)
                                        );
                                    };

                                    /**
                                     * Converts a CSS hex colour string into an integer.
                                     * @method colorToNumber
                                     * @param {string} colorString
                                     * @return {number} An integer representing the CSS hex string
                                     */
                                    Common.colorToNumber = function (
                                        colorString
                                    ) {
                                        colorString = colorString.replace(
                                            "#",
                                            ""
                                        );

                                        if (colorString.length == 3) {
                                            colorString =
                                                colorString.charAt(0) +
                                                colorString.charAt(0) +
                                                colorString.charAt(1) +
                                                colorString.charAt(1) +
                                                colorString.charAt(2) +
                                                colorString.charAt(2);
                                        }

                                        return parseInt(colorString, 16);
                                    };

                                    /**
                                     * A wrapper for console.log, for providing errors and warnings.
                                     * @method log
                                     * @param {string} message
                                     * @param {string} type
                                     */
                                    Common.log = function (message, type) {
                                        if (
                                            !console ||
                                            !console.log ||
                                            !console.warn
                                        )
                                            return;

                                        switch (type) {
                                            case "warn":
                                                console.warn(
                                                    "Matter.js:",
                                                    message
                                                );
                                                break;
                                            case "error":
                                                console.log(
                                                    "Matter.js:",
                                                    message
                                                );
                                                break;
                                        }
                                    };

                                    /**
                                     * Returns the next unique sequential ID.
                                     * @method nextId
                                     * @return {Number} Unique sequential ID
                                     */
                                    Common.nextId = function () {
                                        return Common._nextId++;
                                    };

                                    /**
                                     * A cross browser compatible indexOf implementation.
                                     * @method indexOf
                                     * @param {array} haystack
                                     * @param {object} needle
                                     */
                                    Common.indexOf = function (
                                        haystack,
                                        needle
                                    ) {
                                        if (haystack.indexOf)
                                            return haystack.indexOf(needle);

                                        for (
                                            var i = 0;
                                            i < haystack.length;
                                            i++
                                        ) {
                                            if (haystack[i] === needle)
                                                return i;
                                        }

                                        return -1;
                                    };

                                    var _seededRandom = function () {
                                        // https://gist.github.com/ngryman/3830489
                                        Common._seed =
                                            (Common._seed * 9301 + 49297) %
                                            233280;
                                        return Common._seed / 233280;
                                    };
                                })();
                            },
                            {},
                        ],
                        15: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Engine` module contains methods for creating and manipulating engines.
                                 * An engine is a controller that manages updating the simulation of the world.
                                 * See `Matter.Runner` for an optional game loop utility.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Engine
                                 */

                                var Engine = {};

                                module.exports = Engine;

                                var World = require("../body/World");
                                var Sleeping = require("./Sleeping");
                                var Resolver = require("../collision/Resolver");
                                var Render = require("../render/Render");
                                var Pairs = require("../collision/Pairs");
                                var Metrics = require("./Metrics");
                                var Grid = require("../collision/Grid");
                                var Events = require("./Events");
                                var Composite = require("../body/Composite");
                                var Constraint = require("../constraint/Constraint");
                                var Common = require("./Common");
                                var Body = require("../body/Body");

                                (function () {
                                    /**
                                     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * All properties have default values, and many are pre-calculated automatically based on other properties.
                                     * See the properties section below for detailed information on what you can pass via the `options` object.
                                     * @method create
                                     * @param {HTMLElement} element
                                     * @param {object} [options]
                                     * @return {engine} engine
                                     */
                                    Engine.create = function (
                                        element,
                                        options
                                    ) {
                                        // options may be passed as the first (and only) argument
                                        options = Common.isElement(element)
                                            ? options
                                            : element;
                                        element = Common.isElement(element)
                                            ? element
                                            : null;

                                        var defaults = {
                                            positionIterations: 6,
                                            velocityIterations: 4,
                                            constraintIterations: 2,
                                            enableSleeping: false,
                                            events: [],
                                            timing: {
                                                timestamp: 0,
                                                timeScale: 1,
                                            },
                                            broadphase: {
                                                controller: Grid,
                                            },
                                        };

                                        var engine = Common.extend(
                                            defaults,
                                            options
                                        );

                                        if (element || engine.render) {
                                            var renderDefaults = {
                                                element: element,
                                                controller: Render,
                                            };

                                            engine.render = Common.extend(
                                                renderDefaults,
                                                engine.render
                                            );
                                        }

                                        if (
                                            engine.render &&
                                            engine.render.controller
                                        ) {
                                            engine.render =
                                                engine.render.controller.create(
                                                    engine.render
                                                );
                                        }

                                        engine.world = World.create(
                                            engine.world
                                        );
                                        engine.pairs = Pairs.create();
                                        engine.broadphase =
                                            engine.broadphase.controller.create(
                                                engine.broadphase
                                            );
                                        engine.metrics = engine.metrics || {
                                            extended: false,
                                        };

                                        return engine;
                                    };

                                    /**
                                     * Moves the simulation forward in time by `delta` ms.
                                     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
                                     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
                                     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
                                     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
                                     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
                                     *
                                     * Triggers `beforeUpdate` and `afterUpdate` events.
                                     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
                                     * @method update
                                     * @param {engine} engine
                                     * @param {number} [delta=16.666]
                                     * @param {number} [correction=1]
                                     */
                                    Engine.update = function (
                                        engine,
                                        delta,
                                        correction
                                    ) {
                                        delta = delta || 1000 / 60;
                                        correction = correction || 1;

                                        var world = engine.world,
                                            timing = engine.timing,
                                            broadphase = engine.broadphase,
                                            broadphasePairs = [],
                                            i;

                                        // increment timestamp
                                        timing.timestamp +=
                                            delta * timing.timeScale;

                                        // create an event object
                                        var event = {
                                            timestamp: timing.timestamp,
                                        };

                                        Events.trigger(
                                            engine,
                                            "beforeUpdate",
                                            event
                                        );

                                        // get lists of all bodies and constraints, no matter what composites they are in
                                        var allBodies =
                                                Composite.allBodies(world),
                                            allConstraints =
                                                Composite.allConstraints(world);

                                        // if sleeping enabled, call the sleeping controller
                                        if (engine.enableSleeping)
                                            Sleeping.update(
                                                allBodies,
                                                timing.timeScale
                                            );

                                        // applies gravity to all bodies
                                        _bodiesApplyGravity(
                                            allBodies,
                                            world.gravity
                                        );

                                        // update all body position and rotation by integration
                                        _bodiesUpdate(
                                            allBodies,
                                            delta,
                                            timing.timeScale,
                                            correction,
                                            world.bounds
                                        );

                                        // update all constraints
                                        for (
                                            i = 0;
                                            i < engine.constraintIterations;
                                            i++
                                        ) {
                                            Constraint.solveAll(
                                                allConstraints,
                                                timing.timeScale
                                            );
                                        }
                                        Constraint.postSolveAll(allBodies);

                                        // broadphase pass: find potential collision pairs
                                        if (broadphase.controller) {
                                            // if world is dirty, we must flush the whole grid
                                            if (world.isModified)
                                                broadphase.controller.clear(
                                                    broadphase
                                                );

                                            // update the grid buckets based on current bodies
                                            broadphase.controller.update(
                                                broadphase,
                                                allBodies,
                                                engine,
                                                world.isModified
                                            );
                                            broadphasePairs =
                                                broadphase.pairsList;
                                        } else {
                                            // if no broadphase set, we just pass all bodies
                                            broadphasePairs = allBodies;
                                        }

                                        // narrowphase pass: find actual collisions, then create or update collision pairs
                                        var collisions = broadphase.detector(
                                            broadphasePairs,
                                            engine
                                        );

                                        // update collision pairs
                                        var pairs = engine.pairs,
                                            timestamp = timing.timestamp;
                                        Pairs.update(
                                            pairs,
                                            collisions,
                                            timestamp
                                        );
                                        Pairs.removeOld(pairs, timestamp);

                                        // wake up bodies involved in collisions
                                        if (engine.enableSleeping)
                                            Sleeping.afterCollisions(
                                                pairs.list,
                                                timing.timeScale
                                            );

                                        // trigger collision events
                                        if (pairs.collisionStart.length > 0)
                                            Events.trigger(
                                                engine,
                                                "collisionStart",
                                                { pairs: pairs.collisionStart }
                                            );

                                        // iteratively resolve position between collisions
                                        Resolver.preSolvePosition(pairs.list);
                                        for (
                                            i = 0;
                                            i < engine.positionIterations;
                                            i++
                                        ) {
                                            Resolver.solvePosition(
                                                pairs.list,
                                                timing.timeScale
                                            );
                                        }
                                        Resolver.postSolvePosition(allBodies);

                                        // iteratively resolve velocity between collisions
                                        Resolver.preSolveVelocity(pairs.list);
                                        for (
                                            i = 0;
                                            i < engine.velocityIterations;
                                            i++
                                        ) {
                                            Resolver.solveVelocity(
                                                pairs.list,
                                                timing.timeScale
                                            );
                                        }

                                        // trigger collision events
                                        if (pairs.collisionActive.length > 0)
                                            Events.trigger(
                                                engine,
                                                "collisionActive",
                                                { pairs: pairs.collisionActive }
                                            );

                                        if (pairs.collisionEnd.length > 0)
                                            Events.trigger(
                                                engine,
                                                "collisionEnd",
                                                { pairs: pairs.collisionEnd }
                                            );

                                        // clear force buffers
                                        _bodiesClearForces(allBodies);

                                        // clear all composite modified flags
                                        if (world.isModified)
                                            Composite.setModified(
                                                world,
                                                false,
                                                false,
                                                true
                                            );

                                        Events.trigger(
                                            engine,
                                            "afterUpdate",
                                            event
                                        );

                                        return engine;
                                    };

                                    /**
                                     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
                                     * @method merge
                                     * @param {engine} engineA
                                     * @param {engine} engineB
                                     */
                                    Engine.merge = function (engineA, engineB) {
                                        Common.extend(engineA, engineB);

                                        if (engineB.world) {
                                            engineA.world = engineB.world;

                                            Engine.clear(engineA);

                                            var bodies = Composite.allBodies(
                                                engineA.world
                                            );

                                            for (
                                                var i = 0;
                                                i < bodies.length;
                                                i++
                                            ) {
                                                var body = bodies[i];
                                                Sleeping.set(body, false);
                                                body.id = Common.nextId();
                                            }
                                        }
                                    };

                                    /**
                                     * Clears the engine including the world, pairs and broadphase.
                                     * @method clear
                                     * @param {engine} engine
                                     */
                                    Engine.clear = function (engine) {
                                        var world = engine.world;

                                        Pairs.clear(engine.pairs);

                                        var broadphase = engine.broadphase;
                                        if (broadphase.controller) {
                                            var bodies =
                                                Composite.allBodies(world);
                                            broadphase.controller.clear(
                                                broadphase
                                            );
                                            broadphase.controller.update(
                                                broadphase,
                                                bodies,
                                                engine,
                                                true
                                            );
                                        }
                                    };

                                    /**
                                     * Zeroes the `body.force` and `body.torque` force buffers.
                                     * @method bodiesClearForces
                                     * @private
                                     * @param {body[]} bodies
                                     */
                                    var _bodiesClearForces = function (bodies) {
                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            // reset force buffers
                                            body.force.x = 0;
                                            body.force.y = 0;
                                            body.torque = 0;
                                        }
                                    };

                                    /**
                                     * Applys a mass dependant force to all given bodies.
                                     * @method bodiesApplyGravity
                                     * @private
                                     * @param {body[]} bodies
                                     * @param {vector} gravity
                                     */
                                    var _bodiesApplyGravity = function (
                                        bodies,
                                        gravity
                                    ) {
                                        var gravityScale =
                                            typeof gravity.scale !== "undefined"
                                                ? gravity.scale
                                                : 0.001;

                                        if (
                                            (gravity.x === 0 &&
                                                gravity.y === 0) ||
                                            gravityScale === 0
                                        ) {
                                            return;
                                        }

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            if (
                                                body.isStatic ||
                                                body.isSleeping
                                            )
                                                continue;

                                            // apply gravity
                                            body.force.y +=
                                                body.mass *
                                                gravity.y *
                                                gravityScale;
                                            body.force.x +=
                                                body.mass *
                                                gravity.x *
                                                gravityScale;
                                        }
                                    };

                                    /**
                                     * Applys `Body.update` to all given `bodies`.
                                     * @method updateAll
                                     * @private
                                     * @param {body[]} bodies
                                     * @param {number} deltaTime
                                     * The amount of time elapsed between updates
                                     * @param {number} timeScale
                                     * @param {number} correction
                                     * The Verlet correction factor (deltaTime / lastDeltaTime)
                                     * @param {bounds} worldBounds
                                     */
                                    var _bodiesUpdate = function (
                                        bodies,
                                        deltaTime,
                                        timeScale,
                                        correction,
                                        worldBounds
                                    ) {
                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            if (
                                                body.isStatic ||
                                                body.isSleeping
                                            )
                                                continue;

                                            Body.update(
                                                body,
                                                deltaTime,
                                                timeScale,
                                                correction
                                            );
                                        }
                                    };

                                    /**
                                     * An alias for `Runner.run`, see `Matter.Runner` for more information.
                                     * @method run
                                     * @param {engine} engine
                                     */

                                    /**
                                     * Fired just before an update
                                     *
                                     * @event beforeUpdate
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after engine update and all collision events
                                     *
                                     * @event afterUpdate
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
                                     *
                                     * @event collisionStart
                                     * @param {} event An event object
                                     * @param {} event.pairs List of affected pairs
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
                                     *
                                     * @event collisionActive
                                     * @param {} event An event object
                                     * @param {} event.pairs List of affected pairs
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
                                     *
                                     * @event collisionEnd
                                     * @param {} event An event object
                                     * @param {} event.pairs List of affected pairs
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * An integer `Number` that specifies the number of position iterations to perform each update.
                                     * The higher the value, the higher quality the simulation will be at the expense of performance.
                                     *
                                     * @property positionIterations
                                     * @type number
                                     * @default 6
                                     */

                                    /**
                                     * An integer `Number` that specifies the number of velocity iterations to perform each update.
                                     * The higher the value, the higher quality the simulation will be at the expense of performance.
                                     *
                                     * @property velocityIterations
                                     * @type number
                                     * @default 4
                                     */

                                    /**
                                     * An integer `Number` that specifies the number of constraint iterations to perform each update.
                                     * The higher the value, the higher quality the simulation will be at the expense of performance.
                                     * The default value of `2` is usually very adequate.
                                     *
                                     * @property constraintIterations
                                     * @type number
                                     * @default 2
                                     */

                                    /**
                                     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
                                     * Sleeping can improve stability and performance, but often at the expense of accuracy.
                                     *
                                     * @property enableSleeping
                                     * @type boolean
                                     * @default false
                                     */

                                    /**
                                     * An `Object` containing properties regarding the timing systems of the engine.
                                     *
                                     * @property timing
                                     * @type object
                                     */

                                    /**
                                     * A `Number` that specifies the global scaling factor of time for all bodies.
                                     * A value of `0` freezes the simulation.
                                     * A value of `0.1` gives a slow-motion effect.
                                     * A value of `1.2` gives a speed-up effect.
                                     *
                                     * @property timing.timeScale
                                     * @type number
                                     * @default 1
                                     */

                                    /**
                                     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`.
                                     * It is incremented on every `Engine.update` by the given `delta` argument.
                                     *
                                     * @property timing.timestamp
                                     * @type number
                                     * @default 0
                                     */

                                    /**
                                     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.
                                     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.
                                     *
                                     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
                                     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.
                                     *
                                     * @property render
                                     * @type render
                                     * @default a Matter.Render instance
                                     */

                                    /**
                                     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
                                     *
                                     * @property broadphase
                                     * @type grid
                                     * @default a Matter.Grid instance
                                     */

                                    /**
                                     * A `World` composite object that will contain all simulated bodies and constraints.
                                     *
                                     * @property world
                                     * @type world
                                     * @default a Matter.World instance
                                     */
                                })();
                            },
                            {
                                "../body/Body": 1,
                                "../body/Composite": 2,
                                "../body/World": 3,
                                "../collision/Grid": 6,
                                "../collision/Pairs": 8,
                                "../collision/Resolver": 10,
                                "../constraint/Constraint": 12,
                                "../render/Render": 29,
                                "./Common": 14,
                                "./Events": 16,
                                "./Metrics": 17,
                                "./Sleeping": 20,
                            },
                        ],
                        16: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Events` module contains methods to fire and listen to events on other objects.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Events
                                 */

                                var Events = {};

                                module.exports = Events;

                                var Common = require("./Common");

                                (function () {
                                    /**
                                     * Subscribes a callback function to the given object's `eventName`.
                                     * @method on
                                     * @param {} object
                                     * @param {string} eventNames
                                     * @param {function} callback
                                     */
                                    Events.on = function (
                                        object,
                                        eventNames,
                                        callback
                                    ) {
                                        var names = eventNames.split(" "),
                                            name;

                                        for (var i = 0; i < names.length; i++) {
                                            name = names[i];
                                            object.events = object.events || {};
                                            object.events[name] =
                                                object.events[name] || [];
                                            object.events[name].push(callback);
                                        }

                                        return callback;
                                    };

                                    /**
                                     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
                                     * @method off
                                     * @param {} object
                                     * @param {string} eventNames
                                     * @param {function} callback
                                     */
                                    Events.off = function (
                                        object,
                                        eventNames,
                                        callback
                                    ) {
                                        if (!eventNames) {
                                            object.events = {};
                                            return;
                                        }

                                        // handle Events.off(object, callback)
                                        if (typeof eventNames === "function") {
                                            callback = eventNames;
                                            eventNames = Common.keys(
                                                object.events
                                            ).join(" ");
                                        }

                                        var names = eventNames.split(" ");

                                        for (var i = 0; i < names.length; i++) {
                                            var callbacks =
                                                    object.events[names[i]],
                                                newCallbacks = [];

                                            if (callback && callbacks) {
                                                for (
                                                    var j = 0;
                                                    j < callbacks.length;
                                                    j++
                                                ) {
                                                    if (
                                                        callbacks[j] !==
                                                        callback
                                                    )
                                                        newCallbacks.push(
                                                            callbacks[j]
                                                        );
                                                }
                                            }

                                            object.events[names[i]] =
                                                newCallbacks;
                                        }
                                    };

                                    /**
                                     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
                                     * @method trigger
                                     * @param {} object
                                     * @param {string} eventNames
                                     * @param {} event
                                     */
                                    Events.trigger = function (
                                        object,
                                        eventNames,
                                        event
                                    ) {
                                        var names, name, callbacks, eventClone;

                                        if (object.events) {
                                            if (!event) event = {};

                                            names = eventNames.split(" ");

                                            for (
                                                var i = 0;
                                                i < names.length;
                                                i++
                                            ) {
                                                name = names[i];
                                                callbacks = object.events[name];

                                                if (callbacks) {
                                                    eventClone = Common.clone(
                                                        event,
                                                        false
                                                    );
                                                    eventClone.name = name;
                                                    eventClone.source = object;

                                                    for (
                                                        var j = 0;
                                                        j < callbacks.length;
                                                        j++
                                                    ) {
                                                        callbacks[j].apply(
                                                            object,
                                                            [eventClone]
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                    };
                                })();
                            },
                            { "./Common": 14 },
                        ],
                        17: [
                            function (require, module, exports) {},
                            { "../body/Composite": 2, "./Common": 14 },
                        ],
                        18: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
                                 *
                                 * @class Mouse
                                 */

                                var Mouse = {};

                                module.exports = Mouse;

                                var Common = require("../core/Common");

                                (function () {
                                    /**
                                     * Creates a mouse input.
                                     * @method create
                                     * @param {HTMLElement} element
                                     * @return {mouse} A new mouse
                                     */
                                    Mouse.create = function (element) {
                                        var mouse = {};

                                        if (!element) {
                                            Common.log(
                                                "Mouse.create: element was undefined, defaulting to document.body",
                                                "warn"
                                            );
                                        }

                                        mouse.element =
                                            element || document.body;
                                        mouse.absolute = { x: 0, y: 0 };
                                        mouse.position = { x: 0, y: 0 };
                                        mouse.mousedownPosition = {
                                            x: 0,
                                            y: 0,
                                        };
                                        mouse.mouseupPosition = { x: 0, y: 0 };
                                        mouse.offset = { x: 0, y: 0 };
                                        mouse.scale = { x: 1, y: 1 };
                                        mouse.wheelDelta = 0;
                                        mouse.button = -1;
                                        mouse.pixelRatio =
                                            mouse.element.getAttribute(
                                                "data-pixel-ratio"
                                            ) || 1;

                                        mouse.sourceEvents = {
                                            mousemove: null,
                                            mousedown: null,
                                            mouseup: null,
                                            mousewheel: null,
                                        };

                                        mouse.mousemove = function (event) {
                                            var position =
                                                    _getRelativeMousePosition(
                                                        event,
                                                        mouse.element,
                                                        mouse.pixelRatio
                                                    ),
                                                touches = event.changedTouches;

                                            if (touches) {
                                                mouse.button = 0;
                                                event.preventDefault();
                                            }

                                            mouse.absolute.x = position.x;
                                            mouse.absolute.y = position.y;
                                            mouse.position.x =
                                                mouse.absolute.x *
                                                    mouse.scale.x +
                                                mouse.offset.x;
                                            mouse.position.y =
                                                mouse.absolute.y *
                                                    mouse.scale.y +
                                                mouse.offset.y;
                                            mouse.sourceEvents.mousemove =
                                                event;
                                        };

                                        mouse.mousedown = function (event) {
                                            var position =
                                                    _getRelativeMousePosition(
                                                        event,
                                                        mouse.element,
                                                        mouse.pixelRatio
                                                    ),
                                                touches = event.changedTouches;

                                            if (touches) {
                                                mouse.button = 0;
                                                event.preventDefault();
                                            } else {
                                                mouse.button = event.button;
                                            }

                                            mouse.absolute.x = position.x;
                                            mouse.absolute.y = position.y;
                                            mouse.position.x =
                                                mouse.absolute.x *
                                                    mouse.scale.x +
                                                mouse.offset.x;
                                            mouse.position.y =
                                                mouse.absolute.y *
                                                    mouse.scale.y +
                                                mouse.offset.y;
                                            mouse.mousedownPosition.x =
                                                mouse.position.x;
                                            mouse.mousedownPosition.y =
                                                mouse.position.y;
                                            mouse.sourceEvents.mousedown =
                                                event;
                                        };

                                        mouse.mouseup = function (event) {
                                            var position =
                                                    _getRelativeMousePosition(
                                                        event,
                                                        mouse.element,
                                                        mouse.pixelRatio
                                                    ),
                                                touches = event.changedTouches;

                                            if (touches) {
                                                event.preventDefault();
                                            }

                                            mouse.button = -1;
                                            mouse.absolute.x = position.x;
                                            mouse.absolute.y = position.y;
                                            mouse.position.x =
                                                mouse.absolute.x *
                                                    mouse.scale.x +
                                                mouse.offset.x;
                                            mouse.position.y =
                                                mouse.absolute.y *
                                                    mouse.scale.y +
                                                mouse.offset.y;
                                            mouse.mouseupPosition.x =
                                                mouse.position.x;
                                            mouse.mouseupPosition.y =
                                                mouse.position.y;
                                            mouse.sourceEvents.mouseup = event;
                                        };

                                        mouse.mousewheel = function (event) {
                                            mouse.wheelDelta = Math.max(
                                                -1,
                                                Math.min(
                                                    1,
                                                    event.wheelDelta ||
                                                        -event.detail
                                                )
                                            );
                                            event.preventDefault();
                                        };

                                        Mouse.setElement(mouse, mouse.element);

                                        return mouse;
                                    };

                                    /**
                                     * Sets the element the mouse is bound to (and relative to).
                                     * @method setElement
                                     * @param {mouse} mouse
                                     * @param {HTMLElement} element
                                     */
                                    Mouse.setElement = function (
                                        mouse,
                                        element
                                    ) {
                                        mouse.element = element;

                                        element.addEventListener(
                                            "mousemove",
                                            mouse.mousemove
                                        );
                                        element.addEventListener(
                                            "mousedown",
                                            mouse.mousedown
                                        );
                                        element.addEventListener(
                                            "mouseup",
                                            mouse.mouseup
                                        );

                                        element.addEventListener(
                                            "mousewheel",
                                            mouse.mousewheel
                                        );
                                        element.addEventListener(
                                            "DOMMouseScroll",
                                            mouse.mousewheel
                                        );

                                        element.addEventListener(
                                            "touchmove",
                                            mouse.mousemove
                                        );
                                        element.addEventListener(
                                            "touchstart",
                                            mouse.mousedown
                                        );
                                        element.addEventListener(
                                            "touchend",
                                            mouse.mouseup
                                        );
                                    };

                                    /**
                                     * Clears all captured source events.
                                     * @method clearSourceEvents
                                     * @param {mouse} mouse
                                     */
                                    Mouse.clearSourceEvents = function (mouse) {
                                        mouse.sourceEvents.mousemove = null;
                                        mouse.sourceEvents.mousedown = null;
                                        mouse.sourceEvents.mouseup = null;
                                        mouse.sourceEvents.mousewheel = null;
                                        mouse.wheelDelta = 0;
                                    };

                                    /**
                                     * Sets the mouse position offset.
                                     * @method setOffset
                                     * @param {mouse} mouse
                                     * @param {vector} offset
                                     */
                                    Mouse.setOffset = function (mouse, offset) {
                                        mouse.offset.x = offset.x;
                                        mouse.offset.y = offset.y;
                                        mouse.position.x =
                                            mouse.absolute.x * mouse.scale.x +
                                            mouse.offset.x;
                                        mouse.position.y =
                                            mouse.absolute.y * mouse.scale.y +
                                            mouse.offset.y;
                                    };

                                    /**
                                     * Sets the mouse position scale.
                                     * @method setScale
                                     * @param {mouse} mouse
                                     * @param {vector} scale
                                     */
                                    Mouse.setScale = function (mouse, scale) {
                                        mouse.scale.x = scale.x;
                                        mouse.scale.y = scale.y;
                                        mouse.position.x =
                                            mouse.absolute.x * mouse.scale.x +
                                            mouse.offset.x;
                                        mouse.position.y =
                                            mouse.absolute.y * mouse.scale.y +
                                            mouse.offset.y;
                                    };

                                    /**
                                     * Gets the mouse position relative to an element given a screen pixel ratio.
                                     * @method _getRelativeMousePosition
                                     * @private
                                     * @param {} event
                                     * @param {} element
                                     * @param {number} pixelRatio
                                     * @return {}
                                     */
                                    var _getRelativeMousePosition = function (
                                        event,
                                        element,
                                        pixelRatio
                                    ) {
                                        var elementBounds =
                                                element.getBoundingClientRect(),
                                            rootNode =
                                                document.documentElement ||
                                                document.body.parentNode ||
                                                document.body,
                                            scrollX =
                                                window.pageXOffset !== undefined
                                                    ? window.pageXOffset
                                                    : rootNode.scrollLeft,
                                            scrollY =
                                                window.pageYOffset !== undefined
                                                    ? window.pageYOffset
                                                    : rootNode.scrollTop,
                                            touches = event.changedTouches,
                                            x,
                                            y;

                                        if (touches) {
                                            x =
                                                touches[0].pageX -
                                                elementBounds.left -
                                                scrollX;
                                            y =
                                                touches[0].pageY -
                                                elementBounds.top -
                                                scrollY;
                                        } else {
                                            x =
                                                event.pageX -
                                                elementBounds.left -
                                                scrollX;
                                            y =
                                                event.pageY -
                                                elementBounds.top -
                                                scrollY;
                                        }

                                        return {
                                            x:
                                                x /
                                                ((element.clientWidth /
                                                    element.width) *
                                                    pixelRatio),
                                            y:
                                                y /
                                                ((element.clientHeight /
                                                    element.height) *
                                                    pixelRatio),
                                        };
                                    };
                                })();
                            },
                            { "../core/Common": 14 },
                        ],
                        19: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Runner` module is an optional utility which provides a game loop,
                                 * that handles updating and rendering a `Matter.Engine` for you within a browser.
                                 * It is intended for demo and testing purposes, but may be adequate for simple games.
                                 * If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
                                 * Instead just call `Engine.update(engine, delta)` in your own loop.
                                 * Note that the method `Engine.run` is an alias for `Runner.run`.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Runner
                                 */

                                var Runner = {};

                                module.exports = Runner;

                                var Events = require("./Events");
                                var Engine = require("./Engine");
                                var Common = require("./Common");

                                (function () {
                                    var _requestAnimationFrame,
                                        _cancelAnimationFrame;

                                    if (typeof window !== "undefined") {
                                        _requestAnimationFrame =
                                            window.requestAnimationFrame ||
                                            window.webkitRequestAnimationFrame ||
                                            window.mozRequestAnimationFrame ||
                                            window.msRequestAnimationFrame ||
                                            function (callback) {
                                                window.setTimeout(function () {
                                                    callback(Common.now());
                                                }, 1000 / 60);
                                            };

                                        _cancelAnimationFrame =
                                            window.cancelAnimationFrame ||
                                            window.mozCancelAnimationFrame ||
                                            window.webkitCancelAnimationFrame ||
                                            window.msCancelAnimationFrame;
                                    }

                                    /**
                                     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * @method create
                                     * @param {} options
                                     */
                                    Runner.create = function (options) {
                                        var defaults = {
                                            fps: 60,
                                            correction: 1,
                                            deltaSampleSize: 60,
                                            counterTimestamp: 0,
                                            frameCounter: 0,
                                            deltaHistory: [],
                                            timePrev: null,
                                            timeScalePrev: 1,
                                            frameRequestId: null,
                                            isFixed: false,
                                            enabled: true,
                                        };

                                        var runner = Common.extend(
                                            defaults,
                                            options
                                        );

                                        runner.delta =
                                            runner.delta || 1000 / runner.fps;
                                        runner.deltaMin =
                                            runner.deltaMin ||
                                            1000 / runner.fps;
                                        runner.deltaMax =
                                            runner.deltaMax ||
                                            1000 / (runner.fps * 0.5);
                                        runner.fps = 1000 / runner.delta;

                                        return runner;
                                    };

                                    /**
                                     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
                                     * @method run
                                     * @param {engine} engine
                                     */
                                    Runner.run = function (runner, engine) {
                                        // create runner if engine is first argument
                                        if (
                                            typeof runner.positionIterations !==
                                            "undefined"
                                        ) {
                                            engine = runner;
                                            runner = Runner.create();
                                        }

                                        (function render(time) {
                                            runner.frameRequestId =
                                                _requestAnimationFrame(render);

                                            if (time && runner.enabled) {
                                                Runner.tick(
                                                    runner,
                                                    engine,
                                                    time
                                                );
                                            }
                                        })();

                                        return runner;
                                    };

                                    /**
                                     * A game loop utility that updates the engine and renderer by one step (a 'tick').
                                     * Features delta smoothing, time correction and fixed or dynamic timing.
                                     * Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
                                     * Consider just `Engine.update(engine, delta)` if you're using your own loop.
                                     * @method tick
                                     * @param {runner} runner
                                     * @param {engine} engine
                                     * @param {number} time
                                     */
                                    Runner.tick = function (
                                        runner,
                                        engine,
                                        time
                                    ) {
                                        var timing = engine.timing,
                                            correction = 1,
                                            delta;

                                        // create an event object
                                        var event = {
                                            timestamp: timing.timestamp,
                                        };

                                        Events.trigger(
                                            runner,
                                            "beforeTick",
                                            event
                                        );
                                        Events.trigger(
                                            engine,
                                            "beforeTick",
                                            event
                                        ); // @deprecated

                                        if (runner.isFixed) {
                                            // fixed timestep
                                            delta = runner.delta;
                                        } else {
                                            // dynamic timestep based on wall clock between calls
                                            delta =
                                                time - runner.timePrev ||
                                                runner.delta;
                                            runner.timePrev = time;

                                            // optimistically filter delta over a few frames, to improve stability
                                            runner.deltaHistory.push(delta);
                                            runner.deltaHistory =
                                                runner.deltaHistory.slice(
                                                    -runner.deltaSampleSize
                                                );
                                            delta = Math.min.apply(
                                                null,
                                                runner.deltaHistory
                                            );

                                            // limit delta
                                            delta =
                                                delta < runner.deltaMin
                                                    ? runner.deltaMin
                                                    : delta;
                                            delta =
                                                delta > runner.deltaMax
                                                    ? runner.deltaMax
                                                    : delta;

                                            // correction for delta
                                            correction = delta / runner.delta;

                                            // update engine timing object
                                            runner.delta = delta;
                                        }

                                        // time correction for time scaling
                                        if (runner.timeScalePrev !== 0)
                                            correction *=
                                                timing.timeScale /
                                                runner.timeScalePrev;

                                        if (timing.timeScale === 0)
                                            correction = 0;

                                        runner.timeScalePrev = timing.timeScale;
                                        runner.correction = correction;

                                        // fps counter
                                        runner.frameCounter += 1;
                                        if (
                                            time - runner.counterTimestamp >=
                                            1000
                                        ) {
                                            runner.fps =
                                                runner.frameCounter *
                                                ((time -
                                                    runner.counterTimestamp) /
                                                    1000);
                                            runner.counterTimestamp = time;
                                            runner.frameCounter = 0;
                                        }

                                        Events.trigger(runner, "tick", event);
                                        Events.trigger(engine, "tick", event); // @deprecated

                                        // if world has been modified, clear the render scene graph
                                        if (
                                            engine.world.isModified &&
                                            engine.render &&
                                            engine.render.controller &&
                                            engine.render.controller.clear
                                        ) {
                                            engine.render.controller.clear(
                                                engine.render
                                            );
                                        }

                                        // update
                                        Events.trigger(
                                            runner,
                                            "beforeUpdate",
                                            event
                                        );
                                        Engine.update(
                                            engine,
                                            delta,
                                            correction
                                        );
                                        Events.trigger(
                                            runner,
                                            "afterUpdate",
                                            event
                                        );

                                        // render
                                        if (
                                            engine.render &&
                                            engine.render.controller
                                        ) {
                                            Events.trigger(
                                                runner,
                                                "beforeRender",
                                                event
                                            );
                                            Events.trigger(
                                                engine,
                                                "beforeRender",
                                                event
                                            ); // @deprecated

                                            engine.render.controller.world(
                                                engine
                                            );

                                            Events.trigger(
                                                runner,
                                                "afterRender",
                                                event
                                            );
                                            Events.trigger(
                                                engine,
                                                "afterRender",
                                                event
                                            ); // @deprecated
                                        }

                                        Events.trigger(
                                            runner,
                                            "afterTick",
                                            event
                                        );
                                        Events.trigger(
                                            engine,
                                            "afterTick",
                                            event
                                        ); // @deprecated
                                    };

                                    /**
                                     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
                                     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
                                     * @method stop
                                     * @param {runner} runner
                                     */
                                    Runner.stop = function (runner) {
                                        _cancelAnimationFrame(
                                            runner.frameRequestId
                                        );
                                    };

                                    /**
                                     * Alias for `Runner.run`.
                                     * @method start
                                     * @param {runner} runner
                                     * @param {engine} engine
                                     */
                                    Runner.start = function (runner, engine) {
                                        Runner.run(runner, engine);
                                    };

                                    /*
                                     *
                                     *  Events Documentation
                                     *
                                     */

                                    /**
                                     * Fired at the start of a tick, before any updates to the engine or timing
                                     *
                                     * @event beforeTick
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after engine timing updated, but just before update
                                     *
                                     * @event tick
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired at the end of a tick, after engine update and after rendering
                                     *
                                     * @event afterTick
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired before update
                                     *
                                     * @event beforeUpdate
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after update
                                     *
                                     * @event afterUpdate
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired before rendering
                                     *
                                     * @event beforeRender
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after rendering
                                     *
                                     * @event afterRender
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * A flag that specifies whether the runner is running or not.
                                     *
                                     * @property enabled
                                     * @type boolean
                                     * @default true
                                     */

                                    /**
                                     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
                                     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
                                     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
                                     *
                                     * @property isFixed
                                     * @type boolean
                                     * @default false
                                     */

                                    /**
                                     * A `Number` that specifies the time step between updates in milliseconds.
                                     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
                                     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
                                     *
                                     * @property delta
                                     * @type number
                                     * @default 1000 / 60
                                     */
                                })();
                            },
                            { "./Common": 14, "./Engine": 15, "./Events": 16 },
                        ],
                        20: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
                                 *
                                 * @class Sleeping
                                 */

                                var Sleeping = {};

                                module.exports = Sleeping;

                                var Events = require("./Events");

                                (function () {
                                    Sleeping._motionWakeThreshold = 0.18;
                                    Sleeping._motionSleepThreshold = 0.08;
                                    Sleeping._minBias = 0.9;

                                    /**
                                     * Puts bodies to sleep or wakes them up depending on their motion.
                                     * @method update
                                     * @param {body[]} bodies
                                     * @param {number} timeScale
                                     */
                                    Sleeping.update = function (
                                        bodies,
                                        timeScale
                                    ) {
                                        var timeFactor =
                                            timeScale * timeScale * timeScale;

                                        // update bodies sleeping status
                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i],
                                                motion =
                                                    body.speed * body.speed +
                                                    body.angularSpeed *
                                                        body.angularSpeed;

                                            // wake up bodies if they have a force applied
                                            if (
                                                body.force.x !== 0 ||
                                                body.force.y !== 0
                                            ) {
                                                Sleeping.set(body, false);
                                                continue;
                                            }

                                            var minMotion = Math.min(
                                                    body.motion,
                                                    motion
                                                ),
                                                maxMotion = Math.max(
                                                    body.motion,
                                                    motion
                                                );

                                            // biased average motion estimation between frames
                                            body.motion =
                                                Sleeping._minBias * minMotion +
                                                (1 - Sleeping._minBias) *
                                                    maxMotion;

                                            if (
                                                body.sleepThreshold > 0 &&
                                                body.motion <
                                                    Sleeping._motionSleepThreshold *
                                                        timeFactor
                                            ) {
                                                body.sleepCounter += 1;

                                                if (
                                                    body.sleepCounter >=
                                                    body.sleepThreshold
                                                )
                                                    Sleeping.set(body, true);
                                            } else if (body.sleepCounter > 0) {
                                                body.sleepCounter -= 1;
                                            }
                                        }
                                    };

                                    /**
                                     * Given a set of colliding pairs, wakes the sleeping bodies involved.
                                     * @method afterCollisions
                                     * @param {pair[]} pairs
                                     * @param {number} timeScale
                                     */
                                    Sleeping.afterCollisions = function (
                                        pairs,
                                        timeScale
                                    ) {
                                        var timeFactor =
                                            timeScale * timeScale * timeScale;

                                        // wake up bodies involved in collisions
                                        for (var i = 0; i < pairs.length; i++) {
                                            var pair = pairs[i];

                                            // don't wake inactive pairs
                                            if (!pair.isActive) continue;

                                            var collision = pair.collision,
                                                bodyA = collision.bodyA.parent,
                                                bodyB = collision.bodyB.parent;

                                            // don't wake if at least one body is static
                                            if (
                                                (bodyA.isSleeping &&
                                                    bodyB.isSleeping) ||
                                                bodyA.isStatic ||
                                                bodyB.isStatic
                                            )
                                                continue;

                                            if (
                                                bodyA.isSleeping ||
                                                bodyB.isSleeping
                                            ) {
                                                var sleepingBody =
                                                        bodyA.isSleeping &&
                                                        !bodyA.isStatic
                                                            ? bodyA
                                                            : bodyB,
                                                    movingBody =
                                                        sleepingBody === bodyA
                                                            ? bodyB
                                                            : bodyA;

                                                if (
                                                    !sleepingBody.isStatic &&
                                                    movingBody.motion >
                                                        Sleeping._motionWakeThreshold *
                                                            timeFactor
                                                ) {
                                                    Sleeping.set(
                                                        sleepingBody,
                                                        false
                                                    );
                                                }
                                            }
                                        }
                                    };

                                    /**
                                     * Set a body as sleeping or awake.
                                     * @method set
                                     * @param {body} body
                                     * @param {boolean} isSleeping
                                     */
                                    Sleeping.set = function (body, isSleeping) {
                                        var wasSleeping = body.isSleeping;

                                        if (isSleeping) {
                                            body.isSleeping = true;
                                            body.sleepCounter =
                                                body.sleepThreshold;

                                            body.positionImpulse.x = 0;
                                            body.positionImpulse.y = 0;

                                            body.positionPrev.x =
                                                body.position.x;
                                            body.positionPrev.y =
                                                body.position.y;

                                            body.anglePrev = body.angle;
                                            body.speed = 0;
                                            body.angularSpeed = 0;
                                            body.motion = 0;

                                            if (!wasSleeping) {
                                                Events.trigger(
                                                    body,
                                                    "sleepStart"
                                                );
                                            }
                                        } else {
                                            body.isSleeping = false;
                                            body.sleepCounter = 0;

                                            if (wasSleeping) {
                                                Events.trigger(
                                                    body,
                                                    "sleepEnd"
                                                );
                                            }
                                        }
                                    };
                                })();
                            },
                            { "./Events": 16 },
                        ],
                        21: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Bodies` module contains factory methods for creating rigid body models
                                 * with commonly used body configurations (such as rectangles, circles and other polygons).
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Bodies
                                 */

                                // TODO: true circle bodies

                                var Bodies = {};

                                module.exports = Bodies;

                                var Vertices = require("../geometry/Vertices");
                                var Common = require("../core/Common");
                                var Body = require("../body/Body");
                                var Bounds = require("../geometry/Bounds");
                                var Vector = require("../geometry/Vector");

                                (function () {
                                    /**
                                     * Creates a new rigid body model with a rectangle hull.
                                     * The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
                                     * @method rectangle
                                     * @param {number} x
                                     * @param {number} y
                                     * @param {number} width
                                     * @param {number} height
                                     * @param {object} [options]
                                     * @return {body} A new rectangle body
                                     */
                                    Bodies.rectangle = function (
                                        x,
                                        y,
                                        width,
                                        height,
                                        options
                                    ) {
                                        options = options || {};

                                        var rectangle = {
                                            label: "Rectangle Body",
                                            position: { x: x, y: y },
                                            vertices: Vertices.fromPath(
                                                "L 0 0 L " +
                                                    width +
                                                    " 0 L " +
                                                    width +
                                                    " " +
                                                    height +
                                                    " L 0 " +
                                                    height
                                            ),
                                        };

                                        if (options.chamfer) {
                                            var chamfer = options.chamfer;
                                            rectangle.vertices =
                                                Vertices.chamfer(
                                                    rectangle.vertices,
                                                    chamfer.radius,
                                                    chamfer.quality,
                                                    chamfer.qualityMin,
                                                    chamfer.qualityMax
                                                );
                                            delete options.chamfer;
                                        }

                                        return Body.create(
                                            Common.extend(
                                                {},
                                                rectangle,
                                                options
                                            )
                                        );
                                    };

                                    /**
                                     * Creates a new rigid body model with a trapezoid hull.
                                     * The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
                                     * @method trapezoid
                                     * @param {number} x
                                     * @param {number} y
                                     * @param {number} width
                                     * @param {number} height
                                     * @param {number} slope
                                     * @param {object} [options]
                                     * @return {body} A new trapezoid body
                                     */
                                    Bodies.trapezoid = function (
                                        x,
                                        y,
                                        width,
                                        height,
                                        slope,
                                        options
                                    ) {
                                        options = options || {};

                                        slope *= 0.5;
                                        var roof = (1 - slope * 2) * width;

                                        var x1 = width * slope,
                                            x2 = x1 + roof,
                                            x3 = x2 + x1,
                                            verticesPath;

                                        if (slope < 0.5) {
                                            verticesPath =
                                                "L 0 0 L " +
                                                x1 +
                                                " " +
                                                -height +
                                                " L " +
                                                x2 +
                                                " " +
                                                -height +
                                                " L " +
                                                x3 +
                                                " 0";
                                        } else {
                                            verticesPath =
                                                "L 0 0 L " +
                                                x2 +
                                                " " +
                                                -height +
                                                " L " +
                                                x3 +
                                                " 0";
                                        }

                                        var trapezoid = {
                                            label: "Trapezoid Body",
                                            position: { x: x, y: y },
                                            vertices:
                                                Vertices.fromPath(verticesPath),
                                        };

                                        if (options.chamfer) {
                                            var chamfer = options.chamfer;
                                            trapezoid.vertices =
                                                Vertices.chamfer(
                                                    trapezoid.vertices,
                                                    chamfer.radius,
                                                    chamfer.quality,
                                                    chamfer.qualityMin,
                                                    chamfer.qualityMax
                                                );
                                            delete options.chamfer;
                                        }

                                        return Body.create(
                                            Common.extend(
                                                {},
                                                trapezoid,
                                                options
                                            )
                                        );
                                    };

                                    /**
                                     * Creates a new rigid body model with a circle hull.
                                     * The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
                                     * @method circle
                                     * @param {number} x
                                     * @param {number} y
                                     * @param {number} radius
                                     * @param {object} [options]
                                     * @param {number} [maxSides]
                                     * @return {body} A new circle body
                                     */
                                    Bodies.circle = function (
                                        x,
                                        y,
                                        radius,
                                        options,
                                        maxSides
                                    ) {
                                        options = options || {};

                                        var circle = {
                                            label: "Circle Body",
                                            circleRadius: radius,
                                        };

                                        // approximate circles with polygons until true circles implemented in SAT
                                        maxSides = maxSides || 25;
                                        var sides = Math.ceil(
                                            Math.max(
                                                10,
                                                Math.min(maxSides, radius)
                                            )
                                        );

                                        // optimisation: always use even number of sides (half the number of unique axes)
                                        if (sides % 2 === 1) sides += 1;

                                        return Bodies.polygon(
                                            x,
                                            y,
                                            sides,
                                            radius,
                                            Common.extend({}, circle, options)
                                        );
                                    };

                                    /**
                                     * Creates a new rigid body model with a regular polygon hull with the given number of sides.
                                     * The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
                                     * @method polygon
                                     * @param {number} x
                                     * @param {number} y
                                     * @param {number} sides
                                     * @param {number} radius
                                     * @param {object} [options]
                                     * @return {body} A new regular polygon body
                                     */
                                    Bodies.polygon = function (
                                        x,
                                        y,
                                        sides,
                                        radius,
                                        options
                                    ) {
                                        options = options || {};

                                        if (sides < 3)
                                            return Bodies.circle(
                                                x,
                                                y,
                                                radius,
                                                options
                                            );

                                        var theta = (2 * Math.PI) / sides,
                                            path = "",
                                            offset = theta * 0.5;

                                        for (var i = 0; i < sides; i += 1) {
                                            var angle = offset + i * theta,
                                                xx = Math.cos(angle) * radius,
                                                yy = Math.sin(angle) * radius;

                                            path +=
                                                "L " +
                                                xx.toFixed(3) +
                                                " " +
                                                yy.toFixed(3) +
                                                " ";
                                        }

                                        var polygon = {
                                            label: "Polygon Body",
                                            position: { x: x, y: y },
                                            vertices: Vertices.fromPath(path),
                                        };

                                        if (options.chamfer) {
                                            var chamfer = options.chamfer;
                                            polygon.vertices = Vertices.chamfer(
                                                polygon.vertices,
                                                chamfer.radius,
                                                chamfer.quality,
                                                chamfer.qualityMin,
                                                chamfer.qualityMax
                                            );
                                            delete options.chamfer;
                                        }

                                        return Body.create(
                                            Common.extend({}, polygon, options)
                                        );
                                    };

                                    /**
                                     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
                                     * If the vertices are convex, they will pass through as supplied.
                                     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
                                     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
                                     * By default the decomposition will discard collinear edges (to improve performance).
                                     * It can also optionally discard any parts that have an area less than `minimumArea`.
                                     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
                                     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
                                     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
                                     * @method fromVertices
                                     * @param {number} x
                                     * @param {number} y
                                     * @param [[vector]] vertexSets
                                     * @param {object} [options]
                                     * @param {bool} [flagInternal=false]
                                     * @param {number} [removeCollinear=0.01]
                                     * @param {number} [minimumArea=10]
                                     * @return {body}
                                     */
                                    Bodies.fromVertices = function (
                                        x,
                                        y,
                                        vertexSets,
                                        options,
                                        flagInternal,
                                        removeCollinear,
                                        minimumArea
                                    ) {
                                        var body,
                                            parts,
                                            isConvex,
                                            vertices,
                                            i,
                                            j,
                                            k,
                                            v,
                                            z;

                                        options = options || {};
                                        parts = [];

                                        flagInternal =
                                            typeof flagInternal !== "undefined"
                                                ? flagInternal
                                                : false;
                                        removeCollinear =
                                            typeof removeCollinear !==
                                            "undefined"
                                                ? removeCollinear
                                                : 0.01;
                                        minimumArea =
                                            typeof minimumArea !== "undefined"
                                                ? minimumArea
                                                : 10;

                                        if (!window.decomp) {
                                            Common.log(
                                                "Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.",
                                                "warn"
                                            );
                                        }

                                        // ensure vertexSets is an array of arrays
                                        if (!Common.isArray(vertexSets[0])) {
                                            vertexSets = [vertexSets];
                                        }

                                        for (
                                            v = 0;
                                            v < vertexSets.length;
                                            v += 1
                                        ) {
                                            vertices = vertexSets[v];
                                            isConvex =
                                                Vertices.isConvex(vertices);

                                            if (isConvex || !window.decomp) {
                                                if (isConvex) {
                                                    vertices =
                                                        Vertices.clockwiseSort(
                                                            vertices
                                                        );
                                                } else {
                                                    // fallback to convex hull when decomposition is not possible
                                                    vertices =
                                                        Vertices.hull(vertices);
                                                }

                                                parts.push({
                                                    position: { x: x, y: y },
                                                    vertices: vertices,
                                                });
                                            } else {
                                                // initialise a decomposition
                                                var concave =
                                                    new decomp.Polygon();
                                                for (
                                                    i = 0;
                                                    i < vertices.length;
                                                    i++
                                                ) {
                                                    concave.vertices.push([
                                                        vertices[i].x,
                                                        vertices[i].y,
                                                    ]);
                                                }

                                                // vertices are concave and simple, we can decompose into parts
                                                concave.makeCCW();
                                                if (removeCollinear !== false)
                                                    concave.removeCollinearPoints(
                                                        removeCollinear
                                                    );

                                                // use the quick decomposition algorithm (Bayazit)
                                                var decomposed =
                                                    concave.quickDecomp();

                                                // for each decomposed chunk
                                                for (
                                                    i = 0;
                                                    i < decomposed.length;
                                                    i++
                                                ) {
                                                    var chunk = decomposed[i],
                                                        chunkVertices = [];

                                                    // convert vertices into the correct structure
                                                    for (
                                                        j = 0;
                                                        j <
                                                        chunk.vertices.length;
                                                        j++
                                                    ) {
                                                        chunkVertices.push({
                                                            x: chunk.vertices[
                                                                j
                                                            ][0],
                                                            y: chunk.vertices[
                                                                j
                                                            ][1],
                                                        });
                                                    }

                                                    // skip small chunks
                                                    if (
                                                        minimumArea > 0 &&
                                                        Vertices.area(
                                                            chunkVertices
                                                        ) < minimumArea
                                                    )
                                                        continue;

                                                    // create a compound part
                                                    parts.push({
                                                        position:
                                                            Vertices.centre(
                                                                chunkVertices
                                                            ),
                                                        vertices: chunkVertices,
                                                    });
                                                }
                                            }
                                        }

                                        // create body parts
                                        for (i = 0; i < parts.length; i++) {
                                            parts[i] = Body.create(
                                                Common.extend(parts[i], options)
                                            );
                                        }

                                        // flag internal edges (coincident part edges)
                                        if (flagInternal) {
                                            var coincident_max_dist = 5;

                                            for (i = 0; i < parts.length; i++) {
                                                var partA = parts[i];

                                                for (
                                                    j = i + 1;
                                                    j < parts.length;
                                                    j++
                                                ) {
                                                    var partB = parts[j];

                                                    if (
                                                        Bounds.overlaps(
                                                            partA.bounds,
                                                            partB.bounds
                                                        )
                                                    ) {
                                                        var pav =
                                                                partA.vertices,
                                                            pbv =
                                                                partB.vertices;

                                                        // iterate vertices of both parts
                                                        for (
                                                            k = 0;
                                                            k <
                                                            partA.vertices
                                                                .length;
                                                            k++
                                                        ) {
                                                            for (
                                                                z = 0;
                                                                z <
                                                                partB.vertices
                                                                    .length;
                                                                z++
                                                            ) {
                                                                // find distances between the vertices
                                                                var da =
                                                                        Vector.magnitudeSquared(
                                                                            Vector.sub(
                                                                                pav[
                                                                                    (k +
                                                                                        1) %
                                                                                        pav.length
                                                                                ],
                                                                                pbv[
                                                                                    z
                                                                                ]
                                                                            )
                                                                        ),
                                                                    db =
                                                                        Vector.magnitudeSquared(
                                                                            Vector.sub(
                                                                                pav[
                                                                                    k
                                                                                ],
                                                                                pbv[
                                                                                    (z +
                                                                                        1) %
                                                                                        pbv.length
                                                                                ]
                                                                            )
                                                                        );

                                                                // if both vertices are very close, consider the edge concident (internal)
                                                                if (
                                                                    da <
                                                                        coincident_max_dist &&
                                                                    db <
                                                                        coincident_max_dist
                                                                ) {
                                                                    pav[
                                                                        k
                                                                    ].isInternal = true;
                                                                    pbv[
                                                                        z
                                                                    ].isInternal = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        if (parts.length > 1) {
                                            // create the parent body to be returned, that contains generated compound parts
                                            body = Body.create(
                                                Common.extend(
                                                    { parts: parts.slice(0) },
                                                    options
                                                )
                                            );
                                            Body.setPosition(body, {
                                                x: x,
                                                y: y,
                                            });

                                            return body;
                                        } else {
                                            return parts[0];
                                        }
                                    };
                                })();
                            },
                            {
                                "../body/Body": 1,
                                "../core/Common": 14,
                                "../geometry/Bounds": 24,
                                "../geometry/Vector": 26,
                                "../geometry/Vertices": 27,
                            },
                        ],
                        22: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Composites` module contains factory methods for creating composite bodies
                                 * with commonly used configurations (such as stacks and chains).
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Composites
                                 */

                                var Composites = {};

                                module.exports = Composites;

                                var Composite = require("../body/Composite");
                                var Constraint = require("../constraint/Constraint");
                                var Common = require("../core/Common");
                                var Body = require("../body/Body");
                                var Bodies = require("./Bodies");

                                (function () {
                                    /**
                                     * Create a new composite containing bodies created in the callback in a grid arrangement.
                                     * This function uses the body's bounds to prevent overlaps.
                                     * @method stack
                                     * @param {number} xx
                                     * @param {number} yy
                                     * @param {number} columns
                                     * @param {number} rows
                                     * @param {number} columnGap
                                     * @param {number} rowGap
                                     * @param {function} callback
                                     * @return {composite} A new composite containing objects created in the callback
                                     */
                                    Composites.stack = function (
                                        xx,
                                        yy,
                                        columns,
                                        rows,
                                        columnGap,
                                        rowGap,
                                        callback
                                    ) {
                                        var stack = Composite.create({
                                                label: "Stack",
                                            }),
                                            x = xx,
                                            y = yy,
                                            lastBody,
                                            i = 0;

                                        for (var row = 0; row < rows; row++) {
                                            var maxHeight = 0;

                                            for (
                                                var column = 0;
                                                column < columns;
                                                column++
                                            ) {
                                                var body = callback(
                                                    x,
                                                    y,
                                                    column,
                                                    row,
                                                    lastBody,
                                                    i
                                                );

                                                if (body) {
                                                    var bodyHeight =
                                                            body.bounds.max.y -
                                                            body.bounds.min.y,
                                                        bodyWidth =
                                                            body.bounds.max.x -
                                                            body.bounds.min.x;

                                                    if (bodyHeight > maxHeight)
                                                        maxHeight = bodyHeight;

                                                    Body.translate(body, {
                                                        x: bodyWidth * 0.5,
                                                        y: bodyHeight * 0.5,
                                                    });

                                                    x =
                                                        body.bounds.max.x +
                                                        columnGap;

                                                    Composite.addBody(
                                                        stack,
                                                        body
                                                    );

                                                    lastBody = body;
                                                    i += 1;
                                                } else {
                                                    x += columnGap;
                                                }
                                            }

                                            y += maxHeight + rowGap;
                                            x = xx;
                                        }

                                        return stack;
                                    };

                                    /**
                                     * Chains all bodies in the given composite together using constraints.
                                     * @method chain
                                     * @param {composite} composite
                                     * @param {number} xOffsetA
                                     * @param {number} yOffsetA
                                     * @param {number} xOffsetB
                                     * @param {number} yOffsetB
                                     * @param {object} options
                                     * @return {composite} A new composite containing objects chained together with constraints
                                     */
                                    Composites.chain = function (
                                        composite,
                                        xOffsetA,
                                        yOffsetA,
                                        xOffsetB,
                                        yOffsetB,
                                        options
                                    ) {
                                        var bodies = composite.bodies;

                                        for (
                                            var i = 1;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var bodyA = bodies[i - 1],
                                                bodyB = bodies[i],
                                                bodyAHeight =
                                                    bodyA.bounds.max.y -
                                                    bodyA.bounds.min.y,
                                                bodyAWidth =
                                                    bodyA.bounds.max.x -
                                                    bodyA.bounds.min.x,
                                                bodyBHeight =
                                                    bodyB.bounds.max.y -
                                                    bodyB.bounds.min.y,
                                                bodyBWidth =
                                                    bodyB.bounds.max.x -
                                                    bodyB.bounds.min.x;

                                            var defaults = {
                                                bodyA: bodyA,
                                                pointA: {
                                                    x: bodyAWidth * xOffsetA,
                                                    y: bodyAHeight * yOffsetA,
                                                },
                                                bodyB: bodyB,
                                                pointB: {
                                                    x: bodyBWidth * xOffsetB,
                                                    y: bodyBHeight * yOffsetB,
                                                },
                                            };

                                            var constraint = Common.extend(
                                                defaults,
                                                options
                                            );

                                            Composite.addConstraint(
                                                composite,
                                                Constraint.create(constraint)
                                            );
                                        }

                                        composite.label += " Chain";

                                        return composite;
                                    };

                                    /**
                                     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
                                     * @method mesh
                                     * @param {composite} composite
                                     * @param {number} columns
                                     * @param {number} rows
                                     * @param {boolean} crossBrace
                                     * @param {object} options
                                     * @return {composite} The composite containing objects meshed together with constraints
                                     */
                                    Composites.mesh = function (
                                        composite,
                                        columns,
                                        rows,
                                        crossBrace,
                                        options
                                    ) {
                                        var bodies = composite.bodies,
                                            row,
                                            col,
                                            bodyA,
                                            bodyB,
                                            bodyC;

                                        for (row = 0; row < rows; row++) {
                                            for (
                                                col = 1;
                                                col < columns;
                                                col++
                                            ) {
                                                bodyA =
                                                    bodies[
                                                        col - 1 + row * columns
                                                    ];
                                                bodyB =
                                                    bodies[col + row * columns];
                                                Composite.addConstraint(
                                                    composite,
                                                    Constraint.create(
                                                        Common.extend(
                                                            {
                                                                bodyA: bodyA,
                                                                bodyB: bodyB,
                                                            },
                                                            options
                                                        )
                                                    )
                                                );
                                            }

                                            if (row > 0) {
                                                for (
                                                    col = 0;
                                                    col < columns;
                                                    col++
                                                ) {
                                                    bodyA =
                                                        bodies[
                                                            col +
                                                                (row - 1) *
                                                                    columns
                                                        ];
                                                    bodyB =
                                                        bodies[
                                                            col + row * columns
                                                        ];
                                                    Composite.addConstraint(
                                                        composite,
                                                        Constraint.create(
                                                            Common.extend(
                                                                {
                                                                    bodyA: bodyA,
                                                                    bodyB: bodyB,
                                                                },
                                                                options
                                                            )
                                                        )
                                                    );

                                                    if (crossBrace && col > 0) {
                                                        bodyC =
                                                            bodies[
                                                                col -
                                                                    1 +
                                                                    (row - 1) *
                                                                        columns
                                                            ];
                                                        Composite.addConstraint(
                                                            composite,
                                                            Constraint.create(
                                                                Common.extend(
                                                                    {
                                                                        bodyA: bodyC,
                                                                        bodyB: bodyB,
                                                                    },
                                                                    options
                                                                )
                                                            )
                                                        );
                                                    }

                                                    if (
                                                        crossBrace &&
                                                        col < columns - 1
                                                    ) {
                                                        bodyC =
                                                            bodies[
                                                                col +
                                                                    1 +
                                                                    (row - 1) *
                                                                        columns
                                                            ];
                                                        Composite.addConstraint(
                                                            composite,
                                                            Constraint.create(
                                                                Common.extend(
                                                                    {
                                                                        bodyA: bodyC,
                                                                        bodyB: bodyB,
                                                                    },
                                                                    options
                                                                )
                                                            )
                                                        );
                                                    }
                                                }
                                            }
                                        }

                                        composite.label += " Mesh";

                                        return composite;
                                    };

                                    /**
                                     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
                                     * This function uses the body's bounds to prevent overlaps.
                                     * @method pyramid
                                     * @param {number} xx
                                     * @param {number} yy
                                     * @param {number} columns
                                     * @param {number} rows
                                     * @param {number} columnGap
                                     * @param {number} rowGap
                                     * @param {function} callback
                                     * @return {composite} A new composite containing objects created in the callback
                                     */
                                    Composites.pyramid = function (
                                        xx,
                                        yy,
                                        columns,
                                        rows,
                                        columnGap,
                                        rowGap,
                                        callback
                                    ) {
                                        return Composites.stack(
                                            xx,
                                            yy,
                                            columns,
                                            rows,
                                            columnGap,
                                            rowGap,
                                            function (
                                                x,
                                                y,
                                                column,
                                                row,
                                                lastBody,
                                                i
                                            ) {
                                                var actualRows = Math.min(
                                                        rows,
                                                        Math.ceil(columns / 2)
                                                    ),
                                                    lastBodyWidth = lastBody
                                                        ? lastBody.bounds.max
                                                              .x -
                                                          lastBody.bounds.min.x
                                                        : 0;

                                                if (row > actualRows) return;

                                                // reverse row order
                                                row = actualRows - row;

                                                var start = row,
                                                    end = columns - 1 - row;

                                                if (
                                                    column < start ||
                                                    column > end
                                                )
                                                    return;

                                                // retroactively fix the first body's position, since width was unknown
                                                if (i === 1) {
                                                    Body.translate(lastBody, {
                                                        x:
                                                            (column +
                                                                (columns % 2 ===
                                                                1
                                                                    ? 1
                                                                    : -1)) *
                                                            lastBodyWidth,
                                                        y: 0,
                                                    });
                                                }

                                                var xOffset = lastBody
                                                    ? column * lastBodyWidth
                                                    : 0;

                                                return callback(
                                                    xx +
                                                        xOffset +
                                                        column * columnGap,
                                                    y,
                                                    column,
                                                    row,
                                                    lastBody,
                                                    i
                                                );
                                            }
                                        );
                                    };

                                    /**
                                     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
                                     * @method newtonsCradle
                                     * @param {number} xx
                                     * @param {number} yy
                                     * @param {number} number
                                     * @param {number} size
                                     * @param {number} length
                                     * @return {composite} A new composite newtonsCradle body
                                     */
                                    Composites.newtonsCradle = function (
                                        xx,
                                        yy,
                                        number,
                                        size,
                                        length
                                    ) {
                                        var newtonsCradle = Composite.create({
                                            label: "Newtons Cradle",
                                        });

                                        for (var i = 0; i < number; i++) {
                                            var separation = 1.9,
                                                circle = Bodies.circle(
                                                    xx +
                                                        i * (size * separation),
                                                    yy + length,
                                                    size,
                                                    {
                                                        inertia: Infinity,
                                                        restitution: 1,
                                                        friction: 0,
                                                        frictionAir: 0.0001,
                                                        slop: 1,
                                                    }
                                                ),
                                                constraint = Constraint.create({
                                                    pointA: {
                                                        x:
                                                            xx +
                                                            i *
                                                                (size *
                                                                    separation),
                                                        y: yy,
                                                    },
                                                    bodyB: circle,
                                                });

                                            Composite.addBody(
                                                newtonsCradle,
                                                circle
                                            );
                                            Composite.addConstraint(
                                                newtonsCradle,
                                                constraint
                                            );
                                        }

                                        return newtonsCradle;
                                    };

                                    /**
                                     * Creates a composite with simple car setup of bodies and constraints.
                                     * @method car
                                     * @param {number} xx
                                     * @param {number} yy
                                     * @param {number} width
                                     * @param {number} height
                                     * @param {number} wheelSize
                                     * @return {composite} A new composite car body
                                     */
                                    Composites.car = function (
                                        xx,
                                        yy,
                                        width,
                                        height,
                                        wheelSize
                                    ) {
                                        var group = Body.nextGroup(true),
                                            wheelBase = -20,
                                            wheelAOffset =
                                                -width * 0.5 + wheelBase,
                                            wheelBOffset =
                                                width * 0.5 - wheelBase,
                                            wheelYOffset = 0;

                                        var car = Composite.create({
                                                label: "Car",
                                            }),
                                            body = Bodies.trapezoid(
                                                xx,
                                                yy,
                                                width,
                                                height,
                                                0.3,
                                                {
                                                    collisionFilter: {
                                                        group: group,
                                                    },
                                                    friction: 0.01,
                                                    chamfer: {
                                                        radius: 10,
                                                    },
                                                }
                                            );

                                        var wheelA = Bodies.circle(
                                            xx + wheelAOffset,
                                            yy + wheelYOffset,
                                            wheelSize,
                                            {
                                                collisionFilter: {
                                                    group: group,
                                                },
                                                friction: 0.8,
                                                density: 0.01,
                                            }
                                        );

                                        var wheelB = Bodies.circle(
                                            xx + wheelBOffset,
                                            yy + wheelYOffset,
                                            wheelSize,
                                            {
                                                collisionFilter: {
                                                    group: group,
                                                },
                                                friction: 0.8,
                                                density: 0.01,
                                            }
                                        );

                                        var axelA = Constraint.create({
                                            bodyA: body,
                                            pointA: {
                                                x: wheelAOffset,
                                                y: wheelYOffset,
                                            },
                                            bodyB: wheelA,
                                            stiffness: 0.2,
                                        });

                                        var axelB = Constraint.create({
                                            bodyA: body,
                                            pointA: {
                                                x: wheelBOffset,
                                                y: wheelYOffset,
                                            },
                                            bodyB: wheelB,
                                            stiffness: 0.2,
                                        });

                                        Composite.addBody(car, body);
                                        Composite.addBody(car, wheelA);
                                        Composite.addBody(car, wheelB);
                                        Composite.addConstraint(car, axelA);
                                        Composite.addConstraint(car, axelB);

                                        return car;
                                    };

                                    /**
                                     * Creates a simple soft body like object.
                                     * @method softBody
                                     * @param {number} xx
                                     * @param {number} yy
                                     * @param {number} columns
                                     * @param {number} rows
                                     * @param {number} columnGap
                                     * @param {number} rowGap
                                     * @param {boolean} crossBrace
                                     * @param {number} particleRadius
                                     * @param {} particleOptions
                                     * @param {} constraintOptions
                                     * @return {composite} A new composite softBody
                                     */
                                    Composites.softBody = function (
                                        xx,
                                        yy,
                                        columns,
                                        rows,
                                        columnGap,
                                        rowGap,
                                        crossBrace,
                                        particleRadius,
                                        particleOptions,
                                        constraintOptions
                                    ) {
                                        particleOptions = Common.extend(
                                            { inertia: Infinity },
                                            particleOptions
                                        );
                                        constraintOptions = Common.extend(
                                            { stiffness: 0.4 },
                                            constraintOptions
                                        );

                                        var softBody = Composites.stack(
                                            xx,
                                            yy,
                                            columns,
                                            rows,
                                            columnGap,
                                            rowGap,
                                            function (x, y) {
                                                return Bodies.circle(
                                                    x,
                                                    y,
                                                    particleRadius,
                                                    particleOptions
                                                );
                                            }
                                        );

                                        Composites.mesh(
                                            softBody,
                                            columns,
                                            rows,
                                            crossBrace,
                                            constraintOptions
                                        );

                                        softBody.label = "Soft Body";

                                        return softBody;
                                    };
                                })();
                            },
                            {
                                "../body/Body": 1,
                                "../body/Composite": 2,
                                "../constraint/Constraint": 12,
                                "../core/Common": 14,
                                "./Bodies": 21,
                            },
                        ],
                        23: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
                                 *
                                 * @class Axes
                                 */

                                var Axes = {};

                                module.exports = Axes;

                                var Vector = require("../geometry/Vector");
                                var Common = require("../core/Common");

                                (function () {
                                    /**
                                     * Creates a new set of axes from the given vertices.
                                     * @method fromVertices
                                     * @param {vertices} vertices
                                     * @return {axes} A new axes from the given vertices
                                     */
                                    Axes.fromVertices = function (vertices) {
                                        var axes = {};

                                        // find the unique axes, using edge normal gradients
                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            var j = (i + 1) % vertices.length,
                                                normal = Vector.normalise({
                                                    x:
                                                        vertices[j].y -
                                                        vertices[i].y,
                                                    y:
                                                        vertices[i].x -
                                                        vertices[j].x,
                                                }),
                                                gradient =
                                                    normal.y === 0
                                                        ? Infinity
                                                        : normal.x / normal.y;

                                            // limit precision
                                            gradient = gradient
                                                .toFixed(3)
                                                .toString();
                                            axes[gradient] = normal;
                                        }

                                        return Common.values(axes);
                                    };

                                    /**
                                     * Rotates a set of axes by the given angle.
                                     * @method rotate
                                     * @param {axes} axes
                                     * @param {number} angle
                                     */
                                    Axes.rotate = function (axes, angle) {
                                        if (angle === 0) return;

                                        var cos = Math.cos(angle),
                                            sin = Math.sin(angle);

                                        for (var i = 0; i < axes.length; i++) {
                                            var axis = axes[i],
                                                xx;
                                            xx = axis.x * cos - axis.y * sin;
                                            axis.y =
                                                axis.x * sin + axis.y * cos;
                                            axis.x = xx;
                                        }
                                    };
                                })();
                            },
                            { "../core/Common": 14, "../geometry/Vector": 26 },
                        ],
                        24: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
                                 *
                                 * @class Bounds
                                 */

                                var Bounds = {};

                                module.exports = Bounds;

                                (function () {
                                    /**
                                     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
                                     * @method create
                                     * @param {vertices} vertices
                                     * @return {bounds} A new bounds object
                                     */
                                    Bounds.create = function (vertices) {
                                        var bounds = {
                                            min: { x: 0, y: 0 },
                                            max: { x: 0, y: 0 },
                                        };

                                        if (vertices)
                                            Bounds.update(bounds, vertices);

                                        return bounds;
                                    };

                                    /**
                                     * Updates bounds using the given vertices and extends the bounds given a velocity.
                                     * @method update
                                     * @param {bounds} bounds
                                     * @param {vertices} vertices
                                     * @param {vector} velocity
                                     */
                                    Bounds.update = function (
                                        bounds,
                                        vertices,
                                        velocity
                                    ) {
                                        bounds.min.x = Infinity;
                                        bounds.max.x = -Infinity;
                                        bounds.min.y = Infinity;
                                        bounds.max.y = -Infinity;

                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            var vertex = vertices[i];
                                            if (vertex.x > bounds.max.x)
                                                bounds.max.x = vertex.x;
                                            if (vertex.x < bounds.min.x)
                                                bounds.min.x = vertex.x;
                                            if (vertex.y > bounds.max.y)
                                                bounds.max.y = vertex.y;
                                            if (vertex.y < bounds.min.y)
                                                bounds.min.y = vertex.y;
                                        }

                                        if (velocity) {
                                            if (velocity.x > 0) {
                                                bounds.max.x += velocity.x;
                                            } else {
                                                bounds.min.x += velocity.x;
                                            }

                                            if (velocity.y > 0) {
                                                bounds.max.y += velocity.y;
                                            } else {
                                                bounds.min.y += velocity.y;
                                            }
                                        }
                                    };

                                    /**
                                     * Returns true if the bounds contains the given point.
                                     * @method contains
                                     * @param {bounds} bounds
                                     * @param {vector} point
                                     * @return {boolean} True if the bounds contain the point, otherwise false
                                     */
                                    Bounds.contains = function (bounds, point) {
                                        return (
                                            point.x >= bounds.min.x &&
                                            point.x <= bounds.max.x &&
                                            point.y >= bounds.min.y &&
                                            point.y <= bounds.max.y
                                        );
                                    };

                                    /**
                                     * Returns true if the two bounds intersect.
                                     * @method overlaps
                                     * @param {bounds} boundsA
                                     * @param {bounds} boundsB
                                     * @return {boolean} True if the bounds overlap, otherwise false
                                     */
                                    Bounds.overlaps = function (
                                        boundsA,
                                        boundsB
                                    ) {
                                        return (
                                            boundsA.min.x <= boundsB.max.x &&
                                            boundsA.max.x >= boundsB.min.x &&
                                            boundsA.max.y >= boundsB.min.y &&
                                            boundsA.min.y <= boundsB.max.y
                                        );
                                    };

                                    /**
                                     * Translates the bounds by the given vector.
                                     * @method translate
                                     * @param {bounds} bounds
                                     * @param {vector} vector
                                     */
                                    Bounds.translate = function (
                                        bounds,
                                        vector
                                    ) {
                                        bounds.min.x += vector.x;
                                        bounds.max.x += vector.x;
                                        bounds.min.y += vector.y;
                                        bounds.max.y += vector.y;
                                    };

                                    /**
                                     * Shifts the bounds to the given position.
                                     * @method shift
                                     * @param {bounds} bounds
                                     * @param {vector} position
                                     */
                                    Bounds.shift = function (bounds, position) {
                                        var deltaX =
                                                bounds.max.x - bounds.min.x,
                                            deltaY =
                                                bounds.max.y - bounds.min.y;

                                        bounds.min.x = position.x;
                                        bounds.max.x = position.x + deltaX;
                                        bounds.min.y = position.y;
                                        bounds.max.y = position.y + deltaY;
                                    };
                                })();
                            },
                            {},
                        ],
                        25: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
                                 *
                                 * To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Svg
                                 */

                                var Svg = {};

                                module.exports = Svg;

                                var Bounds = require("../geometry/Bounds");

                                (function () {
                                    /**
                                     * Converts an SVG path into an array of vector points.
                                     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
                                     * See `Bodies.fromVertices` which provides support for this.
                                     * Note that this function is not guaranteed to support complex paths (such as those with holes).
                                     * @method pathToVertices
                                     * @param {SVGPathElement} path
                                     * @param {Number} [sampleLength=15]
                                     * @return {Vector[]} points
                                     */
                                    Svg.pathToVertices = function (
                                        path,
                                        sampleLength
                                    ) {
                                        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
                                        var i,
                                            il,
                                            total,
                                            point,
                                            segment,
                                            segments,
                                            segmentsQueue,
                                            lastSegment,
                                            lastPoint,
                                            segmentIndex,
                                            points = [],
                                            lx,
                                            ly,
                                            length = 0,
                                            x = 0,
                                            y = 0;

                                        sampleLength = sampleLength || 15;

                                        var addPoint = function (
                                            px,
                                            py,
                                            pathSegType
                                        ) {
                                            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
                                            var isRelative =
                                                pathSegType % 2 === 1 &&
                                                pathSegType > 1;

                                            // when the last point doesn't equal the current point add the current point
                                            if (
                                                !lastPoint ||
                                                px != lastPoint.x ||
                                                py != lastPoint.y
                                            ) {
                                                if (lastPoint && isRelative) {
                                                    lx = lastPoint.x;
                                                    ly = lastPoint.y;
                                                } else {
                                                    lx = 0;
                                                    ly = 0;
                                                }

                                                var point = {
                                                    x: lx + px,
                                                    y: ly + py,
                                                };

                                                // set last point
                                                if (isRelative || !lastPoint) {
                                                    lastPoint = point;
                                                }

                                                points.push(point);

                                                x = lx + px;
                                                y = ly + py;
                                            }
                                        };

                                        var addSegmentPoint = function (
                                            segment
                                        ) {
                                            var segType =
                                                segment.pathSegTypeAsLetter.toUpperCase();

                                            // skip path ends
                                            if (segType === "Z") return;

                                            // map segment to x and y
                                            switch (segType) {
                                                case "M":
                                                case "L":
                                                case "T":
                                                case "C":
                                                case "S":
                                                case "Q":
                                                    x = segment.x;
                                                    y = segment.y;
                                                    break;
                                                case "H":
                                                    x = segment.x;
                                                    break;
                                                case "V":
                                                    y = segment.y;
                                                    break;
                                            }

                                            addPoint(x, y, segment.pathSegType);
                                        };

                                        // ensure path is absolute
                                        _svgPathToAbsolute(path);

                                        // get total length
                                        total = path.getTotalLength();

                                        // queue segments
                                        segments = [];
                                        for (
                                            i = 0;
                                            i < path.pathSegList.numberOfItems;
                                            i += 1
                                        )
                                            segments.push(
                                                path.pathSegList.getItem(i)
                                            );

                                        segmentsQueue = segments.concat();

                                        // sample through path
                                        while (length < total) {
                                            // get segment at position
                                            segmentIndex =
                                                path.getPathSegAtLength(length);
                                            segment = segments[segmentIndex];

                                            // new segment
                                            if (segment != lastSegment) {
                                                while (
                                                    segmentsQueue.length &&
                                                    segmentsQueue[0] != segment
                                                )
                                                    addSegmentPoint(
                                                        segmentsQueue.shift()
                                                    );

                                                lastSegment = segment;
                                            }

                                            // add points in between when curving
                                            // TODO: adaptive sampling
                                            switch (
                                                segment.pathSegTypeAsLetter.toUpperCase()
                                            ) {
                                                case "C":
                                                case "T":
                                                case "S":
                                                case "Q":
                                                case "A":
                                                    point =
                                                        path.getPointAtLength(
                                                            length
                                                        );
                                                    addPoint(
                                                        point.x,
                                                        point.y,
                                                        0
                                                    );
                                                    break;
                                            }

                                            // increment by sample value
                                            length += sampleLength;
                                        }

                                        // add remaining segments not passed by sampling
                                        for (
                                            i = 0, il = segmentsQueue.length;
                                            i < il;
                                            ++i
                                        )
                                            addSegmentPoint(segmentsQueue[i]);

                                        return points;
                                    };

                                    var _svgPathToAbsolute = function (path) {
                                        // http://phrogz.net/convert-svg-path-to-all-absolute-commands
                                        var x0,
                                            y0,
                                            x1,
                                            y1,
                                            x2,
                                            y2,
                                            segs = path.pathSegList,
                                            x = 0,
                                            y = 0,
                                            len = segs.numberOfItems;

                                        for (var i = 0; i < len; ++i) {
                                            var seg = segs.getItem(i),
                                                segType =
                                                    seg.pathSegTypeAsLetter;

                                            if (/[MLHVCSQTA]/.test(segType)) {
                                                if ("x" in seg) x = seg.x;
                                                if ("y" in seg) y = seg.y;
                                            } else {
                                                if ("x1" in seg)
                                                    x1 = x + seg.x1;
                                                if ("x2" in seg)
                                                    x2 = x + seg.x2;
                                                if ("y1" in seg)
                                                    y1 = y + seg.y1;
                                                if ("y2" in seg)
                                                    y2 = y + seg.y2;
                                                if ("x" in seg) x += seg.x;
                                                if ("y" in seg) y += seg.y;

                                                switch (segType) {
                                                    case "m":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegMovetoAbs(
                                                                x,
                                                                y
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "l":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegLinetoAbs(
                                                                x,
                                                                y
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "h":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegLinetoHorizontalAbs(
                                                                x
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "v":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegLinetoVerticalAbs(
                                                                y
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "c":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegCurvetoCubicAbs(
                                                                x,
                                                                y,
                                                                x1,
                                                                y1,
                                                                x2,
                                                                y2
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "s":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegCurvetoCubicSmoothAbs(
                                                                x,
                                                                y,
                                                                x2,
                                                                y2
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "q":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegCurvetoQuadraticAbs(
                                                                x,
                                                                y,
                                                                x1,
                                                                y1
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "t":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegCurvetoQuadraticSmoothAbs(
                                                                x,
                                                                y
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "a":
                                                        segs.replaceItem(
                                                            path.createSVGPathSegArcAbs(
                                                                x,
                                                                y,
                                                                seg.r1,
                                                                seg.r2,
                                                                seg.angle,
                                                                seg.largeArcFlag,
                                                                seg.sweepFlag
                                                            ),
                                                            i
                                                        );
                                                        break;
                                                    case "z":
                                                    case "Z":
                                                        x = x0;
                                                        y = y0;
                                                        break;
                                                }
                                            }

                                            if (
                                                segType == "M" ||
                                                segType == "m"
                                            ) {
                                                x0 = x;
                                                y0 = y;
                                            }
                                        }
                                    };
                                })();
                            },
                            { "../geometry/Bounds": 24 },
                        ],
                        26: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Vector` module contains methods for creating and manipulating vectors.
                                 * Vectors are the basis of all the geometry related operations in the engine.
                                 * A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Vector
                                 */

                                // TODO: consider params for reusing vector objects

                                var Vector = {};

                                module.exports = Vector;

                                (function () {
                                    /**
                                     * Creates a new vector.
                                     * @method create
                                     * @param {number} x
                                     * @param {number} y
                                     * @return {vector} A new vector
                                     */
                                    Vector.create = function (x, y) {
                                        return { x: x || 0, y: y || 0 };
                                    };

                                    /**
                                     * Returns a new vector with `x` and `y` copied from the given `vector`.
                                     * @method clone
                                     * @param {vector} vector
                                     * @return {vector} A new cloned vector
                                     */
                                    Vector.clone = function (vector) {
                                        return { x: vector.x, y: vector.y };
                                    };

                                    /**
                                     * Returns the magnitude (length) of a vector.
                                     * @method magnitude
                                     * @param {vector} vector
                                     * @return {number} The magnitude of the vector
                                     */
                                    Vector.magnitude = function (vector) {
                                        return Math.sqrt(
                                            vector.x * vector.x +
                                                vector.y * vector.y
                                        );
                                    };

                                    /**
                                     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
                                     * @method magnitudeSquared
                                     * @param {vector} vector
                                     * @return {number} The squared magnitude of the vector
                                     */
                                    Vector.magnitudeSquared = function (
                                        vector
                                    ) {
                                        return (
                                            vector.x * vector.x +
                                            vector.y * vector.y
                                        );
                                    };

                                    /**
                                     * Rotates the vector about (0, 0) by specified angle.
                                     * @method rotate
                                     * @param {vector} vector
                                     * @param {number} angle
                                     * @return {vector} A new vector rotated about (0, 0)
                                     */
                                    Vector.rotate = function (vector, angle) {
                                        var cos = Math.cos(angle),
                                            sin = Math.sin(angle);
                                        return {
                                            x: vector.x * cos - vector.y * sin,
                                            y: vector.x * sin + vector.y * cos,
                                        };
                                    };

                                    /**
                                     * Rotates the vector about a specified point by specified angle.
                                     * @method rotateAbout
                                     * @param {vector} vector
                                     * @param {number} angle
                                     * @param {vector} point
                                     * @param {vector} [output]
                                     * @return {vector} A new vector rotated about the point
                                     */
                                    Vector.rotateAbout = function (
                                        vector,
                                        angle,
                                        point,
                                        output
                                    ) {
                                        var cos = Math.cos(angle),
                                            sin = Math.sin(angle);
                                        if (!output) output = {};
                                        var x =
                                            point.x +
                                            ((vector.x - point.x) * cos -
                                                (vector.y - point.y) * sin);
                                        output.y =
                                            point.y +
                                            ((vector.x - point.x) * sin +
                                                (vector.y - point.y) * cos);
                                        output.x = x;
                                        return output;
                                    };

                                    /**
                                     * Normalises a vector (such that its magnitude is `1`).
                                     * @method normalise
                                     * @param {vector} vector
                                     * @return {vector} A new vector normalised
                                     */
                                    Vector.normalise = function (vector) {
                                        var magnitude =
                                            Vector.magnitude(vector);
                                        if (magnitude === 0)
                                            return { x: 0, y: 0 };
                                        return {
                                            x: vector.x / magnitude,
                                            y: vector.y / magnitude,
                                        };
                                    };

                                    /**
                                     * Returns the dot-product of two vectors.
                                     * @method dot
                                     * @param {vector} vectorA
                                     * @param {vector} vectorB
                                     * @return {number} The dot product of the two vectors
                                     */
                                    Vector.dot = function (vectorA, vectorB) {
                                        return (
                                            vectorA.x * vectorB.x +
                                            vectorA.y * vectorB.y
                                        );
                                    };

                                    /**
                                     * Returns the cross-product of two vectors.
                                     * @method cross
                                     * @param {vector} vectorA
                                     * @param {vector} vectorB
                                     * @return {number} The cross product of the two vectors
                                     */
                                    Vector.cross = function (vectorA, vectorB) {
                                        return (
                                            vectorA.x * vectorB.y -
                                            vectorA.y * vectorB.x
                                        );
                                    };

                                    /**
                                     * Returns the cross-product of three vectors.
                                     * @method cross3
                                     * @param {vector} vectorA
                                     * @param {vector} vectorB
                                     * @param {vector} vectorC
                                     * @return {number} The cross product of the three vectors
                                     */
                                    Vector.cross3 = function (
                                        vectorA,
                                        vectorB,
                                        vectorC
                                    ) {
                                        return (
                                            (vectorB.x - vectorA.x) *
                                                (vectorC.y - vectorA.y) -
                                            (vectorB.y - vectorA.y) *
                                                (vectorC.x - vectorA.x)
                                        );
                                    };

                                    /**
                                     * Adds the two vectors.
                                     * @method add
                                     * @param {vector} vectorA
                                     * @param {vector} vectorB
                                     * @param {vector} [output]
                                     * @return {vector} A new vector of vectorA and vectorB added
                                     */
                                    Vector.add = function (
                                        vectorA,
                                        vectorB,
                                        output
                                    ) {
                                        if (!output) output = {};
                                        output.x = vectorA.x + vectorB.x;
                                        output.y = vectorA.y + vectorB.y;
                                        return output;
                                    };

                                    /**
                                     * Subtracts the two vectors.
                                     * @method sub
                                     * @param {vector} vectorA
                                     * @param {vector} vectorB
                                     * @param {vector} [output]
                                     * @return {vector} A new vector of vectorA and vectorB subtracted
                                     */
                                    Vector.sub = function (
                                        vectorA,
                                        vectorB,
                                        output
                                    ) {
                                        if (!output) output = {};
                                        output.x = vectorA.x - vectorB.x;
                                        output.y = vectorA.y - vectorB.y;
                                        return output;
                                    };

                                    /**
                                     * Multiplies a vector and a scalar.
                                     * @method mult
                                     * @param {vector} vector
                                     * @param {number} scalar
                                     * @return {vector} A new vector multiplied by scalar
                                     */
                                    Vector.mult = function (vector, scalar) {
                                        return {
                                            x: vector.x * scalar,
                                            y: vector.y * scalar,
                                        };
                                    };

                                    /**
                                     * Divides a vector and a scalar.
                                     * @method div
                                     * @param {vector} vector
                                     * @param {number} scalar
                                     * @return {vector} A new vector divided by scalar
                                     */
                                    Vector.div = function (vector, scalar) {
                                        return {
                                            x: vector.x / scalar,
                                            y: vector.y / scalar,
                                        };
                                    };

                                    /**
                                     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
                                     * @method perp
                                     * @param {vector} vector
                                     * @param {bool} [negate=false]
                                     * @return {vector} The perpendicular vector
                                     */
                                    Vector.perp = function (vector, negate) {
                                        negate = negate === true ? -1 : 1;
                                        return {
                                            x: negate * -vector.y,
                                            y: negate * vector.x,
                                        };
                                    };

                                    /**
                                     * Negates both components of a vector such that it points in the opposite direction.
                                     * @method neg
                                     * @param {vector} vector
                                     * @return {vector} The negated vector
                                     */
                                    Vector.neg = function (vector) {
                                        return { x: -vector.x, y: -vector.y };
                                    };

                                    /**
                                     * Returns the angle in radians between the two vectors relative to the x-axis.
                                     * @method angle
                                     * @param {vector} vectorA
                                     * @param {vector} vectorB
                                     * @return {number} The angle in radians
                                     */
                                    Vector.angle = function (vectorA, vectorB) {
                                        return Math.atan2(
                                            vectorB.y - vectorA.y,
                                            vectorB.x - vectorA.x
                                        );
                                    };

                                    /**
                                     * Temporary vector pool (not thread-safe).
                                     * @property _temp
                                     * @type {vector[]}
                                     * @private
                                     */
                                    Vector._temp = [
                                        Vector.create(),
                                        Vector.create(),
                                        Vector.create(),
                                        Vector.create(),
                                        Vector.create(),
                                        Vector.create(),
                                    ];
                                })();
                            },
                            {},
                        ],
                        27: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
                                 * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
                                 * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
                                 *
                                 * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
                                 *
                                 * @class Vertices
                                 */

                                var Vertices = {};

                                module.exports = Vertices;

                                var Vector = require("../geometry/Vector");
                                var Common = require("../core/Common");

                                (function () {
                                    /**
                                     * Creates a new set of `Matter.Body` compatible vertices.
                                     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
                                     *
                                     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
                                     *
                                     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
                                     * but with some additional references required for efficient collision detection routines.
                                     *
                                     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
                                     *
                                     * @method create
                                     * @param {vector[]} points
                                     * @param {body} body
                                     */
                                    Vertices.create = function (points, body) {
                                        var vertices = [];

                                        for (
                                            var i = 0;
                                            i < points.length;
                                            i++
                                        ) {
                                            var point = points[i],
                                                vertex = {
                                                    x: point.x,
                                                    y: point.y,
                                                    index: i,
                                                    body: body,
                                                    isInternal: false,
                                                };

                                            vertices.push(vertex);
                                        }

                                        return vertices;
                                    };

                                    /**
                                     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas),
                                     * into a `Matter.Vertices` object for the given `Matter.Body`.
                                     * For parsing SVG paths, see `Svg.pathToVertices`.
                                     * @method fromPath
                                     * @param {string} path
                                     * @param {body} body
                                     * @return {vertices} vertices
                                     */
                                    Vertices.fromPath = function (path, body) {
                                        var pathPattern =
                                                /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/gi,
                                            points = [];

                                        path.replace(
                                            pathPattern,
                                            function (match, x, y) {
                                                points.push({
                                                    x: parseFloat(x),
                                                    y: parseFloat(y),
                                                });
                                            }
                                        );

                                        return Vertices.create(points, body);
                                    };

                                    /**
                                     * Returns the centre (centroid) of the set of vertices.
                                     * @method centre
                                     * @param {vertices} vertices
                                     * @return {vector} The centre point
                                     */
                                    Vertices.centre = function (vertices) {
                                        var area = Vertices.area(
                                                vertices,
                                                true
                                            ),
                                            centre = { x: 0, y: 0 },
                                            cross,
                                            temp,
                                            j;

                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            j = (i + 1) % vertices.length;
                                            cross = Vector.cross(
                                                vertices[i],
                                                vertices[j]
                                            );
                                            temp = Vector.mult(
                                                Vector.add(
                                                    vertices[i],
                                                    vertices[j]
                                                ),
                                                cross
                                            );
                                            centre = Vector.add(centre, temp);
                                        }

                                        return Vector.div(centre, 6 * area);
                                    };

                                    /**
                                     * Returns the average (mean) of the set of vertices.
                                     * @method mean
                                     * @param {vertices} vertices
                                     * @return {vector} The average point
                                     */
                                    Vertices.mean = function (vertices) {
                                        var average = { x: 0, y: 0 };

                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            average.x += vertices[i].x;
                                            average.y += vertices[i].y;
                                        }

                                        return Vector.div(
                                            average,
                                            vertices.length
                                        );
                                    };

                                    /**
                                     * Returns the area of the set of vertices.
                                     * @method area
                                     * @param {vertices} vertices
                                     * @param {bool} signed
                                     * @return {number} The area
                                     */
                                    Vertices.area = function (
                                        vertices,
                                        signed
                                    ) {
                                        var area = 0,
                                            j = vertices.length - 1;

                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            area +=
                                                (vertices[j].x -
                                                    vertices[i].x) *
                                                (vertices[j].y + vertices[i].y);
                                            j = i;
                                        }

                                        if (signed) return area / 2;

                                        return Math.abs(area) / 2;
                                    };

                                    /**
                                     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
                                     * @method inertia
                                     * @param {vertices} vertices
                                     * @param {number} mass
                                     * @return {number} The polygon's moment of inertia
                                     */
                                    Vertices.inertia = function (
                                        vertices,
                                        mass
                                    ) {
                                        var numerator = 0,
                                            denominator = 0,
                                            v = vertices,
                                            cross,
                                            j;

                                        // find the polygon's moment of inertia, using second moment of area
                                        // http://www.physicsforums.com/showthread.php?t=25293
                                        for (var n = 0; n < v.length; n++) {
                                            j = (n + 1) % v.length;
                                            cross = Math.abs(
                                                Vector.cross(v[j], v[n])
                                            );
                                            numerator +=
                                                cross *
                                                (Vector.dot(v[j], v[j]) +
                                                    Vector.dot(v[j], v[n]) +
                                                    Vector.dot(v[n], v[n]));
                                            denominator += cross;
                                        }

                                        return (
                                            (mass / 6) *
                                            (numerator / denominator)
                                        );
                                    };

                                    /**
                                     * Translates the set of vertices in-place.
                                     * @method translate
                                     * @param {vertices} vertices
                                     * @param {vector} vector
                                     * @param {number} scalar
                                     */
                                    Vertices.translate = function (
                                        vertices,
                                        vector,
                                        scalar
                                    ) {
                                        var i;
                                        if (scalar) {
                                            for (
                                                i = 0;
                                                i < vertices.length;
                                                i++
                                            ) {
                                                vertices[i].x +=
                                                    vector.x * scalar;
                                                vertices[i].y +=
                                                    vector.y * scalar;
                                            }
                                        } else {
                                            for (
                                                i = 0;
                                                i < vertices.length;
                                                i++
                                            ) {
                                                vertices[i].x += vector.x;
                                                vertices[i].y += vector.y;
                                            }
                                        }

                                        return vertices;
                                    };

                                    /**
                                     * Rotates the set of vertices in-place.
                                     * @method rotate
                                     * @param {vertices} vertices
                                     * @param {number} angle
                                     * @param {vector} point
                                     */
                                    Vertices.rotate = function (
                                        vertices,
                                        angle,
                                        point
                                    ) {
                                        if (angle === 0) return;

                                        var cos = Math.cos(angle),
                                            sin = Math.sin(angle);

                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            var vertice = vertices[i],
                                                dx = vertice.x - point.x,
                                                dy = vertice.y - point.y;

                                            vertice.x =
                                                point.x + (dx * cos - dy * sin);
                                            vertice.y =
                                                point.y + (dx * sin + dy * cos);
                                        }

                                        return vertices;
                                    };

                                    /**
                                     * Returns `true` if the `point` is inside the set of `vertices`.
                                     * @method contains
                                     * @param {vertices} vertices
                                     * @param {vector} point
                                     * @return {boolean} True if the vertices contains point, otherwise false
                                     */
                                    Vertices.contains = function (
                                        vertices,
                                        point
                                    ) {
                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            var vertice = vertices[i],
                                                nextVertice =
                                                    vertices[
                                                        (i + 1) %
                                                            vertices.length
                                                    ];
                                            if (
                                                (point.x - vertice.x) *
                                                    (nextVertice.y -
                                                        vertice.y) +
                                                    (point.y - vertice.y) *
                                                        (vertice.x -
                                                            nextVertice.x) >
                                                0
                                            ) {
                                                return false;
                                            }
                                        }

                                        return true;
                                    };

                                    /**
                                     * Scales the vertices from a point (default is centre) in-place.
                                     * @method scale
                                     * @param {vertices} vertices
                                     * @param {number} scaleX
                                     * @param {number} scaleY
                                     * @param {vector} point
                                     */
                                    Vertices.scale = function (
                                        vertices,
                                        scaleX,
                                        scaleY,
                                        point
                                    ) {
                                        if (scaleX === 1 && scaleY === 1)
                                            return vertices;

                                        point =
                                            point || Vertices.centre(vertices);

                                        var vertex, delta;

                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            vertex = vertices[i];
                                            delta = Vector.sub(vertex, point);
                                            vertices[i].x =
                                                point.x + delta.x * scaleX;
                                            vertices[i].y =
                                                point.y + delta.y * scaleY;
                                        }

                                        return vertices;
                                    };

                                    /**
                                     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
                                     * The radius parameter is a single number or an array to specify the radius for each vertex.
                                     * @method chamfer
                                     * @param {vertices} vertices
                                     * @param {number[]} radius
                                     * @param {number} quality
                                     * @param {number} qualityMin
                                     * @param {number} qualityMax
                                     */
                                    Vertices.chamfer = function (
                                        vertices,
                                        radius,
                                        quality,
                                        qualityMin,
                                        qualityMax
                                    ) {
                                        radius = radius || [8];

                                        if (!radius.length) radius = [radius];

                                        // quality defaults to -1, which is auto
                                        quality =
                                            typeof quality !== "undefined"
                                                ? quality
                                                : -1;
                                        qualityMin = qualityMin || 2;
                                        qualityMax = qualityMax || 14;

                                        var newVertices = [];

                                        for (
                                            var i = 0;
                                            i < vertices.length;
                                            i++
                                        ) {
                                            var prevVertex =
                                                    vertices[
                                                        i - 1 >= 0
                                                            ? i - 1
                                                            : vertices.length -
                                                              1
                                                    ],
                                                vertex = vertices[i],
                                                nextVertex =
                                                    vertices[
                                                        (i + 1) %
                                                            vertices.length
                                                    ],
                                                currentRadius =
                                                    radius[
                                                        i < radius.length
                                                            ? i
                                                            : radius.length - 1
                                                    ];

                                            if (currentRadius === 0) {
                                                newVertices.push(vertex);
                                                continue;
                                            }

                                            var prevNormal = Vector.normalise({
                                                x: vertex.y - prevVertex.y,
                                                y: prevVertex.x - vertex.x,
                                            });

                                            var nextNormal = Vector.normalise({
                                                x: nextVertex.y - vertex.y,
                                                y: vertex.x - nextVertex.x,
                                            });

                                            var diagonalRadius = Math.sqrt(
                                                    2 *
                                                        Math.pow(
                                                            currentRadius,
                                                            2
                                                        )
                                                ),
                                                radiusVector = Vector.mult(
                                                    Common.clone(prevNormal),
                                                    currentRadius
                                                ),
                                                midNormal = Vector.normalise(
                                                    Vector.mult(
                                                        Vector.add(
                                                            prevNormal,
                                                            nextNormal
                                                        ),
                                                        0.5
                                                    )
                                                ),
                                                scaledVertex = Vector.sub(
                                                    vertex,
                                                    Vector.mult(
                                                        midNormal,
                                                        diagonalRadius
                                                    )
                                                );

                                            var precision = quality;

                                            if (quality === -1) {
                                                // automatically decide precision
                                                precision =
                                                    Math.pow(
                                                        currentRadius,
                                                        0.32
                                                    ) * 1.75;
                                            }

                                            precision = Common.clamp(
                                                precision,
                                                qualityMin,
                                                qualityMax
                                            );

                                            // use an even value for precision, more likely to reduce axes by using symmetry
                                            if (precision % 2 === 1)
                                                precision += 1;

                                            var alpha = Math.acos(
                                                    Vector.dot(
                                                        prevNormal,
                                                        nextNormal
                                                    )
                                                ),
                                                theta = alpha / precision;

                                            for (
                                                var j = 0;
                                                j < precision;
                                                j++
                                            ) {
                                                newVertices.push(
                                                    Vector.add(
                                                        Vector.rotate(
                                                            radiusVector,
                                                            theta * j
                                                        ),
                                                        scaledVertex
                                                    )
                                                );
                                            }
                                        }

                                        return newVertices;
                                    };

                                    /**
                                     * Sorts the input vertices into clockwise order in place.
                                     * @method clockwiseSort
                                     * @param {vertices} vertices
                                     * @return {vertices} vertices
                                     */
                                    Vertices.clockwiseSort = function (
                                        vertices
                                    ) {
                                        var centre = Vertices.mean(vertices);

                                        vertices.sort(function (
                                            vertexA,
                                            vertexB
                                        ) {
                                            return (
                                                Vector.angle(centre, vertexA) -
                                                Vector.angle(centre, vertexB)
                                            );
                                        });

                                        return vertices;
                                    };

                                    /**
                                     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
                                     * @method isConvex
                                     * @param {vertices} vertices
                                     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
                                     */
                                    Vertices.isConvex = function (vertices) {
                                        // http://paulbourke.net/geometry/polygonmesh/

                                        var flag = 0,
                                            n = vertices.length,
                                            i,
                                            j,
                                            k,
                                            z;

                                        if (n < 3) return null;

                                        for (i = 0; i < n; i++) {
                                            j = (i + 1) % n;
                                            k = (i + 2) % n;
                                            z =
                                                (vertices[j].x -
                                                    vertices[i].x) *
                                                (vertices[k].y - vertices[j].y);
                                            z -=
                                                (vertices[j].y -
                                                    vertices[i].y) *
                                                (vertices[k].x - vertices[j].x);

                                            if (z < 0) {
                                                flag |= 1;
                                            } else if (z > 0) {
                                                flag |= 2;
                                            }

                                            if (flag === 3) {
                                                return false;
                                            }
                                        }

                                        if (flag !== 0) {
                                            return true;
                                        } else {
                                            return null;
                                        }
                                    };

                                    /**
                                     * Returns the convex hull of the input vertices as a new array of points.
                                     * @method hull
                                     * @param {vertices} vertices
                                     * @return [vertex] vertices
                                     */
                                    Vertices.hull = function (vertices) {
                                        // http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain

                                        var upper = [],
                                            lower = [],
                                            vertex,
                                            i;

                                        // sort vertices on x-axis (y-axis for ties)
                                        vertices = vertices.slice(0);
                                        vertices.sort(function (
                                            vertexA,
                                            vertexB
                                        ) {
                                            var dx = vertexA.x - vertexB.x;
                                            return dx !== 0
                                                ? dx
                                                : vertexA.y - vertexB.y;
                                        });

                                        // build lower hull
                                        for (i = 0; i < vertices.length; i++) {
                                            vertex = vertices[i];

                                            while (
                                                lower.length >= 2 &&
                                                Vector.cross3(
                                                    lower[lower.length - 2],
                                                    lower[lower.length - 1],
                                                    vertex
                                                ) <= 0
                                            ) {
                                                lower.pop();
                                            }

                                            lower.push(vertex);
                                        }

                                        // build upper hull
                                        for (
                                            i = vertices.length - 1;
                                            i >= 0;
                                            i--
                                        ) {
                                            vertex = vertices[i];

                                            while (
                                                upper.length >= 2 &&
                                                Vector.cross3(
                                                    upper[upper.length - 2],
                                                    upper[upper.length - 1],
                                                    vertex
                                                ) <= 0
                                            ) {
                                                upper.pop();
                                            }

                                            upper.push(vertex);
                                        }

                                        // concatenation of the lower and upper hulls gives the convex hull
                                        // omit last points because they are repeated at the beginning of the other list
                                        upper.pop();
                                        lower.pop();

                                        return upper.concat(lower);
                                    };
                                })();
                            },
                            { "../core/Common": 14, "../geometry/Vector": 26 },
                        ],
                        28: [
                            function (require, module, exports) {
                                var Matter = (module.exports = {});
                                Matter.version = "master";

                                Matter.Body = require("../body/Body");
                                Matter.Composite = require("../body/Composite");
                                Matter.World = require("../body/World");

                                Matter.Contact = require("../collision/Contact");
                                Matter.Detector = require("../collision/Detector");
                                Matter.Grid = require("../collision/Grid");
                                Matter.Pairs = require("../collision/Pairs");
                                Matter.Pair = require("../collision/Pair");
                                Matter.Query = require("../collision/Query");
                                Matter.Resolver = require("../collision/Resolver");
                                Matter.SAT = require("../collision/SAT");

                                Matter.Constraint = require("../constraint/Constraint");
                                Matter.MouseConstraint = require("../constraint/MouseConstraint");

                                Matter.Common = require("../core/Common");
                                Matter.Engine = require("../core/Engine");
                                Matter.Events = require("../core/Events");
                                Matter.Mouse = require("../core/Mouse");
                                Matter.Runner = require("../core/Runner");
                                Matter.Sleeping = require("../core/Sleeping");

                                Matter.Bodies = require("../factory/Bodies");
                                Matter.Composites = require("../factory/Composites");

                                Matter.Axes = require("../geometry/Axes");
                                Matter.Bounds = require("../geometry/Bounds");
                                Matter.Svg = require("../geometry/Svg");
                                Matter.Vector = require("../geometry/Vector");
                                Matter.Vertices = require("../geometry/Vertices");

                                Matter.Render = require("../render/Render");
                                Matter.RenderPixi = require("../render/RenderPixi");

                                // aliases

                                Matter.World.add = Matter.Composite.add;
                                Matter.World.remove = Matter.Composite.remove;
                                Matter.World.addComposite =
                                    Matter.Composite.addComposite;
                                Matter.World.addBody = Matter.Composite.addBody;
                                Matter.World.addConstraint =
                                    Matter.Composite.addConstraint;
                                Matter.World.clear = Matter.Composite.clear;
                                Matter.Engine.run = Matter.Runner.run;
                            },
                            {
                                "../body/Body": 1,
                                "../body/Composite": 2,
                                "../body/World": 3,
                                "../collision/Contact": 4,
                                "../collision/Detector": 5,
                                "../collision/Grid": 6,
                                "../collision/Pair": 7,
                                "../collision/Pairs": 8,
                                "../collision/Query": 9,
                                "../collision/Resolver": 10,
                                "../collision/SAT": 11,
                                "../constraint/Constraint": 12,
                                "../constraint/MouseConstraint": 13,
                                "../core/Common": 14,
                                "../core/Engine": 15,
                                "../core/Events": 16,
                                "../core/Metrics": 17,
                                "../core/Mouse": 18,
                                "../core/Runner": 19,
                                "../core/Sleeping": 20,
                                "../factory/Bodies": 21,
                                "../factory/Composites": 22,
                                "../geometry/Axes": 23,
                                "../geometry/Bounds": 24,
                                "../geometry/Svg": 25,
                                "../geometry/Vector": 26,
                                "../geometry/Vertices": 27,
                                "../render/Render": 29,
                                "../render/RenderPixi": 30,
                            },
                        ],
                        29: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.Render` module is the default `render.controller` used by a `Matter.Engine`.
                                 * This renderer is HTML5 canvas based and supports a number of drawing options including sprites and viewports.
                                 *
                                 * It is possible develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.
                                 * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
                                 *
                                 * See also `Matter.RenderPixi` for an alternate WebGL, scene-graph based renderer.
                                 *
                                 * @class Render
                                 */

                                var Render = {};

                                module.exports = Render;

                                var Common = require("../core/Common");
                                var Composite = require("../body/Composite");
                                var Bounds = require("../geometry/Bounds");
                                var Events = require("../core/Events");
                                var Grid = require("../collision/Grid");
                                var Vector = require("../geometry/Vector");

                                (function () {
                                    /**
                                     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
                                     * All properties have default values, and many are pre-calculated automatically based on other properties.
                                     * See the properties section below for detailed information on what you can pass via the `options` object.
                                     * @method create
                                     * @param {object} [options]
                                     * @return {render} A new renderer
                                     */
                                    Render.create = function (options) {
                                        var defaults = {
                                            controller: Render,
                                            element: null,
                                            canvas: null,
                                            mouse: null,
                                            options: {
                                                width: 800,
                                                height: 600,
                                                pixelRatio: 1,
                                                background: "#fafafa",
                                                wireframeBackground: "#222",
                                                hasBounds: false,
                                                enabled: true,
                                                wireframes: true,
                                                showSleeping: true,
                                                showDebug: false,
                                                showBroadphase: false,
                                                showBounds: false,
                                                showVelocity: false,
                                                showCollisions: false,
                                                showSeparations: false,
                                                showAxes: false,
                                                showPositions: false,
                                                showAngleIndicator: false,
                                                showIds: false,
                                                showShadows: false,
                                                showVertexNumbers: false,
                                                showConvexHulls: false,
                                                showInternalEdges: false,
                                                showMousePosition: false,
                                            },
                                        };

                                        var render = Common.extend(
                                            defaults,
                                            options
                                        );

                                        if (render.canvas) {
                                            render.canvas.width =
                                                render.options.width ||
                                                render.canvas.width;
                                            render.canvas.height =
                                                render.options.height ||
                                                render.canvas.height;
                                        }

                                        render.canvas =
                                            render.canvas ||
                                            _createCanvas(
                                                render.options.width,
                                                render.options.height
                                            );
                                        render.context =
                                            render.canvas.getContext("2d");
                                        render.textures = {};

                                        render.bounds = render.bounds || {
                                            min: {
                                                x: 0,
                                                y: 0,
                                            },
                                            max: {
                                                x: render.canvas.width,
                                                y: render.canvas.height,
                                            },
                                        };

                                        if (render.options.pixelRatio !== 1) {
                                            Render.setPixelRatio(
                                                render,
                                                render.options.pixelRatio
                                            );
                                        }

                                        if (Common.isElement(render.element)) {
                                            render.element.appendChild(
                                                render.canvas
                                            );
                                        } else {
                                            Common.log(
                                                "Render.create: options.element was undefined, render.canvas was created but not appended",
                                                "warn"
                                            );
                                        }

                                        return render;
                                    };

                                    /**
                                     * Sets the pixel ratio of the renderer and updates the canvas.
                                     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
                                     * @method setPixelRatio
                                     * @param {render} render
                                     * @param {number} pixelRatio
                                     */
                                    Render.setPixelRatio = function (
                                        render,
                                        pixelRatio
                                    ) {
                                        var options = render.options,
                                            canvas = render.canvas;

                                        if (pixelRatio === "auto") {
                                            pixelRatio = _getPixelRatio(canvas);
                                        }

                                        options.pixelRatio = pixelRatio;
                                        canvas.setAttribute(
                                            "data-pixel-ratio",
                                            pixelRatio
                                        );
                                        canvas.width =
                                            options.width * pixelRatio;
                                        canvas.height =
                                            options.height * pixelRatio;
                                        canvas.style.width =
                                            options.width + "px";
                                        canvas.style.height =
                                            options.height + "px";
                                        render.context.scale(
                                            pixelRatio,
                                            pixelRatio
                                        );
                                    };

                                    /**
                                     * Renders the given `engine`'s `Matter.World` object.
                                     * This is the entry point for all rendering and should be called every time the scene changes.
                                     * @method world
                                     * @param {engine} engine
                                     */
                                    Render.world = function (engine) {
                                        var render = engine.render,
                                            world = engine.world,
                                            canvas = render.canvas,
                                            context = render.context,
                                            options = render.options,
                                            allBodies =
                                                Composite.allBodies(world),
                                            allConstraints =
                                                Composite.allConstraints(world),
                                            background = options.wireframes
                                                ? options.wireframeBackground
                                                : options.background,
                                            bodies = [],
                                            constraints = [],
                                            i;

                                        var event = {
                                            timestamp: engine.timing.timestamp,
                                        };

                                        Events.trigger(
                                            render,
                                            "beforeRender",
                                            event
                                        );

                                        // apply background if it has changed
                                        if (
                                            render.currentBackground !==
                                            background
                                        )
                                            _applyBackground(
                                                render,
                                                background
                                            );

                                        // clear the canvas with a transparent fill, to allow the canvas background to show
                                        context.globalCompositeOperation =
                                            "source-in";
                                        context.fillStyle = "transparent";
                                        context.fillRect(
                                            0,
                                            0,
                                            canvas.width,
                                            canvas.height
                                        );
                                        context.globalCompositeOperation =
                                            "source-over";

                                        // handle bounds
                                        if (options.hasBounds) {
                                            var boundsWidth =
                                                    render.bounds.max.x -
                                                    render.bounds.min.x,
                                                boundsHeight =
                                                    render.bounds.max.y -
                                                    render.bounds.min.y,
                                                boundsScaleX =
                                                    boundsWidth / options.width,
                                                boundsScaleY =
                                                    boundsHeight /
                                                    options.height;

                                            // filter out bodies that are not in view
                                            for (
                                                i = 0;
                                                i < allBodies.length;
                                                i++
                                            ) {
                                                var body = allBodies[i];
                                                if (
                                                    Bounds.overlaps(
                                                        body.bounds,
                                                        render.bounds
                                                    )
                                                )
                                                    bodies.push(body);
                                            }

                                            // filter out constraints that are not in view
                                            for (
                                                i = 0;
                                                i < allConstraints.length;
                                                i++
                                            ) {
                                                var constraint =
                                                        allConstraints[i],
                                                    bodyA = constraint.bodyA,
                                                    bodyB = constraint.bodyB,
                                                    pointAWorld =
                                                        constraint.pointA,
                                                    pointBWorld =
                                                        constraint.pointB;

                                                if (bodyA)
                                                    pointAWorld = Vector.add(
                                                        bodyA.position,
                                                        constraint.pointA
                                                    );
                                                if (bodyB)
                                                    pointBWorld = Vector.add(
                                                        bodyB.position,
                                                        constraint.pointB
                                                    );

                                                if (
                                                    !pointAWorld ||
                                                    !pointBWorld
                                                )
                                                    continue;

                                                if (
                                                    Bounds.contains(
                                                        render.bounds,
                                                        pointAWorld
                                                    ) ||
                                                    Bounds.contains(
                                                        render.bounds,
                                                        pointBWorld
                                                    )
                                                )
                                                    constraints.push(
                                                        constraint
                                                    );
                                            }

                                            // transform the view
                                            context.scale(
                                                1 / boundsScaleX,
                                                1 / boundsScaleY
                                            );
                                            context.translate(
                                                -render.bounds.min.x,
                                                -render.bounds.min.y
                                            );
                                        } else {
                                            constraints = allConstraints;
                                            bodies = allBodies;
                                        }

                                        if (
                                            !options.wireframes ||
                                            (engine.enableSleeping &&
                                                options.showSleeping)
                                        ) {
                                            // fully featured rendering of bodies
                                            Render.bodies(
                                                engine,
                                                bodies,
                                                context
                                            );
                                        } else {
                                            if (options.showConvexHulls)
                                                Render.bodyConvexHulls(
                                                    engine,
                                                    bodies,
                                                    context
                                                );

                                            // optimised method for wireframes only
                                            Render.bodyWireframes(
                                                engine,
                                                bodies,
                                                context
                                            );
                                        }

                                        if (options.showBounds)
                                            Render.bodyBounds(
                                                engine,
                                                bodies,
                                                context
                                            );

                                        if (
                                            options.showAxes ||
                                            options.showAngleIndicator
                                        )
                                            Render.bodyAxes(
                                                engine,
                                                bodies,
                                                context
                                            );

                                        if (options.showPositions)
                                            Render.bodyPositions(
                                                engine,
                                                bodies,
                                                context
                                            );

                                        if (options.showVelocity)
                                            Render.bodyVelocity(
                                                engine,
                                                bodies,
                                                context
                                            );

                                        if (options.showIds)
                                            Render.bodyIds(
                                                engine,
                                                bodies,
                                                context
                                            );

                                        if (options.showSeparations)
                                            Render.separations(
                                                engine,
                                                engine.pairs.list,
                                                context
                                            );

                                        if (options.showCollisions)
                                            Render.collisions(
                                                engine,
                                                engine.pairs.list,
                                                context
                                            );

                                        if (options.showVertexNumbers)
                                            Render.vertexNumbers(
                                                engine,
                                                bodies,
                                                context
                                            );

                                        if (options.showMousePosition)
                                            Render.mousePosition(
                                                engine,
                                                render.mouse,
                                                context
                                            );

                                        Render.constraints(
                                            constraints,
                                            context
                                        );

                                        if (
                                            options.showBroadphase &&
                                            engine.broadphase.controller ===
                                                Grid
                                        )
                                            Render.grid(
                                                engine,
                                                engine.broadphase,
                                                context
                                            );

                                        if (options.showDebug)
                                            Render.debug(engine, context);

                                        if (options.hasBounds) {
                                            // revert view transforms
                                            context.setTransform(
                                                options.pixelRatio,
                                                0,
                                                0,
                                                options.pixelRatio,
                                                0,
                                                0
                                            );
                                        }

                                        Events.trigger(
                                            render,
                                            "afterRender",
                                            event
                                        );
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method debug
                                     * @param {engine} engine
                                     * @param {RenderingContext} context
                                     */
                                    Render.debug = function (engine, context) {
                                        var c = context,
                                            world = engine.world,
                                            render = engine.render,
                                            metrics = engine.metrics,
                                            options = render.options,
                                            bodies = Composite.allBodies(world),
                                            space = "    ";

                                        if (
                                            engine.timing.timestamp -
                                                (render.debugTimestamp || 0) >=
                                            500
                                        ) {
                                            var text = "";

                                            if (metrics.timing) {
                                                text +=
                                                    "fps: " +
                                                    Math.round(
                                                        metrics.timing.fps
                                                    ) +
                                                    space;
                                            }

                                            render.debugString = text;
                                            render.debugTimestamp =
                                                engine.timing.timestamp;
                                        }

                                        if (render.debugString) {
                                            c.font = "12px Arial";

                                            if (options.wireframes) {
                                                c.fillStyle =
                                                    "rgba(255,255,255,0.5)";
                                            } else {
                                                c.fillStyle = "rgba(0,0,0,0.5)";
                                            }

                                            var split =
                                                render.debugString.split("\n");

                                            for (
                                                var i = 0;
                                                i < split.length;
                                                i++
                                            ) {
                                                c.fillText(
                                                    split[i],
                                                    50,
                                                    50 + i * 18
                                                );
                                            }
                                        }
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method constraints
                                     * @param {constraint[]} constraints
                                     * @param {RenderingContext} context
                                     */
                                    Render.constraints = function (
                                        constraints,
                                        context
                                    ) {
                                        var c = context;

                                        for (
                                            var i = 0;
                                            i < constraints.length;
                                            i++
                                        ) {
                                            var constraint = constraints[i];

                                            if (
                                                !constraint.render.visible ||
                                                !constraint.pointA ||
                                                !constraint.pointB
                                            )
                                                continue;

                                            var bodyA = constraint.bodyA,
                                                bodyB = constraint.bodyB;

                                            if (bodyA) {
                                                c.beginPath();
                                                c.moveTo(
                                                    bodyA.position.x +
                                                        constraint.pointA.x,
                                                    bodyA.position.y +
                                                        constraint.pointA.y
                                                );
                                            } else {
                                                c.beginPath();
                                                c.moveTo(
                                                    constraint.pointA.x,
                                                    constraint.pointA.y
                                                );
                                            }

                                            if (bodyB) {
                                                c.lineTo(
                                                    bodyB.position.x +
                                                        constraint.pointB.x,
                                                    bodyB.position.y +
                                                        constraint.pointB.y
                                                );
                                            } else {
                                                c.lineTo(
                                                    constraint.pointB.x,
                                                    constraint.pointB.y
                                                );
                                            }

                                            c.lineWidth =
                                                constraint.render.lineWidth;
                                            c.strokeStyle =
                                                constraint.render.strokeStyle;
                                            c.stroke();
                                        }
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method bodyShadows
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyShadows = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            render = engine.render;

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            if (!body.render.visible) continue;

                                            if (body.circleRadius) {
                                                c.beginPath();
                                                c.arc(
                                                    body.position.x,
                                                    body.position.y,
                                                    body.circleRadius,
                                                    0,
                                                    2 * Math.PI
                                                );
                                                c.closePath();
                                            } else {
                                                c.beginPath();
                                                c.moveTo(
                                                    body.vertices[0].x,
                                                    body.vertices[0].y
                                                );
                                                for (
                                                    var j = 1;
                                                    j < body.vertices.length;
                                                    j++
                                                ) {
                                                    c.lineTo(
                                                        body.vertices[j].x,
                                                        body.vertices[j].y
                                                    );
                                                }
                                                c.closePath();
                                            }

                                            var distanceX =
                                                    body.position.x -
                                                    render.options.width * 0.5,
                                                distanceY =
                                                    body.position.y -
                                                    render.options.height * 0.2,
                                                distance =
                                                    Math.abs(distanceX) +
                                                    Math.abs(distanceY);

                                            c.shadowColor = "rgba(0,0,0,0.15)";
                                            c.shadowOffsetX = 0.05 * distanceX;
                                            c.shadowOffsetY = 0.05 * distanceY;
                                            c.shadowBlur =
                                                1 +
                                                12 *
                                                    Math.min(
                                                        1,
                                                        distance / 1000
                                                    );

                                            c.fill();

                                            c.shadowColor = null;
                                            c.shadowOffsetX = null;
                                            c.shadowOffsetY = null;
                                            c.shadowBlur = null;
                                        }
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method bodies
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodies = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            render = engine.render,
                                            options = render.options,
                                            showInternalEdges =
                                                options.showInternalEdges ||
                                                !options.wireframes,
                                            body,
                                            part,
                                            i,
                                            k;

                                        for (i = 0; i < bodies.length; i++) {
                                            body = bodies[i];

                                            if (!body.render.visible) continue;

                                            // handle compound parts
                                            for (
                                                k =
                                                    body.parts.length > 1
                                                        ? 1
                                                        : 0;
                                                k < body.parts.length;
                                                k++
                                            ) {
                                                part = body.parts[k];

                                                if (!part.render.visible)
                                                    continue;

                                                if (
                                                    options.showSleeping &&
                                                    body.isSleeping
                                                ) {
                                                    c.globalAlpha =
                                                        0.5 *
                                                        part.render.opacity;
                                                } else if (
                                                    part.render.opacity !== 1
                                                ) {
                                                    c.globalAlpha =
                                                        part.render.opacity;
                                                }

                                                if (
                                                    part.render.sprite &&
                                                    part.render.sprite
                                                        .texture &&
                                                    !options.wireframes
                                                ) {
                                                    // part sprite
                                                    var sprite =
                                                            part.render.sprite,
                                                        texture = _getTexture(
                                                            render,
                                                            sprite.texture
                                                        );

                                                    c.translate(
                                                        part.position.x,
                                                        part.position.y
                                                    );
                                                    c.rotate(part.angle);

                                                    c.drawImage(
                                                        texture,
                                                        texture.width *
                                                            -sprite.xOffset *
                                                            sprite.xScale,
                                                        texture.height *
                                                            -sprite.yOffset *
                                                            sprite.yScale,
                                                        texture.width *
                                                            sprite.xScale,
                                                        texture.height *
                                                            sprite.yScale
                                                    );

                                                    // revert translation, hopefully faster than save / restore
                                                    c.rotate(-part.angle);
                                                    c.translate(
                                                        -part.position.x,
                                                        -part.position.y
                                                    );
                                                } else {
                                                    // part polygon
                                                    if (part.circleRadius) {
                                                        c.beginPath();
                                                        c.arc(
                                                            part.position.x,
                                                            part.position.y,
                                                            part.circleRadius,
                                                            0,
                                                            2 * Math.PI
                                                        );
                                                    } else {
                                                        c.beginPath();
                                                        c.moveTo(
                                                            part.vertices[0].x,
                                                            part.vertices[0].y
                                                        );

                                                        for (
                                                            var j = 1;
                                                            j <
                                                            part.vertices
                                                                .length;
                                                            j++
                                                        ) {
                                                            if (
                                                                !part.vertices[
                                                                    j - 1
                                                                ].isInternal ||
                                                                showInternalEdges
                                                            ) {
                                                                c.lineTo(
                                                                    part
                                                                        .vertices[
                                                                        j
                                                                    ].x,
                                                                    part
                                                                        .vertices[
                                                                        j
                                                                    ].y
                                                                );
                                                            } else {
                                                                c.moveTo(
                                                                    part
                                                                        .vertices[
                                                                        j
                                                                    ].x,
                                                                    part
                                                                        .vertices[
                                                                        j
                                                                    ].y
                                                                );
                                                            }

                                                            if (
                                                                part.vertices[j]
                                                                    .isInternal &&
                                                                !showInternalEdges
                                                            ) {
                                                                c.moveTo(
                                                                    part
                                                                        .vertices[
                                                                        (j +
                                                                            1) %
                                                                            part
                                                                                .vertices
                                                                                .length
                                                                    ].x,
                                                                    part
                                                                        .vertices[
                                                                        (j +
                                                                            1) %
                                                                            part
                                                                                .vertices
                                                                                .length
                                                                    ].y
                                                                );
                                                            }
                                                        }

                                                        c.lineTo(
                                                            part.vertices[0].x,
                                                            part.vertices[0].y
                                                        );
                                                        c.closePath();
                                                    }

                                                    if (!options.wireframes) {
                                                        c.fillStyle =
                                                            part.render.fillStyle;
                                                        c.lineWidth =
                                                            part.render.lineWidth;
                                                        c.strokeStyle =
                                                            part.render.strokeStyle;
                                                        c.fill();
                                                    } else {
                                                        c.lineWidth = 1;
                                                        c.strokeStyle = "#bbb";
                                                    }

                                                    c.stroke();
                                                }

                                                c.globalAlpha = 1;
                                            }
                                        }
                                    };

                                    /**
                                     * Optimised method for drawing body wireframes in one pass
                                     * @private
                                     * @method bodyWireframes
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyWireframes = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            showInternalEdges =
                                                engine.render.options
                                                    .showInternalEdges,
                                            body,
                                            part,
                                            i,
                                            j,
                                            k;

                                        c.beginPath();

                                        // render all bodies
                                        for (i = 0; i < bodies.length; i++) {
                                            body = bodies[i];

                                            if (!body.render.visible) continue;

                                            // handle compound parts
                                            for (
                                                k =
                                                    body.parts.length > 1
                                                        ? 1
                                                        : 0;
                                                k < body.parts.length;
                                                k++
                                            ) {
                                                part = body.parts[k];

                                                c.moveTo(
                                                    part.vertices[0].x,
                                                    part.vertices[0].y
                                                );

                                                for (
                                                    j = 1;
                                                    j < part.vertices.length;
                                                    j++
                                                ) {
                                                    if (
                                                        !part.vertices[j - 1]
                                                            .isInternal ||
                                                        showInternalEdges
                                                    ) {
                                                        c.lineTo(
                                                            part.vertices[j].x,
                                                            part.vertices[j].y
                                                        );
                                                    } else {
                                                        c.moveTo(
                                                            part.vertices[j].x,
                                                            part.vertices[j].y
                                                        );
                                                    }

                                                    if (
                                                        part.vertices[j]
                                                            .isInternal &&
                                                        !showInternalEdges
                                                    ) {
                                                        c.moveTo(
                                                            part.vertices[
                                                                (j + 1) %
                                                                    part
                                                                        .vertices
                                                                        .length
                                                            ].x,
                                                            part.vertices[
                                                                (j + 1) %
                                                                    part
                                                                        .vertices
                                                                        .length
                                                            ].y
                                                        );
                                                    }
                                                }

                                                c.lineTo(
                                                    part.vertices[0].x,
                                                    part.vertices[0].y
                                                );
                                            }
                                        }

                                        c.lineWidth = 1;
                                        c.strokeStyle = "#bbb";
                                        c.stroke();
                                    };

                                    /**
                                     * Optimised method for drawing body convex hull wireframes in one pass
                                     * @private
                                     * @method bodyConvexHulls
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyConvexHulls = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            body,
                                            part,
                                            i,
                                            j,
                                            k;

                                        c.beginPath();

                                        // render convex hulls
                                        for (i = 0; i < bodies.length; i++) {
                                            body = bodies[i];

                                            if (
                                                !body.render.visible ||
                                                body.parts.length === 1
                                            )
                                                continue;

                                            c.moveTo(
                                                body.vertices[0].x,
                                                body.vertices[0].y
                                            );

                                            for (
                                                j = 1;
                                                j < body.vertices.length;
                                                j++
                                            ) {
                                                c.lineTo(
                                                    body.vertices[j].x,
                                                    body.vertices[j].y
                                                );
                                            }

                                            c.lineTo(
                                                body.vertices[0].x,
                                                body.vertices[0].y
                                            );
                                        }

                                        c.lineWidth = 1;
                                        c.strokeStyle = "rgba(255,255,255,0.2)";
                                        c.stroke();
                                    };

                                    /**
                                     * Renders body vertex numbers.
                                     * @private
                                     * @method vertexNumbers
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.vertexNumbers = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            i,
                                            j,
                                            k;

                                        for (i = 0; i < bodies.length; i++) {
                                            var parts = bodies[i].parts;
                                            for (
                                                k = parts.length > 1 ? 1 : 0;
                                                k < parts.length;
                                                k++
                                            ) {
                                                var part = parts[k];
                                                for (
                                                    j = 0;
                                                    j < part.vertices.length;
                                                    j++
                                                ) {
                                                    c.fillStyle =
                                                        "rgba(255,255,255,0.2)";
                                                    c.fillText(
                                                        i + "_" + j,
                                                        part.position.x +
                                                            (part.vertices[j]
                                                                .x -
                                                                part.position
                                                                    .x) *
                                                                0.8,
                                                        part.position.y +
                                                            (part.vertices[j]
                                                                .y -
                                                                part.position
                                                                    .y) *
                                                                0.8
                                                    );
                                                }
                                            }
                                        }
                                    };

                                    /**
                                     * Renders mouse position.
                                     * @private
                                     * @method mousePosition
                                     * @param {engine} engine
                                     * @param {mouse} mouse
                                     * @param {RenderingContext} context
                                     */
                                    Render.mousePosition = function (
                                        engine,
                                        mouse,
                                        context
                                    ) {
                                        var c = context;
                                        c.fillStyle = "rgba(255,255,255,0.8)";
                                        c.fillText(
                                            mouse.position.x +
                                                "  " +
                                                mouse.position.y,
                                            mouse.position.x + 5,
                                            mouse.position.y - 5
                                        );
                                    };

                                    /**
                                     * Draws body bounds
                                     * @private
                                     * @method bodyBounds
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyBounds = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            render = engine.render,
                                            options = render.options;

                                        c.beginPath();

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            if (body.render.visible) {
                                                var parts = bodies[i].parts;
                                                for (
                                                    var j =
                                                        parts.length > 1
                                                            ? 1
                                                            : 0;
                                                    j < parts.length;
                                                    j++
                                                ) {
                                                    var part = parts[j];
                                                    c.rect(
                                                        part.bounds.min.x,
                                                        part.bounds.min.y,
                                                        part.bounds.max.x -
                                                            part.bounds.min.x,
                                                        part.bounds.max.y -
                                                            part.bounds.min.y
                                                    );
                                                }
                                            }
                                        }

                                        if (options.wireframes) {
                                            c.strokeStyle =
                                                "rgba(255,255,255,0.08)";
                                        } else {
                                            c.strokeStyle = "rgba(0,0,0,0.1)";
                                        }

                                        c.lineWidth = 1;
                                        c.stroke();
                                    };

                                    /**
                                     * Draws body angle indicators and axes
                                     * @private
                                     * @method bodyAxes
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyAxes = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            render = engine.render,
                                            options = render.options,
                                            part,
                                            i,
                                            j,
                                            k;

                                        c.beginPath();

                                        for (i = 0; i < bodies.length; i++) {
                                            var body = bodies[i],
                                                parts = body.parts;

                                            if (!body.render.visible) continue;

                                            if (options.showAxes) {
                                                // render all axes
                                                for (
                                                    j =
                                                        parts.length > 1
                                                            ? 1
                                                            : 0;
                                                    j < parts.length;
                                                    j++
                                                ) {
                                                    part = parts[j];
                                                    for (
                                                        k = 0;
                                                        k < part.axes.length;
                                                        k++
                                                    ) {
                                                        var axis = part.axes[k];
                                                        c.moveTo(
                                                            part.position.x,
                                                            part.position.y
                                                        );
                                                        c.lineTo(
                                                            part.position.x +
                                                                axis.x * 20,
                                                            part.position.y +
                                                                axis.y * 20
                                                        );
                                                    }
                                                }
                                            } else {
                                                for (
                                                    j =
                                                        parts.length > 1
                                                            ? 1
                                                            : 0;
                                                    j < parts.length;
                                                    j++
                                                ) {
                                                    part = parts[j];
                                                    for (
                                                        k = 0;
                                                        k < part.axes.length;
                                                        k++
                                                    ) {
                                                        // render a single axis indicator
                                                        c.moveTo(
                                                            part.position.x,
                                                            part.position.y
                                                        );
                                                        c.lineTo(
                                                            (part.vertices[0]
                                                                .x +
                                                                part.vertices[
                                                                    part
                                                                        .vertices
                                                                        .length -
                                                                        1
                                                                ].x) /
                                                                2,
                                                            (part.vertices[0]
                                                                .y +
                                                                part.vertices[
                                                                    part
                                                                        .vertices
                                                                        .length -
                                                                        1
                                                                ].y) /
                                                                2
                                                        );
                                                    }
                                                }
                                            }
                                        }

                                        if (options.wireframes) {
                                            c.strokeStyle = "indianred";
                                        } else {
                                            c.strokeStyle = "rgba(0,0,0,0.8)";
                                            c.globalCompositeOperation =
                                                "overlay";
                                        }

                                        c.lineWidth = 1;
                                        c.stroke();
                                        c.globalCompositeOperation =
                                            "source-over";
                                    };

                                    /**
                                     * Draws body positions
                                     * @private
                                     * @method bodyPositions
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyPositions = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            render = engine.render,
                                            options = render.options,
                                            body,
                                            part,
                                            i,
                                            k;

                                        c.beginPath();

                                        // render current positions
                                        for (i = 0; i < bodies.length; i++) {
                                            body = bodies[i];

                                            if (!body.render.visible) continue;

                                            // handle compound parts
                                            for (
                                                k = 0;
                                                k < body.parts.length;
                                                k++
                                            ) {
                                                part = body.parts[k];
                                                c.arc(
                                                    part.position.x,
                                                    part.position.y,
                                                    3,
                                                    0,
                                                    2 * Math.PI,
                                                    false
                                                );
                                                c.closePath();
                                            }
                                        }

                                        if (options.wireframes) {
                                            c.fillStyle = "indianred";
                                        } else {
                                            c.fillStyle = "rgba(0,0,0,0.5)";
                                        }
                                        c.fill();

                                        c.beginPath();

                                        // render previous positions
                                        for (i = 0; i < bodies.length; i++) {
                                            body = bodies[i];
                                            if (body.render.visible) {
                                                c.arc(
                                                    body.positionPrev.x,
                                                    body.positionPrev.y,
                                                    2,
                                                    0,
                                                    2 * Math.PI,
                                                    false
                                                );
                                                c.closePath();
                                            }
                                        }

                                        c.fillStyle = "rgba(255,165,0,0.8)";
                                        c.fill();
                                    };

                                    /**
                                     * Draws body velocity
                                     * @private
                                     * @method bodyVelocity
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyVelocity = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context;

                                        c.beginPath();

                                        for (
                                            var i = 0;
                                            i < bodies.length;
                                            i++
                                        ) {
                                            var body = bodies[i];

                                            if (!body.render.visible) continue;

                                            c.moveTo(
                                                body.position.x,
                                                body.position.y
                                            );
                                            c.lineTo(
                                                body.position.x +
                                                    (body.position.x -
                                                        body.positionPrev.x) *
                                                        2,
                                                body.position.y +
                                                    (body.position.y -
                                                        body.positionPrev.y) *
                                                        2
                                            );
                                        }

                                        c.lineWidth = 3;
                                        c.strokeStyle = "cornflowerblue";
                                        c.stroke();
                                    };

                                    /**
                                     * Draws body ids
                                     * @private
                                     * @method bodyIds
                                     * @param {engine} engine
                                     * @param {body[]} bodies
                                     * @param {RenderingContext} context
                                     */
                                    Render.bodyIds = function (
                                        engine,
                                        bodies,
                                        context
                                    ) {
                                        var c = context,
                                            i,
                                            j;

                                        for (i = 0; i < bodies.length; i++) {
                                            if (!bodies[i].render.visible)
                                                continue;

                                            var parts = bodies[i].parts;
                                            for (
                                                j = parts.length > 1 ? 1 : 0;
                                                j < parts.length;
                                                j++
                                            ) {
                                                var part = parts[j];
                                                c.font = "12px Arial";
                                                c.fillStyle =
                                                    "rgba(255,255,255,0.5)";
                                                c.fillText(
                                                    part.id,
                                                    part.position.x + 10,
                                                    part.position.y - 10
                                                );
                                            }
                                        }
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method collisions
                                     * @param {engine} engine
                                     * @param {pair[]} pairs
                                     * @param {RenderingContext} context
                                     */
                                    Render.collisions = function (
                                        engine,
                                        pairs,
                                        context
                                    ) {
                                        var c = context,
                                            options = engine.render.options,
                                            pair,
                                            collision,
                                            corrected,
                                            bodyA,
                                            bodyB,
                                            i,
                                            j;

                                        c.beginPath();

                                        // render collision positions
                                        for (i = 0; i < pairs.length; i++) {
                                            pair = pairs[i];

                                            if (!pair.isActive) continue;

                                            collision = pair.collision;
                                            for (
                                                j = 0;
                                                j < pair.activeContacts.length;
                                                j++
                                            ) {
                                                var contact =
                                                        pair.activeContacts[j],
                                                    vertex = contact.vertex;
                                                c.rect(
                                                    vertex.x - 1.5,
                                                    vertex.y - 1.5,
                                                    3.5,
                                                    3.5
                                                );
                                            }
                                        }

                                        if (options.wireframes) {
                                            c.fillStyle =
                                                "rgba(255,255,255,0.7)";
                                        } else {
                                            c.fillStyle = "orange";
                                        }
                                        c.fill();

                                        c.beginPath();

                                        // render collision normals
                                        for (i = 0; i < pairs.length; i++) {
                                            pair = pairs[i];

                                            if (!pair.isActive) continue;

                                            collision = pair.collision;

                                            if (
                                                pair.activeContacts.length > 0
                                            ) {
                                                var normalPosX =
                                                        pair.activeContacts[0]
                                                            .vertex.x,
                                                    normalPosY =
                                                        pair.activeContacts[0]
                                                            .vertex.y;

                                                if (
                                                    pair.activeContacts
                                                        .length === 2
                                                ) {
                                                    normalPosX =
                                                        (pair.activeContacts[0]
                                                            .vertex.x +
                                                            pair
                                                                .activeContacts[1]
                                                                .vertex.x) /
                                                        2;
                                                    normalPosY =
                                                        (pair.activeContacts[0]
                                                            .vertex.y +
                                                            pair
                                                                .activeContacts[1]
                                                                .vertex.y) /
                                                        2;
                                                }

                                                if (
                                                    collision.bodyB ===
                                                        collision.supports[0]
                                                            .body ||
                                                    collision.bodyA.isStatic ===
                                                        true
                                                ) {
                                                    c.moveTo(
                                                        normalPosX -
                                                            collision.normal.x *
                                                                8,
                                                        normalPosY -
                                                            collision.normal.y *
                                                                8
                                                    );
                                                } else {
                                                    c.moveTo(
                                                        normalPosX +
                                                            collision.normal.x *
                                                                8,
                                                        normalPosY +
                                                            collision.normal.y *
                                                                8
                                                    );
                                                }

                                                c.lineTo(
                                                    normalPosX,
                                                    normalPosY
                                                );
                                            }
                                        }

                                        if (options.wireframes) {
                                            c.strokeStyle =
                                                "rgba(255,165,0,0.7)";
                                        } else {
                                            c.strokeStyle = "orange";
                                        }

                                        c.lineWidth = 1;
                                        c.stroke();
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method separations
                                     * @param {engine} engine
                                     * @param {pair[]} pairs
                                     * @param {RenderingContext} context
                                     */
                                    Render.separations = function (
                                        engine,
                                        pairs,
                                        context
                                    ) {
                                        var c = context,
                                            options = engine.render.options,
                                            pair,
                                            collision,
                                            corrected,
                                            bodyA,
                                            bodyB,
                                            i,
                                            j;

                                        c.beginPath();

                                        // render separations
                                        for (i = 0; i < pairs.length; i++) {
                                            pair = pairs[i];

                                            if (!pair.isActive) continue;

                                            collision = pair.collision;
                                            bodyA = collision.bodyA;
                                            bodyB = collision.bodyB;

                                            var k = 1;

                                            if (
                                                !bodyB.isStatic &&
                                                !bodyA.isStatic
                                            )
                                                k = 0.5;
                                            if (bodyB.isStatic) k = 0;

                                            c.moveTo(
                                                bodyB.position.x,
                                                bodyB.position.y
                                            );
                                            c.lineTo(
                                                bodyB.position.x -
                                                    collision.penetration.x * k,
                                                bodyB.position.y -
                                                    collision.penetration.y * k
                                            );

                                            k = 1;

                                            if (
                                                !bodyB.isStatic &&
                                                !bodyA.isStatic
                                            )
                                                k = 0.5;
                                            if (bodyA.isStatic) k = 0;

                                            c.moveTo(
                                                bodyA.position.x,
                                                bodyA.position.y
                                            );
                                            c.lineTo(
                                                bodyA.position.x +
                                                    collision.penetration.x * k,
                                                bodyA.position.y +
                                                    collision.penetration.y * k
                                            );
                                        }

                                        if (options.wireframes) {
                                            c.strokeStyle =
                                                "rgba(255,165,0,0.5)";
                                        } else {
                                            c.strokeStyle = "orange";
                                        }
                                        c.stroke();
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method grid
                                     * @param {engine} engine
                                     * @param {grid} grid
                                     * @param {RenderingContext} context
                                     */
                                    Render.grid = function (
                                        engine,
                                        grid,
                                        context
                                    ) {
                                        var c = context,
                                            options = engine.render.options;

                                        if (options.wireframes) {
                                            c.strokeStyle =
                                                "rgba(255,180,0,0.1)";
                                        } else {
                                            c.strokeStyle =
                                                "rgba(255,180,0,0.5)";
                                        }

                                        c.beginPath();

                                        var bucketKeys = Common.keys(
                                            grid.buckets
                                        );

                                        for (
                                            var i = 0;
                                            i < bucketKeys.length;
                                            i++
                                        ) {
                                            var bucketId = bucketKeys[i];

                                            if (
                                                grid.buckets[bucketId].length <
                                                2
                                            )
                                                continue;

                                            var region = bucketId.split(",");
                                            c.rect(
                                                0.5 +
                                                    parseInt(region[0], 10) *
                                                        grid.bucketWidth,
                                                0.5 +
                                                    parseInt(region[1], 10) *
                                                        grid.bucketHeight,
                                                grid.bucketWidth,
                                                grid.bucketHeight
                                            );
                                        }

                                        c.lineWidth = 1;
                                        c.stroke();
                                    };

                                    /**
                                     * Description
                                     * @private
                                     * @method inspector
                                     * @param {inspector} inspector
                                     * @param {RenderingContext} context
                                     */
                                    Render.inspector = function (
                                        inspector,
                                        context
                                    ) {
                                        var engine = inspector.engine,
                                            selected = inspector.selected,
                                            render = engine.render,
                                            options = render.options,
                                            bounds;

                                        if (options.hasBounds) {
                                            var boundsWidth =
                                                    render.bounds.max.x -
                                                    render.bounds.min.x,
                                                boundsHeight =
                                                    render.bounds.max.y -
                                                    render.bounds.min.y,
                                                boundsScaleX =
                                                    boundsWidth /
                                                    render.options.width,
                                                boundsScaleY =
                                                    boundsHeight /
                                                    render.options.height;

                                            context.scale(
                                                1 / boundsScaleX,
                                                1 / boundsScaleY
                                            );
                                            context.translate(
                                                -render.bounds.min.x,
                                                -render.bounds.min.y
                                            );
                                        }

                                        for (
                                            var i = 0;
                                            i < selected.length;
                                            i++
                                        ) {
                                            var item = selected[i].data;

                                            context.translate(0.5, 0.5);
                                            context.lineWidth = 1;
                                            context.strokeStyle =
                                                "rgba(255,165,0,0.9)";
                                            context.setLineDash([1, 2]);

                                            switch (item.type) {
                                                case "body":
                                                    // render body selections
                                                    bounds = item.bounds;
                                                    context.beginPath();
                                                    context.rect(
                                                        Math.floor(
                                                            bounds.min.x - 3
                                                        ),
                                                        Math.floor(
                                                            bounds.min.y - 3
                                                        ),
                                                        Math.floor(
                                                            bounds.max.x -
                                                                bounds.min.x +
                                                                6
                                                        ),
                                                        Math.floor(
                                                            bounds.max.y -
                                                                bounds.min.y +
                                                                6
                                                        )
                                                    );
                                                    context.closePath();
                                                    context.stroke();

                                                    break;

                                                case "constraint":
                                                    // render constraint selections
                                                    var point = item.pointA;
                                                    if (item.bodyA)
                                                        point = item.pointB;
                                                    context.beginPath();
                                                    context.arc(
                                                        point.x,
                                                        point.y,
                                                        10,
                                                        0,
                                                        2 * Math.PI
                                                    );
                                                    context.closePath();
                                                    context.stroke();

                                                    break;
                                            }

                                            context.setLineDash([]);
                                            context.translate(-0.5, -0.5);
                                        }

                                        // render selection region
                                        if (inspector.selectStart !== null) {
                                            context.translate(0.5, 0.5);
                                            context.lineWidth = 1;
                                            context.strokeStyle =
                                                "rgba(255,165,0,0.6)";
                                            context.fillStyle =
                                                "rgba(255,165,0,0.1)";
                                            bounds = inspector.selectBounds;
                                            context.beginPath();
                                            context.rect(
                                                Math.floor(bounds.min.x),
                                                Math.floor(bounds.min.y),
                                                Math.floor(
                                                    bounds.max.x - bounds.min.x
                                                ),
                                                Math.floor(
                                                    bounds.max.y - bounds.min.y
                                                )
                                            );
                                            context.closePath();
                                            context.stroke();
                                            context.fill();
                                            context.translate(-0.5, -0.5);
                                        }

                                        if (options.hasBounds)
                                            context.setTransform(
                                                1,
                                                0,
                                                0,
                                                1,
                                                0,
                                                0
                                            );
                                    };

                                    /**
                                     * Description
                                     * @method _createCanvas
                                     * @private
                                     * @param {} width
                                     * @param {} height
                                     * @return canvas
                                     */
                                    var _createCanvas = function (
                                        width,
                                        height
                                    ) {
                                        var canvas =
                                            document.createElement("canvas");
                                        canvas.width = width;
                                        canvas.height = height;
                                        canvas.oncontextmenu = function () {
                                            return false;
                                        };
                                        canvas.onselectstart = function () {
                                            return false;
                                        };
                                        return canvas;
                                    };

                                    /**
                                     * Gets the pixel ratio of the canvas.
                                     * @method _getPixelRatio
                                     * @private
                                     * @param {HTMLElement} canvas
                                     * @return {Number} pixel ratio
                                     */
                                    var _getPixelRatio = function (canvas) {
                                        var context = canvas.getContext("2d"),
                                            devicePixelRatio =
                                                window.devicePixelRatio || 1,
                                            backingStorePixelRatio =
                                                context.webkitBackingStorePixelRatio ||
                                                context.mozBackingStorePixelRatio ||
                                                context.msBackingStorePixelRatio ||
                                                context.oBackingStorePixelRatio ||
                                                context.backingStorePixelRatio ||
                                                1;

                                        return (
                                            devicePixelRatio /
                                            backingStorePixelRatio
                                        );
                                    };

                                    /**
                                     * Gets the requested texture (an Image) via its path
                                     * @method _getTexture
                                     * @private
                                     * @param {render} render
                                     * @param {string} imagePath
                                     * @return {Image} texture
                                     */
                                    var _getTexture = function (
                                        render,
                                        imagePath
                                    ) {
                                        var image = render.textures[imagePath];

                                        if (image) return image;

                                        image = render.textures[imagePath] =
                                            new Image();
                                        image.src = imagePath;

                                        return image;
                                    };

                                    /**
                                     * Applies the background to the canvas using CSS.
                                     * @method applyBackground
                                     * @private
                                     * @param {render} render
                                     * @param {string} background
                                     */
                                    var _applyBackground = function (
                                        render,
                                        background
                                    ) {
                                        var cssBackground = background;

                                        if (/(jpg|gif|png)$/.test(background))
                                            cssBackground =
                                                "url(" + background + ")";

                                        render.canvas.style.background =
                                            cssBackground;
                                        render.canvas.style.backgroundSize =
                                            "contain";
                                        render.currentBackground = background;
                                    };

                                    /*
                                     *
                                     *  Events Documentation
                                     *
                                     */

                                    /**
                                     * Fired before rendering
                                     *
                                     * @event beforeRender
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /**
                                     * Fired after rendering
                                     *
                                     * @event afterRender
                                     * @param {} event An event object
                                     * @param {number} event.timestamp The engine.timing.timestamp of the event
                                     * @param {} event.source The source object of the event
                                     * @param {} event.name The name of the event
                                     */

                                    /*
                                     *
                                     *  Properties Documentation
                                     *
                                     */

                                    /**
                                     * A back-reference to the `Matter.Render` module.
                                     *
                                     * @property controller
                                     * @type render
                                     */

                                    /**
                                     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
                                     *
                                     * @property element
                                     * @type HTMLElement
                                     * @default null
                                     */

                                    /**
                                     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
                                     *
                                     * @property canvas
                                     * @type HTMLCanvasElement
                                     * @default null
                                     */

                                    /**
                                     * The configuration options of the renderer.
                                     *
                                     * @property options
                                     * @type {}
                                     */

                                    /**
                                     * The target width in pixels of the `render.canvas` to be created.
                                     *
                                     * @property options.width
                                     * @type number
                                     * @default 800
                                     */

                                    /**
                                     * The target height in pixels of the `render.canvas` to be created.
                                     *
                                     * @property options.height
                                     * @type number
                                     * @default 600
                                     */

                                    /**
                                     * A flag that specifies if `render.bounds` should be used when rendering.
                                     *
                                     * @property options.hasBounds
                                     * @type boolean
                                     * @default false
                                     */

                                    /**
                                     * A `Bounds` object that specifies the drawing view region.
                                     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
                                     * This allows for creating views that can pan or zoom around the scene.
                                     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
                                     *
                                     * @property bounds
                                     * @type bounds
                                     */

                                    /**
                                     * The 2d rendering context from the `render.canvas` element.
                                     *
                                     * @property context
                                     * @type CanvasRenderingContext2D
                                     */

                                    /**
                                     * The sprite texture cache.
                                     *
                                     * @property textures
                                     * @type {}
                                     */
                                })();
                            },
                            {
                                "../body/Composite": 2,
                                "../collision/Grid": 6,
                                "../core/Common": 14,
                                "../core/Events": 16,
                                "../geometry/Bounds": 24,
                                "../geometry/Vector": 26,
                            },
                        ],
                        30: [
                            function (require, module, exports) {
                                /**
                                 * The `Matter.RenderPixi` module is an example renderer using pixi.js.
                                 * See also `Matter.Render` for a canvas based renderer.
                                 *
                                 * @class RenderPixi
                                 */

                                var RenderPixi = {};

                                module.exports = RenderPixi;

                                var Composite = require("../body/Composite");
                                var Common = require("../core/Common");

                                (function () {
                                    /**
                                     * Creates a new Pixi.js WebGL renderer
                                     * @method create
                                     * @param {object} options
                                     * @return {RenderPixi} A new renderer
                                     */
                                    RenderPixi.create = function (options) {
                                        var defaults = {
                                            controller: RenderPixi,
                                            element: null,
                                            canvas: null,
                                            renderer: null,
                                            container: null,
                                            spriteContainer: null,
                                            pixiOptions: null,
                                            options: {
                                                width: 800,
                                                height: 600,
                                                background: "#fafafa",
                                                wireframeBackground: "#222",
                                                hasBounds: false,
                                                enabled: true,
                                                wireframes: true,
                                                showSleeping: true,
                                                showDebug: false,
                                                showBroadphase: false,
                                                showBounds: false,
                                                showVelocity: false,
                                                showCollisions: false,
                                                showAxes: false,
                                                showPositions: false,
                                                showAngleIndicator: false,
                                                showIds: false,
                                                showShadows: false,
                                            },
                                        };

                                        var render = Common.extend(
                                                defaults,
                                                options
                                            ),
                                            transparent =
                                                !render.options.wireframes &&
                                                render.options.background ===
                                                    "transparent";

                                        // init pixi
                                        render.pixiOptions =
                                            render.pixiOptions || {
                                                view: render.canvas,
                                                transparent: transparent,
                                                antialias: true,
                                                backgroundColor:
                                                    options.background,
                                            };

                                        render.renderer =
                                            render.renderer ||
                                            new PIXI.WebGLRenderer(
                                                render.options.width,
                                                render.options.height,
                                                render.pixiOptions
                                            );
                                        render.container =
                                            render.container ||
                                            new PIXI.Container();
                                        render.spriteContainer =
                                            render.spriteContainer ||
                                            new PIXI.Container();
                                        render.canvas =
                                            render.canvas ||
                                            render.renderer.view;
                                        render.bounds = render.bounds || {
                                            min: {
                                                x: 0,
                                                y: 0,
                                            },
                                            max: {
                                                x: render.options.width,
                                                y: render.options.height,
                                            },
                                        };

                                        // caches
                                        render.textures = {};
                                        render.sprites = {};
                                        render.primitives = {};

                                        // use a sprite batch for performance
                                        render.container.addChild(
                                            render.spriteContainer
                                        );

                                        // insert canvas
                                        if (Common.isElement(render.element)) {
                                            render.element.appendChild(
                                                render.canvas
                                            );
                                        } else {
                                            Common.log(
                                                'No "render.element" passed, "render.canvas" was not inserted into document.',
                                                "warn"
                                            );
                                        }

                                        // prevent menus on canvas
                                        render.canvas.oncontextmenu =
                                            function () {
                                                return false;
                                            };
                                        render.canvas.onselectstart =
                                            function () {
                                                return false;
                                            };

                                        return render;
                                    };

                                    /**
                                     * Clears the scene graph
                                     * @method clear
                                     * @param {RenderPixi} render
                                     */
                                    RenderPixi.clear = function (render) {
                                        var container = render.container,
                                            spriteContainer =
                                                render.spriteContainer;

                                        // clear stage container
                                        while (container.children[0]) {
                                            container.removeChild(
                                                container.children[0]
                                            );
                                        }

                                        // clear sprite batch
                                        while (spriteContainer.children[0]) {
                                            spriteContainer.removeChild(
                                                spriteContainer.children[0]
                                            );
                                        }

                                        var bgSprite = render.sprites["bg-0"];

                                        // clear caches
                                        render.textures = {};
                                        render.sprites = {};
                                        render.primitives = {};

                                        // set background sprite
                                        render.sprites["bg-0"] = bgSprite;
                                        if (bgSprite)
                                            container.addChildAt(bgSprite, 0);

                                        // add sprite batch back into container
                                        render.container.addChild(
                                            render.spriteContainer
                                        );

                                        // reset background state
                                        render.currentBackground = null;

                                        // reset bounds transforms
                                        container.scale.set(1, 1);
                                        container.position.set(0, 0);
                                    };

                                    /**
                                     * Sets the background of the canvas
                                     * @method setBackground
                                     * @param {RenderPixi} render
                                     * @param {string} background
                                     */
                                    RenderPixi.setBackground = function (
                                        render,
                                        background
                                    ) {
                                        if (
                                            render.currentBackground !==
                                            background
                                        ) {
                                            var isColor =
                                                    background.indexOf &&
                                                    background.indexOf("#") !==
                                                        -1,
                                                bgSprite =
                                                    render.sprites["bg-0"];

                                            if (isColor) {
                                                // if solid background color
                                                var color =
                                                    Common.colorToNumber(
                                                        background
                                                    );
                                                render.renderer.backgroundColor =
                                                    color;

                                                // remove background sprite if existing
                                                if (bgSprite)
                                                    render.container.removeChild(
                                                        bgSprite
                                                    );
                                            } else {
                                                // initialise background sprite if needed
                                                if (!bgSprite) {
                                                    var texture = _getTexture(
                                                        render,
                                                        background
                                                    );

                                                    bgSprite = render.sprites[
                                                        "bg-0"
                                                    ] = new PIXI.Sprite(
                                                        texture
                                                    );
                                                    bgSprite.position.x = 0;
                                                    bgSprite.position.y = 0;
                                                    render.container.addChildAt(
                                                        bgSprite,
                                                        0
                                                    );
                                                }
                                            }

                                            render.currentBackground =
                                                background;
                                        }
                                    };

                                    /**
                                     * Description
                                     * @method world
                                     * @param {engine} engine
                                     */
                                    RenderPixi.world = function (engine) {
                                        var render = engine.render,
                                            world = engine.world,
                                            renderer = render.renderer,
                                            container = render.container,
                                            options = render.options,
                                            bodies = Composite.allBodies(world),
                                            allConstraints =
                                                Composite.allConstraints(world),
                                            constraints = [],
                                            i;

                                        if (options.wireframes) {
                                            RenderPixi.setBackground(
                                                render,
                                                options.wireframeBackground
                                            );
                                        } else {
                                            RenderPixi.setBackground(
                                                render,
                                                options.background
                                            );
                                        }

                                        // handle bounds
                                        var boundsWidth =
                                                render.bounds.max.x -
                                                render.bounds.min.x,
                                            boundsHeight =
                                                render.bounds.max.y -
                                                render.bounds.min.y,
                                            boundsScaleX =
                                                boundsWidth /
                                                render.options.width,
                                            boundsScaleY =
                                                boundsHeight /
                                                render.options.height;

                                        if (options.hasBounds) {
                                            // Hide bodies that are not in view
                                            for (
                                                i = 0;
                                                i < bodies.length;
                                                i++
                                            ) {
                                                var body = bodies[i];
                                                body.render.sprite.visible =
                                                    Bounds.overlaps(
                                                        body.bounds,
                                                        render.bounds
                                                    );
                                            }

                                            // filter out constraints that are not in view
                                            for (
                                                i = 0;
                                                i < allConstraints.length;
                                                i++
                                            ) {
                                                var constraint =
                                                        allConstraints[i],
                                                    bodyA = constraint.bodyA,
                                                    bodyB = constraint.bodyB,
                                                    pointAWorld =
                                                        constraint.pointA,
                                                    pointBWorld =
                                                        constraint.pointB;

                                                if (bodyA)
                                                    pointAWorld = Vector.add(
                                                        bodyA.position,
                                                        constraint.pointA
                                                    );
                                                if (bodyB)
                                                    pointBWorld = Vector.add(
                                                        bodyB.position,
                                                        constraint.pointB
                                                    );

                                                if (
                                                    !pointAWorld ||
                                                    !pointBWorld
                                                )
                                                    continue;

                                                if (
                                                    Bounds.contains(
                                                        render.bounds,
                                                        pointAWorld
                                                    ) ||
                                                    Bounds.contains(
                                                        render.bounds,
                                                        pointBWorld
                                                    )
                                                )
                                                    constraints.push(
                                                        constraint
                                                    );
                                            }

                                            // transform the view
                                            container.scale.set(
                                                1 / boundsScaleX,
                                                1 / boundsScaleY
                                            );
                                            container.position.set(
                                                -render.bounds.min.x *
                                                    (1 / boundsScaleX),
                                                -render.bounds.min.y *
                                                    (1 / boundsScaleY)
                                            );
                                        } else {
                                            constraints = allConstraints;
                                        }

                                        for (i = 0; i < bodies.length; i++)
                                            RenderPixi.body(engine, bodies[i]);

                                        for (i = 0; i < constraints.length; i++)
                                            RenderPixi.constraint(
                                                engine,
                                                constraints[i]
                                            );

                                        renderer.render(container);
                                    };

                                    /**
                                     * Description
                                     * @method constraint
                                     * @param {engine} engine
                                     * @param {constraint} constraint
                                     */
                                    RenderPixi.constraint = function (
                                        engine,
                                        constraint
                                    ) {
                                        var render = engine.render,
                                            bodyA = constraint.bodyA,
                                            bodyB = constraint.bodyB,
                                            pointA = constraint.pointA,
                                            pointB = constraint.pointB,
                                            container = render.container,
                                            constraintRender =
                                                constraint.render,
                                            primitiveId = "c-" + constraint.id,
                                            primitive =
                                                render.primitives[primitiveId];

                                        // initialise constraint primitive if not existing
                                        if (!primitive)
                                            primitive = render.primitives[
                                                primitiveId
                                            ] = new PIXI.Graphics();

                                        // don't render if constraint does not have two end points
                                        if (
                                            !constraintRender.visible ||
                                            !constraint.pointA ||
                                            !constraint.pointB
                                        ) {
                                            primitive.clear();
                                            return;
                                        }

                                        // add to scene graph if not already there
                                        if (
                                            Common.indexOf(
                                                container.children,
                                                primitive
                                            ) === -1
                                        )
                                            container.addChild(primitive);

                                        // render the constraint on every update, since they can change dynamically
                                        primitive.clear();
                                        primitive.beginFill(0, 0);
                                        primitive.lineStyle(
                                            constraintRender.lineWidth,
                                            Common.colorToNumber(
                                                constraintRender.strokeStyle
                                            ),
                                            1
                                        );

                                        if (bodyA) {
                                            primitive.moveTo(
                                                bodyA.position.x + pointA.x,
                                                bodyA.position.y + pointA.y
                                            );
                                        } else {
                                            primitive.moveTo(
                                                pointA.x,
                                                pointA.y
                                            );
                                        }

                                        if (bodyB) {
                                            primitive.lineTo(
                                                bodyB.position.x + pointB.x,
                                                bodyB.position.y + pointB.y
                                            );
                                        } else {
                                            primitive.lineTo(
                                                pointB.x,
                                                pointB.y
                                            );
                                        }

                                        primitive.endFill();
                                    };

                                    /**
                                     * Description
                                     * @method body
                                     * @param {engine} engine
                                     * @param {body} body
                                     */
                                    RenderPixi.body = function (engine, body) {
                                        var render = engine.render,
                                            bodyRender = body.render;

                                        if (!bodyRender.visible) return;

                                        if (
                                            bodyRender.sprite &&
                                            bodyRender.sprite.texture
                                        ) {
                                            var spriteId = "b-" + body.id,
                                                sprite =
                                                    render.sprites[spriteId],
                                                spriteContainer =
                                                    render.spriteContainer;

                                            // initialise body sprite if not existing
                                            if (!sprite)
                                                sprite = render.sprites[
                                                    spriteId
                                                ] = _createBodySprite(
                                                    render,
                                                    body
                                                );

                                            // add to scene graph if not already there
                                            if (
                                                Common.indexOf(
                                                    spriteContainer.children,
                                                    sprite
                                                ) === -1
                                            )
                                                spriteContainer.addChild(
                                                    sprite
                                                );

                                            // update body sprite
                                            sprite.position.x = body.position.x;
                                            sprite.position.y = body.position.y;
                                            sprite.rotation = body.angle;
                                            sprite.scale.x =
                                                bodyRender.sprite.xScale || 1;
                                            sprite.scale.y =
                                                bodyRender.sprite.yScale || 1;
                                        } else {
                                            var primitiveId = "b-" + body.id,
                                                primitive =
                                                    render.primitives[
                                                        primitiveId
                                                    ],
                                                container = render.container;

                                            // initialise body primitive if not existing
                                            if (!primitive) {
                                                primitive = render.primitives[
                                                    primitiveId
                                                ] = _createBodyPrimitive(
                                                    render,
                                                    body
                                                );
                                                primitive.initialAngle =
                                                    body.angle;
                                            }

                                            // add to scene graph if not already there
                                            if (
                                                Common.indexOf(
                                                    container.children,
                                                    primitive
                                                ) === -1
                                            )
                                                container.addChild(primitive);

                                            // update body primitive
                                            primitive.position.x =
                                                body.position.x;
                                            primitive.position.y =
                                                body.position.y;
                                            primitive.rotation =
                                                body.angle -
                                                primitive.initialAngle;
                                        }
                                    };

                                    /**
                                     * Creates a body sprite
                                     * @method _createBodySprite
                                     * @private
                                     * @param {RenderPixi} render
                                     * @param {body} body
                                     * @return {PIXI.Sprite} sprite
                                     */
                                    var _createBodySprite = function (
                                        render,
                                        body
                                    ) {
                                        var bodyRender = body.render,
                                            texturePath =
                                                bodyRender.sprite.texture,
                                            texture = _getTexture(
                                                render,
                                                texturePath
                                            ),
                                            sprite = new PIXI.Sprite(texture);

                                        sprite.anchor.x =
                                            body.render.sprite.xOffset;
                                        sprite.anchor.y =
                                            body.render.sprite.yOffset;

                                        return sprite;
                                    };

                                    /**
                                     * Creates a body primitive
                                     * @method _createBodyPrimitive
                                     * @private
                                     * @param {RenderPixi} render
                                     * @param {body} body
                                     * @return {PIXI.Graphics} graphics
                                     */
                                    var _createBodyPrimitive = function (
                                        render,
                                        body
                                    ) {
                                        var bodyRender = body.render,
                                            options = render.options,
                                            primitive = new PIXI.Graphics(),
                                            fillStyle = Common.colorToNumber(
                                                bodyRender.fillStyle
                                            ),
                                            strokeStyle = Common.colorToNumber(
                                                bodyRender.strokeStyle
                                            ),
                                            strokeStyleIndicator =
                                                Common.colorToNumber(
                                                    bodyRender.strokeStyle
                                                ),
                                            strokeStyleWireframe =
                                                Common.colorToNumber("#bbb"),
                                            strokeStyleWireframeIndicator =
                                                Common.colorToNumber("#CD5C5C"),
                                            part;

                                        primitive.clear();

                                        // handle compound parts
                                        for (
                                            var k =
                                                body.parts.length > 1 ? 1 : 0;
                                            k < body.parts.length;
                                            k++
                                        ) {
                                            part = body.parts[k];

                                            if (!options.wireframes) {
                                                primitive.beginFill(
                                                    fillStyle,
                                                    1
                                                );
                                                primitive.lineStyle(
                                                    bodyRender.lineWidth,
                                                    strokeStyle,
                                                    1
                                                );
                                            } else {
                                                primitive.beginFill(0, 0);
                                                primitive.lineStyle(
                                                    1,
                                                    strokeStyleWireframe,
                                                    1
                                                );
                                            }

                                            primitive.moveTo(
                                                part.vertices[0].x -
                                                    body.position.x,
                                                part.vertices[0].y -
                                                    body.position.y
                                            );

                                            for (
                                                var j = 1;
                                                j < part.vertices.length;
                                                j++
                                            ) {
                                                primitive.lineTo(
                                                    part.vertices[j].x -
                                                        body.position.x,
                                                    part.vertices[j].y -
                                                        body.position.y
                                                );
                                            }

                                            primitive.lineTo(
                                                part.vertices[0].x -
                                                    body.position.x,
                                                part.vertices[0].y -
                                                    body.position.y
                                            );

                                            primitive.endFill();

                                            // angle indicator
                                            if (
                                                options.showAngleIndicator ||
                                                options.showAxes
                                            ) {
                                                primitive.beginFill(0, 0);

                                                if (options.wireframes) {
                                                    primitive.lineStyle(
                                                        1,
                                                        strokeStyleWireframeIndicator,
                                                        1
                                                    );
                                                } else {
                                                    primitive.lineStyle(
                                                        1,
                                                        strokeStyleIndicator
                                                    );
                                                }

                                                primitive.moveTo(
                                                    part.position.x -
                                                        body.position.x,
                                                    part.position.y -
                                                        body.position.y
                                                );
                                                primitive.lineTo(
                                                    (part.vertices[0].x +
                                                        part.vertices[
                                                            part.vertices
                                                                .length - 1
                                                        ].x) /
                                                        2 -
                                                        body.position.x,
                                                    (part.vertices[0].y +
                                                        part.vertices[
                                                            part.vertices
                                                                .length - 1
                                                        ].y) /
                                                        2 -
                                                        body.position.y
                                                );

                                                primitive.endFill();
                                            }
                                        }

                                        return primitive;
                                    };

                                    /**
                                     * Gets the requested texture (a PIXI.Texture) via its path
                                     * @method _getTexture
                                     * @private
                                     * @param {RenderPixi} render
                                     * @param {string} imagePath
                                     * @return {PIXI.Texture} texture
                                     */
                                    var _getTexture = function (
                                        render,
                                        imagePath
                                    ) {
                                        var texture =
                                            render.textures[imagePath];

                                        if (!texture)
                                            texture = render.textures[
                                                imagePath
                                            ] =
                                                PIXI.Texture.fromImage(
                                                    imagePath
                                                );

                                        return texture;
                                    };
                                })();
                            },
                            { "../body/Composite": 2, "../core/Common": 14 },
                        ],
                    },
                    {},
                    [28]
                )(28);
            });
        </script>

        <script>
            /*! @license Firebase v2.4.1
    License: https://www.firebase.com/terms/terms-of-service.html */
            (function () {
                var h,
                    n = this;
                function p(a) {
                    return void 0 !== a;
                }
                function aa() {}
                function ba(a) {
                    a.yb = function () {
                        return a.zf ? a.zf : (a.zf = new a());
                    };
                }
                function ca(a) {
                    var b = typeof a;
                    if ("object" == b)
                        if (a) {
                            if (a instanceof Array) return "array";
                            if (a instanceof Object) return b;
                            var c = Object.prototype.toString.call(a);
                            if ("[object Window]" == c) return "object";
                            if (
                                "[object Array]" == c ||
                                ("number" == typeof a.length &&
                                    "undefined" != typeof a.splice &&
                                    "undefined" !=
                                        typeof a.propertyIsEnumerable &&
                                    !a.propertyIsEnumerable("splice"))
                            )
                                return "array";
                            if (
                                "[object Function]" == c ||
                                ("undefined" != typeof a.call &&
                                    "undefined" !=
                                        typeof a.propertyIsEnumerable &&
                                    !a.propertyIsEnumerable("call"))
                            )
                                return "function";
                        } else return "null";
                    else if ("function" == b && "undefined" == typeof a.call)
                        return "object";
                    return b;
                }
                function da(a) {
                    return "array" == ca(a);
                }
                function ea(a) {
                    var b = ca(a);
                    return (
                        "array" == b ||
                        ("object" == b && "number" == typeof a.length)
                    );
                }
                function q(a) {
                    return "string" == typeof a;
                }
                function fa(a) {
                    return "number" == typeof a;
                }
                function r(a) {
                    return "function" == ca(a);
                }
                function ga(a) {
                    var b = typeof a;
                    return ("object" == b && null != a) || "function" == b;
                }
                function ha(a, b, c) {
                    return a.call.apply(a.bind, arguments);
                }
                function ia(a, b, c) {
                    if (!a) throw Error();
                    if (2 < arguments.length) {
                        var d = Array.prototype.slice.call(arguments, 2);
                        return function () {
                            var c = Array.prototype.slice.call(arguments);
                            Array.prototype.unshift.apply(c, d);
                            return a.apply(b, c);
                        };
                    }
                    return function () {
                        return a.apply(b, arguments);
                    };
                }
                function u(a, b, c) {
                    u =
                        Function.prototype.bind &&
                        -1 !=
                            Function.prototype.bind
                                .toString()
                                .indexOf("native code")
                            ? ha
                            : ia;
                    return u.apply(null, arguments);
                }
                var ja =
                    Date.now ||
                    function () {
                        return +new Date();
                    };
                function ka(a, b) {
                    function c() {}
                    c.prototype = b.prototype;
                    a.oh = b.prototype;
                    a.prototype = new c();
                    a.prototype.constructor = a;
                    a.kh = function (a, c, f) {
                        for (
                            var g = Array(arguments.length - 2), k = 2;
                            k < arguments.length;
                            k++
                        )
                            g[k - 2] = arguments[k];
                        return b.prototype[c].apply(a, g);
                    };
                }
                function la(a) {
                    if (Error.captureStackTrace)
                        Error.captureStackTrace(this, la);
                    else {
                        var b = Error().stack;
                        b && (this.stack = b);
                    }
                    a && (this.message = String(a));
                }
                ka(la, Error);
                la.prototype.name = "CustomError";
                function v(a, b) {
                    for (var c in a) b.call(void 0, a[c], c, a);
                }
                function ma(a, b) {
                    var c = {},
                        d;
                    for (d in a) c[d] = b.call(void 0, a[d], d, a);
                    return c;
                }
                function na(a, b) {
                    for (var c in a) if (!b.call(void 0, a[c], c, a)) return !1;
                    return !0;
                }
                function oa(a) {
                    var b = 0,
                        c;
                    for (c in a) b++;
                    return b;
                }
                function pa(a) {
                    for (var b in a) return b;
                }
                function qa(a) {
                    var b = [],
                        c = 0,
                        d;
                    for (d in a) b[c++] = a[d];
                    return b;
                }
                function ra(a) {
                    var b = [],
                        c = 0,
                        d;
                    for (d in a) b[c++] = d;
                    return b;
                }
                function sa(a, b) {
                    for (var c in a) if (a[c] == b) return !0;
                    return !1;
                }
                function ta(a, b, c) {
                    for (var d in a) if (b.call(c, a[d], d, a)) return d;
                }
                function ua(a, b) {
                    var c = ta(a, b, void 0);
                    return c && a[c];
                }
                function va(a) {
                    for (var b in a) return !1;
                    return !0;
                }
                function wa(a) {
                    var b = {},
                        c;
                    for (c in a) b[c] = a[c];
                    return b;
                }
                var xa =
                    "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(
                        " "
                    );
                function ya(a, b) {
                    for (var c, d, e = 1; e < arguments.length; e++) {
                        d = arguments[e];
                        for (c in d) a[c] = d[c];
                        for (var f = 0; f < xa.length; f++)
                            (c = xa[f]),
                                Object.prototype.hasOwnProperty.call(d, c) &&
                                    (a[c] = d[c]);
                    }
                }
                function za(a) {
                    a = String(a);
                    if (
                        /^\s*$/.test(a)
                            ? 0
                            : /^[\],:{}\s\u2028\u2029]*$/.test(
                                  a
                                      .replace(/\\["\\\/bfnrtu]/g, "@")
                                      .replace(
                                          /"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                                          "]"
                                      )
                                      .replace(
                                          /(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g,
                                          ""
                                      )
                              )
                    )
                        try {
                            return eval("(" + a + ")");
                        } catch (b) {}
                    throw Error("Invalid JSON string: " + a);
                }
                function Aa() {
                    this.Vd = void 0;
                }
                function Ba(a, b, c) {
                    switch (typeof b) {
                        case "string":
                            Ca(b, c);
                            break;
                        case "number":
                            c.push(isFinite(b) && !isNaN(b) ? b : "null");
                            break;
                        case "boolean":
                            c.push(b);
                            break;
                        case "undefined":
                            c.push("null");
                            break;
                        case "object":
                            if (null == b) {
                                c.push("null");
                                break;
                            }
                            if (da(b)) {
                                var d = b.length;
                                c.push("[");
                                for (var e = "", f = 0; f < d; f++)
                                    c.push(e),
                                        (e = b[f]),
                                        Ba(
                                            a,
                                            a.Vd
                                                ? a.Vd.call(b, String(f), e)
                                                : e,
                                            c
                                        ),
                                        (e = ",");
                                c.push("]");
                                break;
                            }
                            c.push("{");
                            d = "";
                            for (f in b)
                                Object.prototype.hasOwnProperty.call(b, f) &&
                                    ((e = b[f]),
                                    "function" != typeof e &&
                                        (c.push(d),
                                        Ca(f, c),
                                        c.push(":"),
                                        Ba(a, a.Vd ? a.Vd.call(b, f, e) : e, c),
                                        (d = ",")));
                            c.push("}");
                            break;
                        case "function":
                            break;
                        default:
                            throw Error("Unknown type: " + typeof b);
                    }
                }
                var Da = {
                        '"': '\\"',
                        "\\": "\\\\",
                        "/": "\\/",
                        "\b": "\\b",
                        "\f": "\\f",
                        "\n": "\\n",
                        "\r": "\\r",
                        "\t": "\\t",
                        "\x0B": "\\u000b",
                    },
                    Ea = /\uffff/.test("\uffff")
                        ? /[\\\"\x00-\x1f\x7f-\uffff]/g
                        : /[\\\"\x00-\x1f\x7f-\xff]/g;
                function Ca(a, b) {
                    b.push(
                        '"',
                        a.replace(Ea, function (a) {
                            if (a in Da) return Da[a];
                            var b = a.charCodeAt(0),
                                e = "\\u";
                            16 > b
                                ? (e += "000")
                                : 256 > b
                                ? (e += "00")
                                : 4096 > b && (e += "0");
                            return (Da[a] = e + b.toString(16));
                        }),
                        '"'
                    );
                }
                function Fa() {
                    return (
                        Math.floor(2147483648 * Math.random()).toString(36) +
                        Math.abs(
                            Math.floor(2147483648 * Math.random()) ^ ja()
                        ).toString(36)
                    );
                }
                var w;
                a: {
                    var Ga = n.navigator;
                    if (Ga) {
                        var Ha = Ga.userAgent;
                        if (Ha) {
                            w = Ha;
                            break a;
                        }
                    }
                    w = "";
                }
                function Ia() {
                    this.Ya = -1;
                }
                function Ja() {
                    this.Ya = -1;
                    this.Ya = 64;
                    this.P = [];
                    this.pe = [];
                    this.eg = [];
                    this.Od = [];
                    this.Od[0] = 128;
                    for (var a = 1; a < this.Ya; ++a) this.Od[a] = 0;
                    this.ge = this.ec = 0;
                    this.reset();
                }
                ka(Ja, Ia);
                Ja.prototype.reset = function () {
                    this.P[0] = 1732584193;
                    this.P[1] = 4023233417;
                    this.P[2] = 2562383102;
                    this.P[3] = 271733878;
                    this.P[4] = 3285377520;
                    this.ge = this.ec = 0;
                };
                function Ka(a, b, c) {
                    c || (c = 0);
                    var d = a.eg;
                    if (q(b))
                        for (var e = 0; 16 > e; e++)
                            (d[e] =
                                (b.charCodeAt(c) << 24) |
                                (b.charCodeAt(c + 1) << 16) |
                                (b.charCodeAt(c + 2) << 8) |
                                b.charCodeAt(c + 3)),
                                (c += 4);
                    else
                        for (e = 0; 16 > e; e++)
                            (d[e] =
                                (b[c] << 24) |
                                (b[c + 1] << 16) |
                                (b[c + 2] << 8) |
                                b[c + 3]),
                                (c += 4);
                    for (e = 16; 80 > e; e++) {
                        var f = d[e - 3] ^ d[e - 8] ^ d[e - 14] ^ d[e - 16];
                        d[e] = ((f << 1) | (f >>> 31)) & 4294967295;
                    }
                    b = a.P[0];
                    c = a.P[1];
                    for (
                        var g = a.P[2], k = a.P[3], m = a.P[4], l, e = 0;
                        80 > e;
                        e++
                    )
                        40 > e
                            ? 20 > e
                                ? ((f = k ^ (c & (g ^ k))), (l = 1518500249))
                                : ((f = c ^ g ^ k), (l = 1859775393))
                            : 60 > e
                            ? ((f = (c & g) | (k & (c | g))), (l = 2400959708))
                            : ((f = c ^ g ^ k), (l = 3395469782)),
                            (f =
                                (((b << 5) | (b >>> 27)) + f + m + l + d[e]) &
                                4294967295),
                            (m = k),
                            (k = g),
                            (g = ((c << 30) | (c >>> 2)) & 4294967295),
                            (c = b),
                            (b = f);
                    a.P[0] = (a.P[0] + b) & 4294967295;
                    a.P[1] = (a.P[1] + c) & 4294967295;
                    a.P[2] = (a.P[2] + g) & 4294967295;
                    a.P[3] = (a.P[3] + k) & 4294967295;
                    a.P[4] = (a.P[4] + m) & 4294967295;
                }
                Ja.prototype.update = function (a, b) {
                    if (null != a) {
                        p(b) || (b = a.length);
                        for (
                            var c = b - this.Ya,
                                d = 0,
                                e = this.pe,
                                f = this.ec;
                            d < b;

                        ) {
                            if (0 == f)
                                for (; d <= c; ) Ka(this, a, d), (d += this.Ya);
                            if (q(a))
                                for (; d < b; ) {
                                    if (
                                        ((e[f] = a.charCodeAt(d)),
                                        ++f,
                                        ++d,
                                        f == this.Ya)
                                    ) {
                                        Ka(this, e);
                                        f = 0;
                                        break;
                                    }
                                }
                            else
                                for (; d < b; )
                                    if (
                                        ((e[f] = a[d]), ++f, ++d, f == this.Ya)
                                    ) {
                                        Ka(this, e);
                                        f = 0;
                                        break;
                                    }
                        }
                        this.ec = f;
                        this.ge += b;
                    }
                };
                var x = Array.prototype,
                    La = x.indexOf
                        ? function (a, b, c) {
                              return x.indexOf.call(a, b, c);
                          }
                        : function (a, b, c) {
                              c =
                                  null == c
                                      ? 0
                                      : 0 > c
                                      ? Math.max(0, a.length + c)
                                      : c;
                              if (q(a))
                                  return q(b) && 1 == b.length
                                      ? a.indexOf(b, c)
                                      : -1;
                              for (; c < a.length; c++)
                                  if (c in a && a[c] === b) return c;
                              return -1;
                          },
                    Ma = x.forEach
                        ? function (a, b, c) {
                              x.forEach.call(a, b, c);
                          }
                        : function (a, b, c) {
                              for (
                                  var d = a.length,
                                      e = q(a) ? a.split("") : a,
                                      f = 0;
                                  f < d;
                                  f++
                              )
                                  f in e && b.call(c, e[f], f, a);
                          },
                    Na = x.filter
                        ? function (a, b, c) {
                              return x.filter.call(a, b, c);
                          }
                        : function (a, b, c) {
                              for (
                                  var d = a.length,
                                      e = [],
                                      f = 0,
                                      g = q(a) ? a.split("") : a,
                                      k = 0;
                                  k < d;
                                  k++
                              )
                                  if (k in g) {
                                      var m = g[k];
                                      b.call(c, m, k, a) && (e[f++] = m);
                                  }
                              return e;
                          },
                    Oa = x.map
                        ? function (a, b, c) {
                              return x.map.call(a, b, c);
                          }
                        : function (a, b, c) {
                              for (
                                  var d = a.length,
                                      e = Array(d),
                                      f = q(a) ? a.split("") : a,
                                      g = 0;
                                  g < d;
                                  g++
                              )
                                  g in f && (e[g] = b.call(c, f[g], g, a));
                              return e;
                          },
                    Pa = x.reduce
                        ? function (a, b, c, d) {
                              for (
                                  var e = [], f = 1, g = arguments.length;
                                  f < g;
                                  f++
                              )
                                  e.push(arguments[f]);
                              d && (e[0] = u(b, d));
                              return x.reduce.apply(a, e);
                          }
                        : function (a, b, c, d) {
                              var e = c;
                              Ma(a, function (c, g) {
                                  e = b.call(d, e, c, g, a);
                              });
                              return e;
                          },
                    Qa = x.every
                        ? function (a, b, c) {
                              return x.every.call(a, b, c);
                          }
                        : function (a, b, c) {
                              for (
                                  var d = a.length,
                                      e = q(a) ? a.split("") : a,
                                      f = 0;
                                  f < d;
                                  f++
                              )
                                  if (f in e && !b.call(c, e[f], f, a))
                                      return !1;
                              return !0;
                          };
                function Ra(a, b) {
                    var c = Sa(a, b, void 0);
                    return 0 > c ? null : q(a) ? a.charAt(c) : a[c];
                }
                function Sa(a, b, c) {
                    for (
                        var d = a.length, e = q(a) ? a.split("") : a, f = 0;
                        f < d;
                        f++
                    )
                        if (f in e && b.call(c, e[f], f, a)) return f;
                    return -1;
                }
                function Ta(a, b) {
                    var c = La(a, b);
                    0 <= c && x.splice.call(a, c, 1);
                }
                function Ua(a, b, c) {
                    return 2 >= arguments.length
                        ? x.slice.call(a, b)
                        : x.slice.call(a, b, c);
                }
                function Va(a, b) {
                    a.sort(b || Wa);
                }
                function Wa(a, b) {
                    return a > b ? 1 : a < b ? -1 : 0;
                }
                function Xa(a) {
                    n.setTimeout(function () {
                        throw a;
                    }, 0);
                }
                var Ya;
                function Za() {
                    var a = n.MessageChannel;
                    "undefined" === typeof a &&
                        "undefined" !== typeof window &&
                        window.postMessage &&
                        window.addEventListener &&
                        -1 == w.indexOf("Presto") &&
                        (a = function () {
                            var a = document.createElement("iframe");
                            a.style.display = "none";
                            a.src = "";
                            document.documentElement.appendChild(a);
                            var b = a.contentWindow,
                                a = b.document;
                            a.open();
                            a.write("");
                            a.close();
                            var c = "callImmediate" + Math.random(),
                                d =
                                    "file:" == b.location.protocol
                                        ? "*"
                                        : b.location.protocol +
                                          "//" +
                                          b.location.host,
                                a = u(function (a) {
                                    if (
                                        ("*" == d || a.origin == d) &&
                                        a.data == c
                                    )
                                        this.port1.onmessage();
                                }, this);
                            b.addEventListener("message", a, !1);
                            this.port1 = {};
                            this.port2 = {
                                postMessage: function () {
                                    b.postMessage(c, d);
                                },
                            };
                        });
                    if (
                        "undefined" !== typeof a &&
                        -1 == w.indexOf("Trident") &&
                        -1 == w.indexOf("MSIE")
                    ) {
                        var b = new a(),
                            c = {},
                            d = c;
                        b.port1.onmessage = function () {
                            if (p(c.next)) {
                                c = c.next;
                                var a = c.hb;
                                c.hb = null;
                                a();
                            }
                        };
                        return function (a) {
                            d.next = { hb: a };
                            d = d.next;
                            b.port2.postMessage(0);
                        };
                    }
                    return "undefined" !== typeof document &&
                        "onreadystatechange" in document.createElement("script")
                        ? function (a) {
                              var b = document.createElement("script");
                              b.onreadystatechange = function () {
                                  b.onreadystatechange = null;
                                  b.parentNode.removeChild(b);
                                  b = null;
                                  a();
                                  a = null;
                              };
                              document.documentElement.appendChild(b);
                          }
                        : function (a) {
                              n.setTimeout(a, 0);
                          };
                }
                function $a(a, b) {
                    ab || bb();
                    cb || (ab(), (cb = !0));
                    db.push(new eb(a, b));
                }
                var ab;
                function bb() {
                    if (n.Promise && n.Promise.resolve) {
                        var a = n.Promise.resolve();
                        ab = function () {
                            a.then(fb);
                        };
                    } else
                        ab = function () {
                            var a = fb;
                            !r(n.setImmediate) ||
                            (n.Window &&
                                n.Window.prototype &&
                                n.Window.prototype.setImmediate ==
                                    n.setImmediate)
                                ? (Ya || (Ya = Za()), Ya(a))
                                : n.setImmediate(a);
                        };
                }
                var cb = !1,
                    db = [];
                [].push(function () {
                    cb = !1;
                    db = [];
                });
                function fb() {
                    for (; db.length; ) {
                        var a = db;
                        db = [];
                        for (var b = 0; b < a.length; b++) {
                            var c = a[b];
                            try {
                                c.yg.call(c.scope);
                            } catch (d) {
                                Xa(d);
                            }
                        }
                    }
                    cb = !1;
                }
                function eb(a, b) {
                    this.yg = a;
                    this.scope = b;
                }
                var gb = -1 != w.indexOf("Opera") || -1 != w.indexOf("OPR"),
                    hb = -1 != w.indexOf("Trident") || -1 != w.indexOf("MSIE"),
                    ib =
                        -1 != w.indexOf("Gecko") &&
                        -1 == w.toLowerCase().indexOf("webkit") &&
                        !(
                            -1 != w.indexOf("Trident") ||
                            -1 != w.indexOf("MSIE")
                        ),
                    jb = -1 != w.toLowerCase().indexOf("webkit");
                (function () {
                    var a = "",
                        b;
                    if (gb && n.opera)
                        return (a = n.opera.version), r(a) ? a() : a;
                    ib
                        ? (b = /rv\:([^\);]+)(\)|;)/)
                        : hb
                        ? (b = /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/)
                        : jb && (b = /WebKit\/(\S+)/);
                    b && (a = (a = b.exec(w)) ? a[1] : "");
                    return hb &&
                        ((b = (b = n.document) ? b.documentMode : void 0),
                        b > parseFloat(a))
                        ? String(b)
                        : a;
                })();
                var kb = null,
                    lb = null,
                    mb = null;
                function nb(a, b) {
                    if (!ea(a))
                        throw Error(
                            "encodeByteArray takes an array as a parameter"
                        );
                    ob();
                    for (
                        var c = b ? lb : kb, d = [], e = 0;
                        e < a.length;
                        e += 3
                    ) {
                        var f = a[e],
                            g = e + 1 < a.length,
                            k = g ? a[e + 1] : 0,
                            m = e + 2 < a.length,
                            l = m ? a[e + 2] : 0,
                            t = f >> 2,
                            f = ((f & 3) << 4) | (k >> 4),
                            k = ((k & 15) << 2) | (l >> 6),
                            l = l & 63;
                        m || ((l = 64), g || (k = 64));
                        d.push(c[t], c[f], c[k], c[l]);
                    }
                    return d.join("");
                }
                function ob() {
                    if (!kb) {
                        kb = {};
                        lb = {};
                        mb = {};
                        for (var a = 0; 65 > a; a++)
                            (kb[a] =
                                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(
                                    a
                                )),
                                (lb[a] =
                                    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(
                                        a
                                    )),
                                (mb[lb[a]] = a),
                                62 <= a &&
                                    (mb[
                                        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(
                                            a
                                        )
                                    ] = a);
                    }
                }
                function pb(a, b) {
                    this.N = qb;
                    this.Rf = void 0;
                    this.Ba = this.Ha = null;
                    this.yd = this.ye = !1;
                    if (a == rb) sb(this, tb, b);
                    else
                        try {
                            var c = this;
                            a.call(
                                b,
                                function (a) {
                                    sb(c, tb, a);
                                },
                                function (a) {
                                    if (!(a instanceof ub))
                                        try {
                                            if (a instanceof Error) throw a;
                                            throw Error("Promise rejected.");
                                        } catch (b) {}
                                    sb(c, vb, a);
                                }
                            );
                        } catch (d) {
                            sb(this, vb, d);
                        }
                }
                var qb = 0,
                    tb = 2,
                    vb = 3;
                function rb() {}
                pb.prototype.then = function (a, b, c) {
                    return wb(this, r(a) ? a : null, r(b) ? b : null, c);
                };
                pb.prototype.then = pb.prototype.then;
                pb.prototype.$goog_Thenable = !0;
                h = pb.prototype;
                h.fh = function (a, b) {
                    return wb(this, null, a, b);
                };
                h.cancel = function (a) {
                    this.N == qb &&
                        $a(function () {
                            var b = new ub(a);
                            xb(this, b);
                        }, this);
                };
                function xb(a, b) {
                    if (a.N == qb)
                        if (a.Ha) {
                            var c = a.Ha;
                            if (c.Ba) {
                                for (
                                    var d = 0, e = -1, f = 0, g;
                                    (g = c.Ba[f]);
                                    f++
                                )
                                    if ((g = g.o))
                                        if (
                                            (d++,
                                            g == a && (e = f),
                                            0 <= e && 1 < d)
                                        )
                                            break;
                                0 <= e &&
                                    (c.N == qb && 1 == d
                                        ? xb(c, b)
                                        : ((d = c.Ba.splice(e, 1)[0]),
                                          yb(c, d, vb, b)));
                            }
                            a.Ha = null;
                        } else sb(a, vb, b);
                }
                function zb(a, b) {
                    (a.Ba && a.Ba.length) || (a.N != tb && a.N != vb) || Ab(a);
                    a.Ba || (a.Ba = []);
                    a.Ba.push(b);
                }
                function wb(a, b, c, d) {
                    var e = { o: null, Hf: null, Jf: null };
                    e.o = new pb(function (a, g) {
                        e.Hf = b
                            ? function (c) {
                                  try {
                                      var e = b.call(d, c);
                                      a(e);
                                  } catch (l) {
                                      g(l);
                                  }
                              }
                            : a;
                        e.Jf = c
                            ? function (b) {
                                  try {
                                      var e = c.call(d, b);
                                      !p(e) && b instanceof ub ? g(b) : a(e);
                                  } catch (l) {
                                      g(l);
                                  }
                              }
                            : g;
                    });
                    e.o.Ha = a;
                    zb(a, e);
                    return e.o;
                }
                h.Yf = function (a) {
                    this.N = qb;
                    sb(this, tb, a);
                };
                h.Zf = function (a) {
                    this.N = qb;
                    sb(this, vb, a);
                };
                function sb(a, b, c) {
                    if (a.N == qb) {
                        if (a == c)
                            (b = vb),
                                (c = new TypeError(
                                    "Promise cannot resolve to itself"
                                ));
                        else {
                            var d;
                            if (c)
                                try {
                                    d = !!c.$goog_Thenable;
                                } catch (e) {
                                    d = !1;
                                }
                            else d = !1;
                            if (d) {
                                a.N = 1;
                                c.then(a.Yf, a.Zf, a);
                                return;
                            }
                            if (ga(c))
                                try {
                                    var f = c.then;
                                    if (r(f)) {
                                        Bb(a, c, f);
                                        return;
                                    }
                                } catch (g) {
                                    (b = vb), (c = g);
                                }
                        }
                        a.Rf = c;
                        a.N = b;
                        a.Ha = null;
                        Ab(a);
                        b != vb || c instanceof ub || Cb(a, c);
                    }
                }
                function Bb(a, b, c) {
                    function d(b) {
                        f || ((f = !0), a.Zf(b));
                    }
                    function e(b) {
                        f || ((f = !0), a.Yf(b));
                    }
                    a.N = 1;
                    var f = !1;
                    try {
                        c.call(b, e, d);
                    } catch (g) {
                        d(g);
                    }
                }
                function Ab(a) {
                    a.ye || ((a.ye = !0), $a(a.wg, a));
                }
                h.wg = function () {
                    for (; this.Ba && this.Ba.length; ) {
                        var a = this.Ba;
                        this.Ba = null;
                        for (var b = 0; b < a.length; b++)
                            yb(this, a[b], this.N, this.Rf);
                    }
                    this.ye = !1;
                };
                function yb(a, b, c, d) {
                    if (c == tb) b.Hf(d);
                    else {
                        if (b.o) for (; a && a.yd; a = a.Ha) a.yd = !1;
                        b.Jf(d);
                    }
                }
                function Cb(a, b) {
                    a.yd = !0;
                    $a(function () {
                        a.yd && Db.call(null, b);
                    });
                }
                var Db = Xa;
                function ub(a) {
                    la.call(this, a);
                }
                ka(ub, la);
                ub.prototype.name = "cancel";
                var Eb = Eb || "2.4.1";
                function y(a, b) {
                    return Object.prototype.hasOwnProperty.call(a, b);
                }
                function z(a, b) {
                    if (Object.prototype.hasOwnProperty.call(a, b)) return a[b];
                }
                function Fb(a, b) {
                    for (var c in a)
                        Object.prototype.hasOwnProperty.call(a, c) &&
                            b(c, a[c]);
                }
                function Gb(a) {
                    var b = {};
                    Fb(a, function (a, d) {
                        b[a] = d;
                    });
                    return b;
                }
                function Hb(a) {
                    return "object" === typeof a && null !== a;
                }
                function Ib(a) {
                    var b = [];
                    Fb(a, function (a, d) {
                        da(d)
                            ? Ma(d, function (d) {
                                  b.push(
                                      encodeURIComponent(a) +
                                          "=" +
                                          encodeURIComponent(d)
                                  );
                              })
                            : b.push(
                                  encodeURIComponent(a) +
                                      "=" +
                                      encodeURIComponent(d)
                              );
                    });
                    return b.length ? "&" + b.join("&") : "";
                }
                function Jb(a) {
                    var b = {};
                    a = a.replace(/^\?/, "").split("&");
                    Ma(a, function (a) {
                        a && ((a = a.split("=")), (b[a[0]] = a[1]));
                    });
                    return b;
                }
                function Kb(a, b) {
                    if (!a) throw Lb(b);
                }
                function Lb(a) {
                    return Error(
                        "Firebase (" + Eb + ") INTERNAL ASSERT FAILED: " + a
                    );
                }
                var Mb = n.Promise || pb;
                pb.prototype["catch"] = pb.prototype.fh;
                function B() {
                    var a = this;
                    this.reject = this.resolve = null;
                    this.D = new Mb(function (b, c) {
                        a.resolve = b;
                        a.reject = c;
                    });
                }
                function C(a, b) {
                    return function (c, d) {
                        c ? a.reject(c) : a.resolve(d);
                        r(b) && (Nb(a.D), 1 === b.length ? b(c) : b(c, d));
                    };
                }
                function Nb(a) {
                    a.then(void 0, aa);
                }
                function Ob(a) {
                    for (var b = [], c = 0, d = 0; d < a.length; d++) {
                        var e = a.charCodeAt(d);
                        55296 <= e &&
                            56319 >= e &&
                            ((e -= 55296),
                            d++,
                            Kb(
                                d < a.length,
                                "Surrogate pair missing trail surrogate."
                            ),
                            (e =
                                65536 + (e << 10) + (a.charCodeAt(d) - 56320)));
                        128 > e
                            ? (b[c++] = e)
                            : (2048 > e
                                  ? (b[c++] = (e >> 6) | 192)
                                  : (65536 > e
                                        ? (b[c++] = (e >> 12) | 224)
                                        : ((b[c++] = (e >> 18) | 240),
                                          (b[c++] = ((e >> 12) & 63) | 128)),
                                    (b[c++] = ((e >> 6) & 63) | 128)),
                              (b[c++] = (e & 63) | 128));
                    }
                    return b;
                }
                function Pb(a) {
                    for (var b = 0, c = 0; c < a.length; c++) {
                        var d = a.charCodeAt(c);
                        128 > d
                            ? b++
                            : 2048 > d
                            ? (b += 2)
                            : 55296 <= d && 56319 >= d
                            ? ((b += 4), c++)
                            : (b += 3);
                    }
                    return b;
                }
                function D(a, b, c, d) {
                    var e;
                    d < b
                        ? (e = "at least " + b)
                        : d > c && (e = 0 === c ? "none" : "no more than " + c);
                    if (e)
                        throw Error(
                            a +
                                " failed: Was called with " +
                                d +
                                (1 === d ? " argument." : " arguments.") +
                                " Expects " +
                                e +
                                "."
                        );
                }
                function E(a, b, c) {
                    var d = "";
                    switch (b) {
                        case 1:
                            d = c ? "first" : "First";
                            break;
                        case 2:
                            d = c ? "second" : "Second";
                            break;
                        case 3:
                            d = c ? "third" : "Third";
                            break;
                        case 4:
                            d = c ? "fourth" : "Fourth";
                            break;
                        default:
                            throw Error(
                                "errorPrefix called with argumentNumber > 4.  Need to update it?"
                            );
                    }
                    return (a = a + " failed: " + (d + " argument "));
                }
                function F(a, b, c, d) {
                    if ((!d || p(c)) && !r(c))
                        throw Error(E(a, b, d) + "must be a valid function.");
                }
                function Qb(a, b, c) {
                    if (p(c) && (!ga(c) || null === c))
                        throw Error(
                            E(a, b, !0) + "must be a valid context object."
                        );
                }
                function Rb(a) {
                    return "undefined" !== typeof JSON && p(JSON.parse)
                        ? JSON.parse(a)
                        : za(a);
                }
                function G(a) {
                    if ("undefined" !== typeof JSON && p(JSON.stringify))
                        a = JSON.stringify(a);
                    else {
                        var b = [];
                        Ba(new Aa(), a, b);
                        a = b.join("");
                    }
                    return a;
                }
                function Sb() {
                    this.Zd = H;
                }
                Sb.prototype.j = function (a) {
                    return this.Zd.S(a);
                };
                Sb.prototype.toString = function () {
                    return this.Zd.toString();
                };
                function Tb() {}
                Tb.prototype.uf = function () {
                    return null;
                };
                Tb.prototype.Ce = function () {
                    return null;
                };
                var Ub = new Tb();
                function Vb(a, b, c) {
                    this.bg = a;
                    this.Oa = b;
                    this.Nd = c;
                }
                Vb.prototype.uf = function (a) {
                    var b = this.Oa.Q;
                    if (Wb(b, a)) return b.j().T(a);
                    b = null != this.Nd ? new Xb(this.Nd, !0, !1) : this.Oa.w();
                    return this.bg.Bc(a, b);
                };
                Vb.prototype.Ce = function (a, b, c) {
                    var d = null != this.Nd ? this.Nd : Yb(this.Oa);
                    a = this.bg.qe(d, b, 1, c, a);
                    return 0 === a.length ? null : a[0];
                };
                function Zb() {
                    this.xb = [];
                }
                function $b(a, b) {
                    for (var c = null, d = 0; d < b.length; d++) {
                        var e = b[d],
                            f = e.cc();
                        null === c ||
                            f.ea(c.cc()) ||
                            (a.xb.push(c), (c = null));
                        null === c && (c = new ac(f));
                        c.add(e);
                    }
                    c && a.xb.push(c);
                }
                function bc(a, b, c) {
                    $b(a, c);
                    cc(a, function (a) {
                        return a.ea(b);
                    });
                }
                function dc(a, b, c) {
                    $b(a, c);
                    cc(a, function (a) {
                        return a.contains(b) || b.contains(a);
                    });
                }
                function cc(a, b) {
                    for (var c = !0, d = 0; d < a.xb.length; d++) {
                        var e = a.xb[d];
                        if (e)
                            if (((e = e.cc()), b(e))) {
                                for (
                                    var e = a.xb[d], f = 0;
                                    f < e.xd.length;
                                    f++
                                ) {
                                    var g = e.xd[f];
                                    if (null !== g) {
                                        e.xd[f] = null;
                                        var k = g.Zb();
                                        ec && fc("event: " + g.toString());
                                        gc(k);
                                    }
                                }
                                a.xb[d] = null;
                            } else c = !1;
                    }
                    c && (a.xb = []);
                }
                function ac(a) {
                    this.ta = a;
                    this.xd = [];
                }
                ac.prototype.add = function (a) {
                    this.xd.push(a);
                };
                ac.prototype.cc = function () {
                    return this.ta;
                };
                function J(a, b, c, d) {
                    this.type = a;
                    this.Na = b;
                    this.Za = c;
                    this.Oe = d;
                    this.Td = void 0;
                }
                function hc(a) {
                    return new J(ic, a);
                }
                var ic = "value";
                function jc(a, b, c, d) {
                    this.xe = b;
                    this.be = c;
                    this.Td = d;
                    this.wd = a;
                }
                jc.prototype.cc = function () {
                    var a = this.be.Mb();
                    return "value" === this.wd ? a.path : a.parent().path;
                };
                jc.prototype.De = function () {
                    return this.wd;
                };
                jc.prototype.Zb = function () {
                    return this.xe.Zb(this);
                };
                jc.prototype.toString = function () {
                    return (
                        this.cc().toString() +
                        ":" +
                        this.wd +
                        ":" +
                        G(this.be.qf())
                    );
                };
                function kc(a, b, c) {
                    this.xe = a;
                    this.error = b;
                    this.path = c;
                }
                kc.prototype.cc = function () {
                    return this.path;
                };
                kc.prototype.De = function () {
                    return "cancel";
                };
                kc.prototype.Zb = function () {
                    return this.xe.Zb(this);
                };
                kc.prototype.toString = function () {
                    return this.path.toString() + ":cancel";
                };
                function Xb(a, b, c) {
                    this.A = a;
                    this.ga = b;
                    this.Yb = c;
                }
                function lc(a) {
                    return a.ga;
                }
                function mc(a) {
                    return a.Yb;
                }
                function nc(a, b) {
                    return b.e() ? a.ga && !a.Yb : Wb(a, K(b));
                }
                function Wb(a, b) {
                    return (a.ga && !a.Yb) || a.A.Fa(b);
                }
                Xb.prototype.j = function () {
                    return this.A;
                };
                function oc(a) {
                    this.pg = a;
                    this.Gd = null;
                }
                oc.prototype.get = function () {
                    var a = this.pg.get(),
                        b = wa(a);
                    if (this.Gd) for (var c in this.Gd) b[c] -= this.Gd[c];
                    this.Gd = a;
                    return b;
                };
                function pc(a, b) {
                    this.Vf = {};
                    this.hd = new oc(a);
                    this.da = b;
                    var c = 1e4 + 2e4 * Math.random();
                    setTimeout(u(this.Of, this), Math.floor(c));
                }
                pc.prototype.Of = function () {
                    var a = this.hd.get(),
                        b = {},
                        c = !1,
                        d;
                    for (d in a)
                        0 < a[d] && y(this.Vf, d) && ((b[d] = a[d]), (c = !0));
                    c && this.da.Ye(b);
                    setTimeout(
                        u(this.Of, this),
                        Math.floor(6e5 * Math.random())
                    );
                };
                function qc() {
                    this.Hc = {};
                }
                function rc(a, b, c) {
                    p(c) || (c = 1);
                    y(a.Hc, b) || (a.Hc[b] = 0);
                    a.Hc[b] += c;
                }
                qc.prototype.get = function () {
                    return wa(this.Hc);
                };
                var sc = {},
                    tc = {};
                function uc(a) {
                    a = a.toString();
                    sc[a] || (sc[a] = new qc());
                    return sc[a];
                }
                function vc(a, b) {
                    var c = a.toString();
                    tc[c] || (tc[c] = b());
                    return tc[c];
                }
                function L(a, b) {
                    this.name = a;
                    this.U = b;
                }
                function wc(a, b) {
                    return new L(a, b);
                }
                function xc(a, b) {
                    return yc(a.name, b.name);
                }
                function zc(a, b) {
                    return yc(a, b);
                }
                function Ac(a, b, c) {
                    this.type = Bc;
                    this.source = a;
                    this.path = b;
                    this.Ja = c;
                }
                Ac.prototype.$c = function (a) {
                    return this.path.e()
                        ? new Ac(this.source, M, this.Ja.T(a))
                        : new Ac(this.source, N(this.path), this.Ja);
                };
                Ac.prototype.toString = function () {
                    return (
                        "Operation(" +
                        this.path +
                        ": " +
                        this.source.toString() +
                        " overwrite: " +
                        this.Ja.toString() +
                        ")"
                    );
                };
                function Cc(a, b) {
                    this.type = Dc;
                    this.source = a;
                    this.path = b;
                }
                Cc.prototype.$c = function () {
                    return this.path.e()
                        ? new Cc(this.source, M)
                        : new Cc(this.source, N(this.path));
                };
                Cc.prototype.toString = function () {
                    return (
                        "Operation(" +
                        this.path +
                        ": " +
                        this.source.toString() +
                        " listen_complete)"
                    );
                };
                function Ec(a, b) {
                    this.Pa = a;
                    this.xa = b ? b : Fc;
                }
                h = Ec.prototype;
                h.Sa = function (a, b) {
                    return new Ec(
                        this.Pa,
                        this.xa.Sa(a, b, this.Pa).$(null, null, !1, null, null)
                    );
                };
                h.remove = function (a) {
                    return new Ec(
                        this.Pa,
                        this.xa.remove(a, this.Pa).$(null, null, !1, null, null)
                    );
                };
                h.get = function (a) {
                    for (var b, c = this.xa; !c.e(); ) {
                        b = this.Pa(a, c.key);
                        if (0 === b) return c.value;
                        0 > b ? (c = c.left) : 0 < b && (c = c.right);
                    }
                    return null;
                };
                function Gc(a, b) {
                    for (var c, d = a.xa, e = null; !d.e(); ) {
                        c = a.Pa(b, d.key);
                        if (0 === c) {
                            if (d.left.e()) return e ? e.key : null;
                            for (d = d.left; !d.right.e(); ) d = d.right;
                            return d.key;
                        }
                        0 > c
                            ? (d = d.left)
                            : 0 < c && ((e = d), (d = d.right));
                    }
                    throw Error(
                        "Attempted to find predecessor key for a nonexistent key.  What gives?"
                    );
                }
                h.e = function () {
                    return this.xa.e();
                };
                h.count = function () {
                    return this.xa.count();
                };
                h.Vc = function () {
                    return this.xa.Vc();
                };
                h.jc = function () {
                    return this.xa.jc();
                };
                h.ka = function (a) {
                    return this.xa.ka(a);
                };
                h.ac = function (a) {
                    return new Hc(this.xa, null, this.Pa, !1, a);
                };
                h.bc = function (a, b) {
                    return new Hc(this.xa, a, this.Pa, !1, b);
                };
                h.dc = function (a, b) {
                    return new Hc(this.xa, a, this.Pa, !0, b);
                };
                h.xf = function (a) {
                    return new Hc(this.xa, null, this.Pa, !0, a);
                };
                function Hc(a, b, c, d, e) {
                    this.Xd = e || null;
                    this.Je = d;
                    this.Ta = [];
                    for (e = 1; !a.e(); )
                        if (((e = b ? c(a.key, b) : 1), d && (e *= -1), 0 > e))
                            a = this.Je ? a.left : a.right;
                        else if (0 === e) {
                            this.Ta.push(a);
                            break;
                        } else
                            this.Ta.push(a), (a = this.Je ? a.right : a.left);
                }
                function Ic(a) {
                    if (0 === a.Ta.length) return null;
                    var b = a.Ta.pop(),
                        c;
                    c = a.Xd
                        ? a.Xd(b.key, b.value)
                        : { key: b.key, value: b.value };
                    if (a.Je)
                        for (b = b.left; !b.e(); ) a.Ta.push(b), (b = b.right);
                    else for (b = b.right; !b.e(); ) a.Ta.push(b), (b = b.left);
                    return c;
                }
                function Jc(a) {
                    if (0 === a.Ta.length) return null;
                    var b;
                    b = a.Ta;
                    b = b[b.length - 1];
                    return a.Xd
                        ? a.Xd(b.key, b.value)
                        : { key: b.key, value: b.value };
                }
                function Kc(a, b, c, d, e) {
                    this.key = a;
                    this.value = b;
                    this.color = null != c ? c : !0;
                    this.left = null != d ? d : Fc;
                    this.right = null != e ? e : Fc;
                }
                h = Kc.prototype;
                h.$ = function (a, b, c, d, e) {
                    return new Kc(
                        null != a ? a : this.key,
                        null != b ? b : this.value,
                        null != c ? c : this.color,
                        null != d ? d : this.left,
                        null != e ? e : this.right
                    );
                };
                h.count = function () {
                    return this.left.count() + 1 + this.right.count();
                };
                h.e = function () {
                    return !1;
                };
                h.ka = function (a) {
                    return (
                        this.left.ka(a) ||
                        a(this.key, this.value) ||
                        this.right.ka(a)
                    );
                };
                function Lc(a) {
                    return a.left.e() ? a : Lc(a.left);
                }
                h.Vc = function () {
                    return Lc(this).key;
                };
                h.jc = function () {
                    return this.right.e() ? this.key : this.right.jc();
                };
                h.Sa = function (a, b, c) {
                    var d, e;
                    e = this;
                    d = c(a, e.key);
                    e =
                        0 > d
                            ? e.$(null, null, null, e.left.Sa(a, b, c), null)
                            : 0 === d
                            ? e.$(null, b, null, null, null)
                            : e.$(null, null, null, null, e.right.Sa(a, b, c));
                    return Mc(e);
                };
                function Nc(a) {
                    if (a.left.e()) return Fc;
                    a.left.ha() || a.left.left.ha() || (a = Oc(a));
                    a = a.$(null, null, null, Nc(a.left), null);
                    return Mc(a);
                }
                h.remove = function (a, b) {
                    var c, d;
                    c = this;
                    if (0 > b(a, c.key))
                        c.left.e() ||
                            c.left.ha() ||
                            c.left.left.ha() ||
                            (c = Oc(c)),
                            (c = c.$(
                                null,
                                null,
                                null,
                                c.left.remove(a, b),
                                null
                            ));
                    else {
                        c.left.ha() && (c = Pc(c));
                        c.right.e() ||
                            c.right.ha() ||
                            c.right.left.ha() ||
                            ((c = Qc(c)),
                            c.left.left.ha() && ((c = Pc(c)), (c = Qc(c))));
                        if (0 === b(a, c.key)) {
                            if (c.right.e()) return Fc;
                            d = Lc(c.right);
                            c = c.$(d.key, d.value, null, null, Nc(c.right));
                        }
                        c = c.$(null, null, null, null, c.right.remove(a, b));
                    }
                    return Mc(c);
                };
                h.ha = function () {
                    return this.color;
                };
                function Mc(a) {
                    a.right.ha() && !a.left.ha() && (a = Rc(a));
                    a.left.ha() && a.left.left.ha() && (a = Pc(a));
                    a.left.ha() && a.right.ha() && (a = Qc(a));
                    return a;
                }
                function Oc(a) {
                    a = Qc(a);
                    a.right.left.ha() &&
                        ((a = a.$(null, null, null, null, Pc(a.right))),
                        (a = Rc(a)),
                        (a = Qc(a)));
                    return a;
                }
                function Rc(a) {
                    return a.right.$(
                        null,
                        null,
                        a.color,
                        a.$(null, null, !0, null, a.right.left),
                        null
                    );
                }
                function Pc(a) {
                    return a.left.$(
                        null,
                        null,
                        a.color,
                        null,
                        a.$(null, null, !0, a.left.right, null)
                    );
                }
                function Qc(a) {
                    return a.$(
                        null,
                        null,
                        !a.color,
                        a.left.$(null, null, !a.left.color, null, null),
                        a.right.$(null, null, !a.right.color, null, null)
                    );
                }
                function Sc() {}
                h = Sc.prototype;
                h.$ = function () {
                    return this;
                };
                h.Sa = function (a, b) {
                    return new Kc(a, b, null);
                };
                h.remove = function () {
                    return this;
                };
                h.count = function () {
                    return 0;
                };
                h.e = function () {
                    return !0;
                };
                h.ka = function () {
                    return !1;
                };
                h.Vc = function () {
                    return null;
                };
                h.jc = function () {
                    return null;
                };
                h.ha = function () {
                    return !1;
                };
                var Fc = new Sc();
                function Tc(a, b) {
                    return a && "object" === typeof a
                        ? (O(
                              ".sv" in a,
                              "Unexpected leaf node or priority contents"
                          ),
                          b[a[".sv"]])
                        : a;
                }
                function Uc(a, b) {
                    var c = new Vc();
                    Wc(a, new P(""), function (a, e) {
                        c.rc(a, Xc(e, b));
                    });
                    return c;
                }
                function Xc(a, b) {
                    var c = a.C().J(),
                        c = Tc(c, b),
                        d;
                    if (a.L()) {
                        var e = Tc(a.Ea(), b);
                        return e !== a.Ea() || c !== a.C().J()
                            ? new Yc(e, Q(c))
                            : a;
                    }
                    d = a;
                    c !== a.C().J() && (d = d.ia(new Yc(c)));
                    a.R(R, function (a, c) {
                        var e = Xc(c, b);
                        e !== c && (d = d.W(a, e));
                    });
                    return d;
                }
                function Zc() {
                    this.Ac = {};
                }
                Zc.prototype.set = function (a, b) {
                    null == b ? delete this.Ac[a] : (this.Ac[a] = b);
                };
                Zc.prototype.get = function (a) {
                    return y(this.Ac, a) ? this.Ac[a] : null;
                };
                Zc.prototype.remove = function (a) {
                    delete this.Ac[a];
                };
                Zc.prototype.Af = !0;
                function $c(a) {
                    this.Ic = a;
                    this.Sd = "firebase:";
                }
                h = $c.prototype;
                h.set = function (a, b) {
                    null == b
                        ? this.Ic.removeItem(this.Sd + a)
                        : this.Ic.setItem(this.Sd + a, G(b));
                };
                h.get = function (a) {
                    a = this.Ic.getItem(this.Sd + a);
                    return null == a ? null : Rb(a);
                };
                h.remove = function (a) {
                    this.Ic.removeItem(this.Sd + a);
                };
                h.Af = !1;
                h.toString = function () {
                    return this.Ic.toString();
                };
                function ad(a) {
                    try {
                        if (
                            "undefined" !== typeof window &&
                            "undefined" !== typeof window[a]
                        ) {
                            var b = window[a];
                            b.setItem("firebase:sentinel", "cache");
                            b.removeItem("firebase:sentinel");
                            return new $c(b);
                        }
                    } catch (c) {}
                    return new Zc();
                }
                var bd = ad("localStorage"),
                    cd = ad("sessionStorage");
                function dd(a, b, c, d, e) {
                    this.host = a.toLowerCase();
                    this.domain = this.host.substr(this.host.indexOf(".") + 1);
                    this.ob = b;
                    this.lc = c;
                    this.ih = d;
                    this.Rd = e || "";
                    this.ab = bd.get("host:" + a) || this.host;
                }
                function ed(a, b) {
                    b !== a.ab &&
                        ((a.ab = b),
                        "s-" === a.ab.substr(0, 2) &&
                            bd.set("host:" + a.host, a.ab));
                }
                function fd(a, b, c) {
                    O("string" === typeof b, "typeof type must == string");
                    O("object" === typeof c, "typeof params must == object");
                    if (b === gd)
                        b = (a.ob ? "wss://" : "ws://") + a.ab + "/.ws?";
                    else if (b === hd)
                        b = (a.ob ? "https://" : "http://") + a.ab + "/.lp?";
                    else throw Error("Unknown connection type: " + b);
                    a.host !== a.ab && (c.ns = a.lc);
                    var d = [];
                    v(c, function (a, b) {
                        d.push(b + "=" + a);
                    });
                    return b + d.join("&");
                }
                dd.prototype.toString = function () {
                    var a = (this.ob ? "https://" : "http://") + this.host;
                    this.Rd && (a += "<" + this.Rd + ">");
                    return a;
                };
                var id = (function () {
                        var a = 1;
                        return function () {
                            return a++;
                        };
                    })(),
                    O = Kb,
                    jd = Lb;
                function kd(a) {
                    try {
                        var b;
                        if ("undefined" !== typeof atob) b = atob(a);
                        else {
                            ob();
                            for (var c = mb, d = [], e = 0; e < a.length; ) {
                                var f = c[a.charAt(e++)],
                                    g = e < a.length ? c[a.charAt(e)] : 0;
                                ++e;
                                var k = e < a.length ? c[a.charAt(e)] : 64;
                                ++e;
                                var m = e < a.length ? c[a.charAt(e)] : 64;
                                ++e;
                                if (
                                    null == f ||
                                    null == g ||
                                    null == k ||
                                    null == m
                                )
                                    throw Error();
                                d.push((f << 2) | (g >> 4));
                                64 != k &&
                                    (d.push(((g << 4) & 240) | (k >> 2)),
                                    64 != m && d.push(((k << 6) & 192) | m));
                            }
                            if (8192 > d.length)
                                b = String.fromCharCode.apply(null, d);
                            else {
                                a = "";
                                for (c = 0; c < d.length; c += 8192)
                                    a += String.fromCharCode.apply(
                                        null,
                                        Ua(d, c, c + 8192)
                                    );
                                b = a;
                            }
                        }
                        return b;
                    } catch (l) {
                        fc("base64Decode failed: ", l);
                    }
                    return null;
                }
                function ld(a) {
                    var b = Ob(a);
                    a = new Ja();
                    a.update(b);
                    var b = [],
                        c = 8 * a.ge;
                    56 > a.ec
                        ? a.update(a.Od, 56 - a.ec)
                        : a.update(a.Od, a.Ya - (a.ec - 56));
                    for (var d = a.Ya - 1; 56 <= d; d--)
                        (a.pe[d] = c & 255), (c /= 256);
                    Ka(a, a.pe);
                    for (d = c = 0; 5 > d; d++)
                        for (var e = 24; 0 <= e; e -= 8)
                            (b[c] = (a.P[d] >> e) & 255), ++c;
                    return nb(b);
                }
                function md(a) {
                    for (var b = "", c = 0; c < arguments.length; c++)
                        (b = ea(arguments[c])
                            ? b + md.apply(null, arguments[c])
                            : "object" === typeof arguments[c]
                            ? b + G(arguments[c])
                            : b + arguments[c]),
                            (b += " ");
                    return b;
                }
                var ec = null,
                    nd = !0;
                function od(a, b) {
                    Kb(
                        !b || !0 === a || !1 === a,
                        "Can't turn on custom loggers persistently."
                    );
                    !0 === a
                        ? ("undefined" !== typeof console &&
                              ("function" === typeof console.log
                                  ? (ec = u(console.log, console))
                                  : "object" === typeof console.log &&
                                    (ec = function (a) {
                                        console.log(a);
                                    })),
                          b && cd.set("logging_enabled", !0))
                        : r(a)
                        ? (ec = a)
                        : ((ec = null), cd.remove("logging_enabled"));
                }
                function fc(a) {
                    !0 === nd &&
                        ((nd = !1),
                        null === ec &&
                            !0 === cd.get("logging_enabled") &&
                            od(!0));
                    if (ec) {
                        var b = md.apply(null, arguments);
                        ec(b);
                    }
                }
                function pd(a) {
                    return function () {
                        fc(a, arguments);
                    };
                }
                function qd(a) {
                    if ("undefined" !== typeof console) {
                        var b =
                            "FIREBASE INTERNAL ERROR: " +
                            md.apply(null, arguments);
                        "undefined" !== typeof console.error
                            ? console.error(b)
                            : console.log(b);
                    }
                }
                function rd(a) {
                    var b = md.apply(null, arguments);
                    throw Error("FIREBASE FATAL ERROR: " + b);
                }
                function S(a) {
                    if ("undefined" !== typeof console) {
                        var b =
                            "FIREBASE WARNING: " + md.apply(null, arguments);
                        "undefined" !== typeof console.warn
                            ? console.warn(b)
                            : console.log(b);
                    }
                }
                function sd(a) {
                    var b = "",
                        c = "",
                        d = "",
                        e = "",
                        f = !0,
                        g = "https",
                        k = 443;
                    if (q(a)) {
                        var m = a.indexOf("//");
                        0 <= m &&
                            ((g = a.substring(0, m - 1)),
                            (a = a.substring(m + 2)));
                        m = a.indexOf("/");
                        -1 === m && (m = a.length);
                        b = a.substring(0, m);
                        e = "";
                        a = a.substring(m).split("/");
                        for (m = 0; m < a.length; m++)
                            if (0 < a[m].length) {
                                var l = a[m];
                                try {
                                    l = decodeURIComponent(
                                        l.replace(/\+/g, " ")
                                    );
                                } catch (t) {}
                                e += "/" + l;
                            }
                        a = b.split(".");
                        3 === a.length
                            ? ((c = a[1]), (d = a[0].toLowerCase()))
                            : 2 === a.length && (c = a[0]);
                        m = b.indexOf(":");
                        0 <= m &&
                            ((f = "https" === g || "wss" === g),
                            (k = b.substring(m + 1)),
                            isFinite(k) && (k = String(k)),
                            (k = q(k)
                                ? /^\s*-?0x/i.test(k)
                                    ? parseInt(k, 16)
                                    : parseInt(k, 10)
                                : NaN));
                    }
                    return {
                        host: b,
                        port: k,
                        domain: c,
                        eh: d,
                        ob: f,
                        scheme: g,
                        bd: e,
                    };
                }
                function td(a) {
                    return (
                        fa(a) &&
                        (a != a ||
                            a == Number.POSITIVE_INFINITY ||
                            a == Number.NEGATIVE_INFINITY)
                    );
                }
                function ud(a) {
                    if ("complete" === document.readyState) a();
                    else {
                        var b = !1,
                            c = function () {
                                document.body
                                    ? b || ((b = !0), a())
                                    : setTimeout(c, Math.floor(10));
                            };
                        document.addEventListener
                            ? (document.addEventListener(
                                  "DOMContentLoaded",
                                  c,
                                  !1
                              ),
                              window.addEventListener("load", c, !1))
                            : document.attachEvent &&
                              (document.attachEvent(
                                  "onreadystatechange",
                                  function () {
                                      "complete" === document.readyState && c();
                                  }
                              ),
                              window.attachEvent("onload", c));
                    }
                }
                function yc(a, b) {
                    if (a === b) return 0;
                    if ("[MIN_NAME]" === a || "[MAX_NAME]" === b) return -1;
                    if ("[MIN_NAME]" === b || "[MAX_NAME]" === a) return 1;
                    var c = vd(a),
                        d = vd(b);
                    return null !== c
                        ? null !== d
                            ? 0 == c - d
                                ? a.length - b.length
                                : c - d
                            : -1
                        : null !== d
                        ? 1
                        : a < b
                        ? -1
                        : 1;
                }
                function wd(a, b) {
                    if (b && a in b) return b[a];
                    throw Error(
                        "Missing required key (" + a + ") in object: " + G(b)
                    );
                }
                function xd(a) {
                    if ("object" !== typeof a || null === a) return G(a);
                    var b = [],
                        c;
                    for (c in a) b.push(c);
                    b.sort();
                    c = "{";
                    for (var d = 0; d < b.length; d++)
                        0 !== d && (c += ","),
                            (c += G(b[d])),
                            (c += ":"),
                            (c += xd(a[b[d]]));
                    return c + "}";
                }
                function yd(a, b) {
                    if (a.length <= b) return [a];
                    for (var c = [], d = 0; d < a.length; d += b)
                        d + b > a
                            ? c.push(a.substring(d, a.length))
                            : c.push(a.substring(d, d + b));
                    return c;
                }
                function zd(a, b) {
                    if (da(a)) for (var c = 0; c < a.length; ++c) b(c, a[c]);
                    else v(a, b);
                }
                function Ad(a) {
                    O(!td(a), "Invalid JSON number");
                    var b, c, d, e;
                    0 === a
                        ? ((d = c = 0), (b = -Infinity === 1 / a ? 1 : 0))
                        : ((b = 0 > a),
                          (a = Math.abs(a)),
                          a >= Math.pow(2, -1022)
                              ? ((d = Math.min(
                                    Math.floor(Math.log(a) / Math.LN2),
                                    1023
                                )),
                                (c = d + 1023),
                                (d = Math.round(
                                    a * Math.pow(2, 52 - d) - Math.pow(2, 52)
                                )))
                              : ((c = 0),
                                (d = Math.round(a / Math.pow(2, -1074)))));
                    e = [];
                    for (a = 52; a; --a)
                        e.push(d % 2 ? 1 : 0), (d = Math.floor(d / 2));
                    for (a = 11; a; --a)
                        e.push(c % 2 ? 1 : 0), (c = Math.floor(c / 2));
                    e.push(b ? 1 : 0);
                    e.reverse();
                    b = e.join("");
                    c = "";
                    for (a = 0; 64 > a; a += 8)
                        (d = parseInt(b.substr(a, 8), 2).toString(16)),
                            1 === d.length && (d = "0" + d),
                            (c += d);
                    return c.toLowerCase();
                }
                var Bd = /^-?\d{1,10}$/;
                function vd(a) {
                    return Bd.test(a) &&
                        ((a = Number(a)), -2147483648 <= a && 2147483647 >= a)
                        ? a
                        : null;
                }
                function gc(a) {
                    try {
                        a();
                    } catch (b) {
                        setTimeout(function () {
                            S(
                                "Exception was thrown by user callback.",
                                b.stack || ""
                            );
                            throw b;
                        }, Math.floor(0));
                    }
                }
                function T(a, b) {
                    if (r(a)) {
                        var c = Array.prototype.slice
                            .call(arguments, 1)
                            .slice();
                        gc(function () {
                            a.apply(null, c);
                        });
                    }
                }
                function Cd(a) {
                    var b = {},
                        c = {},
                        d = {},
                        e = "";
                    try {
                        var f = a.split("."),
                            b = Rb(kd(f[0]) || ""),
                            c = Rb(kd(f[1]) || ""),
                            e = f[2],
                            d = c.d || {};
                        delete c.d;
                    } catch (g) {}
                    return { lh: b, Ec: c, data: d, ah: e };
                }
                function Dd(a) {
                    a = Cd(a).Ec;
                    return "object" === typeof a && a.hasOwnProperty("iat")
                        ? z(a, "iat")
                        : null;
                }
                function Ed(a) {
                    a = Cd(a);
                    var b = a.Ec;
                    return (
                        !!a.ah &&
                        !!b &&
                        "object" === typeof b &&
                        b.hasOwnProperty("iat")
                    );
                }
                function Fd(a) {
                    this.Y = a;
                    this.g = a.n.g;
                }
                function Gd(a, b, c, d) {
                    var e = [],
                        f = [];
                    Ma(b, function (b) {
                        "child_changed" === b.type &&
                            a.g.Dd(b.Oe, b.Na) &&
                            f.push(new J("child_moved", b.Na, b.Za));
                    });
                    Hd(a, e, "child_removed", b, d, c);
                    Hd(a, e, "child_added", b, d, c);
                    Hd(a, e, "child_moved", f, d, c);
                    Hd(a, e, "child_changed", b, d, c);
                    Hd(a, e, ic, b, d, c);
                    return e;
                }
                function Hd(a, b, c, d, e, f) {
                    d = Na(d, function (a) {
                        return a.type === c;
                    });
                    Va(d, u(a.qg, a));
                    Ma(d, function (c) {
                        var d = Id(a, c, f);
                        Ma(e, function (e) {
                            e.Qf(c.type) && b.push(e.createEvent(d, a.Y));
                        });
                    });
                }
                function Id(a, b, c) {
                    "value" !== b.type &&
                        "child_removed" !== b.type &&
                        (b.Td = c.wf(b.Za, b.Na, a.g));
                    return b;
                }
                Fd.prototype.qg = function (a, b) {
                    if (null == a.Za || null == b.Za)
                        throw jd("Should only compare child_ events.");
                    return this.g.compare(new L(a.Za, a.Na), new L(b.Za, b.Na));
                };
                function Jd() {
                    this.ib = {};
                }
                function Kd(a, b) {
                    var c = b.type,
                        d = b.Za;
                    O(
                        "child_added" == c ||
                            "child_changed" == c ||
                            "child_removed" == c,
                        "Only child changes supported for tracking"
                    );
                    O(
                        ".priority" !== d,
                        "Only non-priority child changes can be tracked."
                    );
                    var e = z(a.ib, d);
                    if (e) {
                        var f = e.type;
                        if ("child_added" == c && "child_removed" == f)
                            a.ib[d] = new J("child_changed", b.Na, d, e.Na);
                        else if ("child_removed" == c && "child_added" == f)
                            delete a.ib[d];
                        else if ("child_removed" == c && "child_changed" == f)
                            a.ib[d] = new J("child_removed", e.Oe, d);
                        else if ("child_changed" == c && "child_added" == f)
                            a.ib[d] = new J("child_added", b.Na, d);
                        else if ("child_changed" == c && "child_changed" == f)
                            a.ib[d] = new J("child_changed", b.Na, d, e.Oe);
                        else
                            throw jd(
                                "Illegal combination of changes: " +
                                    b +
                                    " occurred after " +
                                    e
                            );
                    } else a.ib[d] = b;
                }
                function Ld(a) {
                    this.g = a;
                }
                h = Ld.prototype;
                h.H = function (a, b, c, d, e, f) {
                    O(
                        a.Mc(this.g),
                        "A node must be indexed if only a child is updated"
                    );
                    e = a.T(b);
                    if (e.S(d).ea(c.S(d)) && e.e() == c.e()) return a;
                    null != f &&
                        (c.e()
                            ? a.Fa(b)
                                ? Kd(f, new J("child_removed", e, b))
                                : O(
                                      a.L(),
                                      "A child remove without an old child only makes sense on a leaf node"
                                  )
                            : e.e()
                            ? Kd(f, new J("child_added", c, b))
                            : Kd(f, new J("child_changed", c, b, e)));
                    return a.L() && c.e() ? a : a.W(b, c).pb(this.g);
                };
                h.ya = function (a, b, c) {
                    null != c &&
                        (a.L() ||
                            a.R(R, function (a, e) {
                                b.Fa(a) || Kd(c, new J("child_removed", e, a));
                            }),
                        b.L() ||
                            b.R(R, function (b, e) {
                                if (a.Fa(b)) {
                                    var f = a.T(b);
                                    f.ea(e) ||
                                        Kd(c, new J("child_changed", e, b, f));
                                } else Kd(c, new J("child_added", e, b));
                            }));
                    return b.pb(this.g);
                };
                h.ia = function (a, b) {
                    return a.e() ? H : a.ia(b);
                };
                h.Ra = function () {
                    return !1;
                };
                h.$b = function () {
                    return this;
                };
                function Md(a) {
                    this.Fe = new Ld(a.g);
                    this.g = a.g;
                    var b;
                    a.oa
                        ? ((b = Nd(a)), (b = a.g.Sc(Od(a), b)))
                        : (b = a.g.Wc());
                    this.gd = b;
                    a.ra
                        ? ((b = Pd(a)), (a = a.g.Sc(Rd(a), b)))
                        : (a = a.g.Tc());
                    this.Jc = a;
                }
                h = Md.prototype;
                h.matches = function (a) {
                    return (
                        0 >= this.g.compare(this.gd, a) &&
                        0 >= this.g.compare(a, this.Jc)
                    );
                };
                h.H = function (a, b, c, d, e, f) {
                    this.matches(new L(b, c)) || (c = H);
                    return this.Fe.H(a, b, c, d, e, f);
                };
                h.ya = function (a, b, c) {
                    b.L() && (b = H);
                    var d = b.pb(this.g),
                        d = d.ia(H),
                        e = this;
                    b.R(R, function (a, b) {
                        e.matches(new L(a, b)) || (d = d.W(a, H));
                    });
                    return this.Fe.ya(a, d, c);
                };
                h.ia = function (a) {
                    return a;
                };
                h.Ra = function () {
                    return !0;
                };
                h.$b = function () {
                    return this.Fe;
                };
                function Sd(a) {
                    this.ua = new Md(a);
                    this.g = a.g;
                    O(a.la, "Only valid if limit has been set");
                    this.ma = a.ma;
                    this.Nb = !Td(a);
                }
                h = Sd.prototype;
                h.H = function (a, b, c, d, e, f) {
                    this.ua.matches(new L(b, c)) || (c = H);
                    return a.T(b).ea(c)
                        ? a
                        : a.Hb() < this.ma
                        ? this.ua.$b().H(a, b, c, d, e, f)
                        : Ud(this, a, b, c, e, f);
                };
                h.ya = function (a, b, c) {
                    var d;
                    if (b.L() || b.e()) d = H.pb(this.g);
                    else if (2 * this.ma < b.Hb() && b.Mc(this.g)) {
                        d = H.pb(this.g);
                        b = this.Nb
                            ? b.dc(this.ua.Jc, this.g)
                            : b.bc(this.ua.gd, this.g);
                        for (var e = 0; 0 < b.Ta.length && e < this.ma; ) {
                            var f = Ic(b),
                                g;
                            if (
                                (g = this.Nb
                                    ? 0 >= this.g.compare(this.ua.gd, f)
                                    : 0 >= this.g.compare(f, this.ua.Jc))
                            )
                                (d = d.W(f.name, f.U)), e++;
                            else break;
                        }
                    } else {
                        d = b.pb(this.g);
                        d = d.ia(H);
                        var k, m, l;
                        if (this.Nb) {
                            b = d.xf(this.g);
                            k = this.ua.Jc;
                            m = this.ua.gd;
                            var t = Vd(this.g);
                            l = function (a, b) {
                                return t(b, a);
                            };
                        } else
                            (b = d.ac(this.g)),
                                (k = this.ua.gd),
                                (m = this.ua.Jc),
                                (l = Vd(this.g));
                        for (var e = 0, A = !1; 0 < b.Ta.length; )
                            (f = Ic(b)),
                                !A && 0 >= l(k, f) && (A = !0),
                                (g = A && e < this.ma && 0 >= l(f, m))
                                    ? e++
                                    : (d = d.W(f.name, H));
                    }
                    return this.ua.$b().ya(a, d, c);
                };
                h.ia = function (a) {
                    return a;
                };
                h.Ra = function () {
                    return !0;
                };
                h.$b = function () {
                    return this.ua.$b();
                };
                function Ud(a, b, c, d, e, f) {
                    var g;
                    if (a.Nb) {
                        var k = Vd(a.g);
                        g = function (a, b) {
                            return k(b, a);
                        };
                    } else g = Vd(a.g);
                    O(b.Hb() == a.ma, "");
                    var m = new L(c, d),
                        l = a.Nb ? Wd(b, a.g) : Xd(b, a.g),
                        t = a.ua.matches(m);
                    if (b.Fa(c)) {
                        for (
                            var A = b.T(c), l = e.Ce(a.g, l, a.Nb);
                            null != l && (l.name == c || b.Fa(l.name));

                        )
                            l = e.Ce(a.g, l, a.Nb);
                        e = null == l ? 1 : g(l, m);
                        if (t && !d.e() && 0 <= e)
                            return (
                                null != f &&
                                    Kd(f, new J("child_changed", d, c, A)),
                                b.W(c, d)
                            );
                        null != f && Kd(f, new J("child_removed", A, c));
                        b = b.W(c, H);
                        return null != l && a.ua.matches(l)
                            ? (null != f &&
                                  Kd(f, new J("child_added", l.U, l.name)),
                              b.W(l.name, l.U))
                            : b;
                    }
                    return d.e()
                        ? b
                        : t && 0 <= g(l, m)
                        ? (null != f &&
                              (Kd(f, new J("child_removed", l.U, l.name)),
                              Kd(f, new J("child_added", d, c))),
                          b.W(c, d).W(l.name, H))
                        : b;
                }
                function Yd(a, b) {
                    this.me = a;
                    this.og = b;
                }
                function Zd(a) {
                    this.X = a;
                }
                Zd.prototype.gb = function (a, b, c, d) {
                    var e = new Jd(),
                        f;
                    if (b.type === Bc)
                        b.source.Ae
                            ? (c = $d(this, a, b.path, b.Ja, c, d, e))
                            : (O(b.source.tf, "Unknown source."),
                              (f = b.source.ef || (mc(a.w()) && !b.path.e())),
                              (c = ae(this, a, b.path, b.Ja, c, d, f, e)));
                    else if (b.type === be)
                        b.source.Ae
                            ? (c = ce(this, a, b.path, b.children, c, d, e))
                            : (O(b.source.tf, "Unknown source."),
                              (f = b.source.ef || mc(a.w())),
                              (c = de(
                                  this,
                                  a,
                                  b.path,
                                  b.children,
                                  c,
                                  d,
                                  f,
                                  e
                              )));
                    else if (b.type === ee)
                        if (b.Yd)
                            if (((b = b.path), null != c.xc(b))) c = a;
                            else {
                                f = new Vb(c, a, d);
                                d = a.Q.j();
                                if (b.e() || ".priority" === K(b))
                                    lc(a.w())
                                        ? (b = c.Aa(Yb(a)))
                                        : ((b = a.w().j()),
                                          O(
                                              b instanceof fe,
                                              "serverChildren would be complete if leaf node"
                                          ),
                                          (b = c.Cc(b))),
                                        (b = this.X.ya(d, b, e));
                                else {
                                    var g = K(b),
                                        k = c.Bc(g, a.w());
                                    null == k && Wb(a.w(), g) && (k = d.T(g));
                                    b =
                                        null != k
                                            ? this.X.H(d, g, k, N(b), f, e)
                                            : a.Q.j().Fa(g)
                                            ? this.X.H(d, g, H, N(b), f, e)
                                            : d;
                                    b.e() &&
                                        lc(a.w()) &&
                                        ((d = c.Aa(Yb(a))),
                                        d.L() && (b = this.X.ya(b, d, e)));
                                }
                                d = lc(a.w()) || null != c.xc(M);
                                c = ge(a, b, d, this.X.Ra());
                            }
                        else c = he(this, a, b.path, b.Ub, c, d, e);
                    else if (b.type === Dc)
                        (d = b.path),
                            (b = a.w()),
                            (f = b.j()),
                            (g = b.ga || d.e()),
                            (c = ie(
                                this,
                                new je(a.Q, new Xb(f, g, b.Yb)),
                                d,
                                c,
                                Ub,
                                e
                            ));
                    else throw jd("Unknown operation type: " + b.type);
                    e = qa(e.ib);
                    d = c;
                    b = d.Q;
                    b.ga &&
                        ((f = b.j().L() || b.j().e()),
                        (g = ke(a)),
                        (0 < e.length ||
                            !a.Q.ga ||
                            (f && !b.j().ea(g)) ||
                            !b.j().C().ea(g.C())) &&
                            e.push(hc(ke(d))));
                    return new Yd(c, e);
                };
                function ie(a, b, c, d, e, f) {
                    var g = b.Q;
                    if (null != d.xc(c)) return b;
                    var k;
                    if (c.e())
                        O(
                            lc(b.w()),
                            "If change path is empty, we must have complete server data"
                        ),
                            mc(b.w())
                                ? ((e = Yb(b)),
                                  (d = d.Cc(e instanceof fe ? e : H)))
                                : (d = d.Aa(Yb(b))),
                            (f = a.X.ya(b.Q.j(), d, f));
                    else {
                        var m = K(c);
                        if (".priority" == m)
                            O(
                                1 == le(c),
                                "Can't have a priority with additional path components"
                            ),
                                (f = g.j()),
                                (k = b.w().j()),
                                (d = d.nd(c, f, k)),
                                (f = null != d ? a.X.ia(f, d) : g.j());
                        else {
                            var l = N(c);
                            Wb(g, m)
                                ? ((k = b.w().j()),
                                  (d = d.nd(c, g.j(), k)),
                                  (d =
                                      null != d
                                          ? g.j().T(m).H(l, d)
                                          : g.j().T(m)))
                                : (d = d.Bc(m, b.w()));
                            f = null != d ? a.X.H(g.j(), m, d, l, e, f) : g.j();
                        }
                    }
                    return ge(b, f, g.ga || c.e(), a.X.Ra());
                }
                function ae(a, b, c, d, e, f, g, k) {
                    var m = b.w();
                    g = g ? a.X : a.X.$b();
                    if (c.e()) d = g.ya(m.j(), d, null);
                    else if (g.Ra() && !m.Yb)
                        (d = m.j().H(c, d)), (d = g.ya(m.j(), d, null));
                    else {
                        var l = K(c);
                        if (!nc(m, c) && 1 < le(c)) return b;
                        var t = N(c);
                        d = m.j().T(l).H(t, d);
                        d =
                            ".priority" == l
                                ? g.ia(m.j(), d)
                                : g.H(m.j(), l, d, t, Ub, null);
                    }
                    m = m.ga || c.e();
                    b = new je(b.Q, new Xb(d, m, g.Ra()));
                    return ie(a, b, c, e, new Vb(e, b, f), k);
                }
                function $d(a, b, c, d, e, f, g) {
                    var k = b.Q;
                    e = new Vb(e, b, f);
                    if (c.e())
                        (g = a.X.ya(b.Q.j(), d, g)),
                            (a = ge(b, g, !0, a.X.Ra()));
                    else if (((f = K(c)), ".priority" === f))
                        (g = a.X.ia(b.Q.j(), d)), (a = ge(b, g, k.ga, k.Yb));
                    else {
                        c = N(c);
                        var m = k.j().T(f);
                        if (!c.e()) {
                            var l = e.uf(f);
                            d =
                                null != l
                                    ? ".priority" === me(c) &&
                                      l.S(c.parent()).e()
                                        ? l
                                        : l.H(c, d)
                                    : H;
                        }
                        m.ea(d)
                            ? (a = b)
                            : ((g = a.X.H(k.j(), f, d, c, e, g)),
                              (a = ge(b, g, k.ga, a.X.Ra())));
                    }
                    return a;
                }
                function ce(a, b, c, d, e, f, g) {
                    var k = b;
                    ne(d, function (d, l) {
                        var t = c.o(d);
                        Wb(b.Q, K(t)) && (k = $d(a, k, t, l, e, f, g));
                    });
                    ne(d, function (d, l) {
                        var t = c.o(d);
                        Wb(b.Q, K(t)) || (k = $d(a, k, t, l, e, f, g));
                    });
                    return k;
                }
                function oe(a, b) {
                    ne(b, function (b, d) {
                        a = a.H(b, d);
                    });
                    return a;
                }
                function de(a, b, c, d, e, f, g, k) {
                    if (b.w().j().e() && !lc(b.w())) return b;
                    var m = b;
                    c = c.e() ? d : pe(qe, c, d);
                    var l = b.w().j();
                    c.children.ka(function (c, d) {
                        if (l.Fa(c)) {
                            var I = b.w().j().T(c),
                                I = oe(I, d);
                            m = ae(a, m, new P(c), I, e, f, g, k);
                        }
                    });
                    c.children.ka(function (c, d) {
                        var I = !Wb(b.w(), c) && null == d.value;
                        l.Fa(c) ||
                            I ||
                            ((I = b.w().j().T(c)),
                            (I = oe(I, d)),
                            (m = ae(a, m, new P(c), I, e, f, g, k)));
                    });
                    return m;
                }
                function he(a, b, c, d, e, f, g) {
                    if (null != e.xc(c)) return b;
                    var k = mc(b.w()),
                        m = b.w();
                    if (null != d.value) {
                        if ((c.e() && m.ga) || nc(m, c))
                            return ae(a, b, c, m.j().S(c), e, f, k, g);
                        if (c.e()) {
                            var l = qe;
                            m.j().R(re, function (a, b) {
                                l = l.set(new P(a), b);
                            });
                            return de(a, b, c, l, e, f, k, g);
                        }
                        return b;
                    }
                    l = qe;
                    ne(d, function (a) {
                        var b = c.o(a);
                        nc(m, b) && (l = l.set(a, m.j().S(b)));
                    });
                    return de(a, b, c, l, e, f, k, g);
                }
                function se() {}
                var te = {};
                function Vd(a) {
                    return u(a.compare, a);
                }
                se.prototype.Dd = function (a, b) {
                    return (
                        0 !==
                        this.compare(
                            new L("[MIN_NAME]", a),
                            new L("[MIN_NAME]", b)
                        )
                    );
                };
                se.prototype.Wc = function () {
                    return ue;
                };
                function ve(a) {
                    O(
                        !a.e() && ".priority" !== K(a),
                        "Can't create PathIndex with empty path or .priority key"
                    );
                    this.gc = a;
                }
                ka(ve, se);
                h = ve.prototype;
                h.Lc = function (a) {
                    return !a.S(this.gc).e();
                };
                h.compare = function (a, b) {
                    var c = a.U.S(this.gc),
                        d = b.U.S(this.gc),
                        c = c.Gc(d);
                    return 0 === c ? yc(a.name, b.name) : c;
                };
                h.Sc = function (a, b) {
                    var c = Q(a),
                        c = H.H(this.gc, c);
                    return new L(b, c);
                };
                h.Tc = function () {
                    var a = H.H(this.gc, we);
                    return new L("[MAX_NAME]", a);
                };
                h.toString = function () {
                    return this.gc.slice().join("/");
                };
                function xe() {}
                ka(xe, se);
                h = xe.prototype;
                h.compare = function (a, b) {
                    var c = a.U.C(),
                        d = b.U.C(),
                        c = c.Gc(d);
                    return 0 === c ? yc(a.name, b.name) : c;
                };
                h.Lc = function (a) {
                    return !a.C().e();
                };
                h.Dd = function (a, b) {
                    return !a.C().ea(b.C());
                };
                h.Wc = function () {
                    return ue;
                };
                h.Tc = function () {
                    return new L("[MAX_NAME]", new Yc("[PRIORITY-POST]", we));
                };
                h.Sc = function (a, b) {
                    var c = Q(a);
                    return new L(b, new Yc("[PRIORITY-POST]", c));
                };
                h.toString = function () {
                    return ".priority";
                };
                var R = new xe();
                function ye() {}
                ka(ye, se);
                h = ye.prototype;
                h.compare = function (a, b) {
                    return yc(a.name, b.name);
                };
                h.Lc = function () {
                    throw jd("KeyIndex.isDefinedOn not expected to be called.");
                };
                h.Dd = function () {
                    return !1;
                };
                h.Wc = function () {
                    return ue;
                };
                h.Tc = function () {
                    return new L("[MAX_NAME]", H);
                };
                h.Sc = function (a) {
                    O(q(a), "KeyIndex indexValue must always be a string.");
                    return new L(a, H);
                };
                h.toString = function () {
                    return ".key";
                };
                var re = new ye();
                function ze() {}
                ka(ze, se);
                h = ze.prototype;
                h.compare = function (a, b) {
                    var c = a.U.Gc(b.U);
                    return 0 === c ? yc(a.name, b.name) : c;
                };
                h.Lc = function () {
                    return !0;
                };
                h.Dd = function (a, b) {
                    return !a.ea(b);
                };
                h.Wc = function () {
                    return ue;
                };
                h.Tc = function () {
                    return Ae;
                };
                h.Sc = function (a, b) {
                    var c = Q(a);
                    return new L(b, c);
                };
                h.toString = function () {
                    return ".value";
                };
                var Be = new ze();
                function Ce() {
                    this.Xb = this.ra = this.Pb = this.oa = this.la = !1;
                    this.ma = 0;
                    this.Rb = "";
                    this.ic = null;
                    this.Bb = "";
                    this.fc = null;
                    this.zb = "";
                    this.g = R;
                }
                var De = new Ce();
                function Td(a) {
                    return "" === a.Rb ? a.oa : "l" === a.Rb;
                }
                function Od(a) {
                    O(a.oa, "Only valid if start has been set");
                    return a.ic;
                }
                function Nd(a) {
                    O(a.oa, "Only valid if start has been set");
                    return a.Pb ? a.Bb : "[MIN_NAME]";
                }
                function Rd(a) {
                    O(a.ra, "Only valid if end has been set");
                    return a.fc;
                }
                function Pd(a) {
                    O(a.ra, "Only valid if end has been set");
                    return a.Xb ? a.zb : "[MAX_NAME]";
                }
                function Ee(a) {
                    var b = new Ce();
                    b.la = a.la;
                    b.ma = a.ma;
                    b.oa = a.oa;
                    b.ic = a.ic;
                    b.Pb = a.Pb;
                    b.Bb = a.Bb;
                    b.ra = a.ra;
                    b.fc = a.fc;
                    b.Xb = a.Xb;
                    b.zb = a.zb;
                    b.g = a.g;
                    return b;
                }
                h = Ce.prototype;
                h.Le = function (a) {
                    var b = Ee(this);
                    b.la = !0;
                    b.ma = a;
                    b.Rb = "";
                    return b;
                };
                h.Me = function (a) {
                    var b = Ee(this);
                    b.la = !0;
                    b.ma = a;
                    b.Rb = "l";
                    return b;
                };
                h.Ne = function (a) {
                    var b = Ee(this);
                    b.la = !0;
                    b.ma = a;
                    b.Rb = "r";
                    return b;
                };
                h.ce = function (a, b) {
                    var c = Ee(this);
                    c.oa = !0;
                    p(a) || (a = null);
                    c.ic = a;
                    null != b
                        ? ((c.Pb = !0), (c.Bb = b))
                        : ((c.Pb = !1), (c.Bb = ""));
                    return c;
                };
                h.vd = function (a, b) {
                    var c = Ee(this);
                    c.ra = !0;
                    p(a) || (a = null);
                    c.fc = a;
                    p(b)
                        ? ((c.Xb = !0), (c.zb = b))
                        : ((c.nh = !1), (c.zb = ""));
                    return c;
                };
                function Fe(a, b) {
                    var c = Ee(a);
                    c.g = b;
                    return c;
                }
                function Ge(a) {
                    var b = {};
                    a.oa && ((b.sp = a.ic), a.Pb && (b.sn = a.Bb));
                    a.ra && ((b.ep = a.fc), a.Xb && (b.en = a.zb));
                    if (a.la) {
                        b.l = a.ma;
                        var c = a.Rb;
                        "" === c && (c = Td(a) ? "l" : "r");
                        b.vf = c;
                    }
                    a.g !== R && (b.i = a.g.toString());
                    return b;
                }
                function He(a) {
                    return !(a.oa || a.ra || a.la);
                }
                function Ie(a) {
                    return He(a) && a.g == R;
                }
                function Je(a) {
                    var b = {};
                    if (Ie(a)) return b;
                    var c;
                    a.g === R
                        ? (c = "$priority")
                        : a.g === Be
                        ? (c = "$value")
                        : a.g === re
                        ? (c = "$key")
                        : (O(a.g instanceof ve, "Unrecognized index type!"),
                          (c = a.g.toString()));
                    b.orderBy = G(c);
                    a.oa &&
                        ((b.startAt = G(a.ic)),
                        a.Pb && (b.startAt += "," + G(a.Bb)));
                    a.ra &&
                        ((b.endAt = G(a.fc)),
                        a.Xb && (b.endAt += "," + G(a.zb)));
                    a.la &&
                        (Td(a)
                            ? (b.limitToFirst = a.ma)
                            : (b.limitToLast = a.ma));
                    return b;
                }
                h.toString = function () {
                    return G(Ge(this));
                };
                function Ke(a, b) {
                    this.Ed = a;
                    this.hc = b;
                }
                Ke.prototype.get = function (a) {
                    var b = z(this.Ed, a);
                    if (!b) throw Error("No index defined for " + a);
                    return b === te ? null : b;
                };
                function Le(a, b, c) {
                    var d = ma(a.Ed, function (d, f) {
                        var g = z(a.hc, f);
                        O(g, "Missing index implementation for " + f);
                        if (d === te) {
                            if (g.Lc(b.U)) {
                                for (var k = [], m = c.ac(wc), l = Ic(m); l; )
                                    l.name != b.name && k.push(l), (l = Ic(m));
                                k.push(b);
                                return Me(k, Vd(g));
                            }
                            return te;
                        }
                        g = c.get(b.name);
                        k = d;
                        g && (k = k.remove(new L(b.name, g)));
                        return k.Sa(b, b.U);
                    });
                    return new Ke(d, a.hc);
                }
                function Ne(a, b, c) {
                    var d = ma(a.Ed, function (a) {
                        if (a === te) return a;
                        var d = c.get(b.name);
                        return d ? a.remove(new L(b.name, d)) : a;
                    });
                    return new Ke(d, a.hc);
                }
                var Oe = new Ke({ ".priority": te }, { ".priority": R });
                function Yc(a, b) {
                    this.B = a;
                    O(
                        p(this.B) && null !== this.B,
                        "LeafNode shouldn't be created with null/undefined value."
                    );
                    this.ca = b || H;
                    Pe(this.ca);
                    this.Gb = null;
                }
                var Qe = ["object", "boolean", "number", "string"];
                h = Yc.prototype;
                h.L = function () {
                    return !0;
                };
                h.C = function () {
                    return this.ca;
                };
                h.ia = function (a) {
                    return new Yc(this.B, a);
                };
                h.T = function (a) {
                    return ".priority" === a ? this.ca : H;
                };
                h.S = function (a) {
                    return a.e() ? this : ".priority" === K(a) ? this.ca : H;
                };
                h.Fa = function () {
                    return !1;
                };
                h.wf = function () {
                    return null;
                };
                h.W = function (a, b) {
                    return ".priority" === a
                        ? this.ia(b)
                        : b.e() && ".priority" !== a
                        ? this
                        : H.W(a, b).ia(this.ca);
                };
                h.H = function (a, b) {
                    var c = K(a);
                    if (null === c) return b;
                    if (b.e() && ".priority" !== c) return this;
                    O(
                        ".priority" !== c || 1 === le(a),
                        ".priority must be the last token in a path"
                    );
                    return this.W(c, H.H(N(a), b));
                };
                h.e = function () {
                    return !1;
                };
                h.Hb = function () {
                    return 0;
                };
                h.R = function () {
                    return !1;
                };
                h.J = function (a) {
                    return a && !this.C().e()
                        ? { ".value": this.Ea(), ".priority": this.C().J() }
                        : this.Ea();
                };
                h.hash = function () {
                    if (null === this.Gb) {
                        var a = "";
                        this.ca.e() ||
                            (a += "priority:" + Re(this.ca.J()) + ":");
                        var b = typeof this.B,
                            a = a + (b + ":"),
                            a = "number" === b ? a + Ad(this.B) : a + this.B;
                        this.Gb = ld(a);
                    }
                    return this.Gb;
                };
                h.Ea = function () {
                    return this.B;
                };
                h.Gc = function (a) {
                    if (a === H) return 1;
                    if (a instanceof fe) return -1;
                    O(a.L(), "Unknown node type");
                    var b = typeof a.B,
                        c = typeof this.B,
                        d = La(Qe, b),
                        e = La(Qe, c);
                    O(0 <= d, "Unknown leaf type: " + b);
                    O(0 <= e, "Unknown leaf type: " + c);
                    return d === e
                        ? "object" === c
                            ? 0
                            : this.B < a.B
                            ? -1
                            : this.B === a.B
                            ? 0
                            : 1
                        : e - d;
                };
                h.pb = function () {
                    return this;
                };
                h.Mc = function () {
                    return !0;
                };
                h.ea = function (a) {
                    return a === this
                        ? !0
                        : a.L()
                        ? this.B === a.B && this.ca.ea(a.ca)
                        : !1;
                };
                h.toString = function () {
                    return G(this.J(!0));
                };
                function fe(a, b, c) {
                    this.m = a;
                    (this.ca = b) && Pe(this.ca);
                    a.e() &&
                        O(
                            !this.ca || this.ca.e(),
                            "An empty node cannot have a priority"
                        );
                    this.Ab = c;
                    this.Gb = null;
                }
                h = fe.prototype;
                h.L = function () {
                    return !1;
                };
                h.C = function () {
                    return this.ca || H;
                };
                h.ia = function (a) {
                    return this.m.e() ? this : new fe(this.m, a, this.Ab);
                };
                h.T = function (a) {
                    if (".priority" === a) return this.C();
                    a = this.m.get(a);
                    return null === a ? H : a;
                };
                h.S = function (a) {
                    var b = K(a);
                    return null === b ? this : this.T(b).S(N(a));
                };
                h.Fa = function (a) {
                    return null !== this.m.get(a);
                };
                h.W = function (a, b) {
                    O(b, "We should always be passing snapshot nodes");
                    if (".priority" === a) return this.ia(b);
                    var c = new L(a, b),
                        d,
                        e;
                    b.e()
                        ? ((d = this.m.remove(a)), (c = Ne(this.Ab, c, this.m)))
                        : ((d = this.m.Sa(a, b)), (c = Le(this.Ab, c, this.m)));
                    e = d.e() ? H : this.ca;
                    return new fe(d, e, c);
                };
                h.H = function (a, b) {
                    var c = K(a);
                    if (null === c) return b;
                    O(
                        ".priority" !== K(a) || 1 === le(a),
                        ".priority must be the last token in a path"
                    );
                    var d = this.T(c).H(N(a), b);
                    return this.W(c, d);
                };
                h.e = function () {
                    return this.m.e();
                };
                h.Hb = function () {
                    return this.m.count();
                };
                var Se = /^(0|[1-9]\d*)$/;
                h = fe.prototype;
                h.J = function (a) {
                    if (this.e()) return null;
                    var b = {},
                        c = 0,
                        d = 0,
                        e = !0;
                    this.R(R, function (f, g) {
                        b[f] = g.J(a);
                        c++;
                        e && Se.test(f)
                            ? (d = Math.max(d, Number(f)))
                            : (e = !1);
                    });
                    if (!a && e && d < 2 * c) {
                        var f = [],
                            g;
                        for (g in b) f[g] = b[g];
                        return f;
                    }
                    a && !this.C().e() && (b[".priority"] = this.C().J());
                    return b;
                };
                h.hash = function () {
                    if (null === this.Gb) {
                        var a = "";
                        this.C().e() ||
                            (a += "priority:" + Re(this.C().J()) + ":");
                        this.R(R, function (b, c) {
                            var d = c.hash();
                            "" !== d && (a += ":" + b + ":" + d);
                        });
                        this.Gb = "" === a ? "" : ld(a);
                    }
                    return this.Gb;
                };
                h.wf = function (a, b, c) {
                    return (c = Te(this, c))
                        ? (a = Gc(c, new L(a, b)))
                            ? a.name
                            : null
                        : Gc(this.m, a);
                };
                function Wd(a, b) {
                    var c;
                    c = (c = Te(a, b)) ? (c = c.Vc()) && c.name : a.m.Vc();
                    return c ? new L(c, a.m.get(c)) : null;
                }
                function Xd(a, b) {
                    var c;
                    c = (c = Te(a, b)) ? (c = c.jc()) && c.name : a.m.jc();
                    return c ? new L(c, a.m.get(c)) : null;
                }
                h.R = function (a, b) {
                    var c = Te(this, a);
                    return c
                        ? c.ka(function (a) {
                              return b(a.name, a.U);
                          })
                        : this.m.ka(b);
                };
                h.ac = function (a) {
                    return this.bc(a.Wc(), a);
                };
                h.bc = function (a, b) {
                    var c = Te(this, b);
                    if (c)
                        return c.bc(a, function (a) {
                            return a;
                        });
                    for (
                        var c = this.m.bc(a.name, wc), d = Jc(c);
                        null != d && 0 > b.compare(d, a);

                    )
                        Ic(c), (d = Jc(c));
                    return c;
                };
                h.xf = function (a) {
                    return this.dc(a.Tc(), a);
                };
                h.dc = function (a, b) {
                    var c = Te(this, b);
                    if (c)
                        return c.dc(a, function (a) {
                            return a;
                        });
                    for (
                        var c = this.m.dc(a.name, wc), d = Jc(c);
                        null != d && 0 < b.compare(d, a);

                    )
                        Ic(c), (d = Jc(c));
                    return c;
                };
                h.Gc = function (a) {
                    return this.e()
                        ? a.e()
                            ? 0
                            : -1
                        : a.L() || a.e()
                        ? 1
                        : a === we
                        ? -1
                        : 0;
                };
                h.pb = function (a) {
                    if (a === re || sa(this.Ab.hc, a.toString())) return this;
                    var b = this.Ab,
                        c = this.m;
                    O(
                        a !== re,
                        "KeyIndex always exists and isn't meant to be added to the IndexMap."
                    );
                    for (var d = [], e = !1, c = c.ac(wc), f = Ic(c); f; )
                        (e = e || a.Lc(f.U)), d.push(f), (f = Ic(c));
                    d = e ? Me(d, Vd(a)) : te;
                    e = a.toString();
                    c = wa(b.hc);
                    c[e] = a;
                    a = wa(b.Ed);
                    a[e] = d;
                    return new fe(this.m, this.ca, new Ke(a, c));
                };
                h.Mc = function (a) {
                    return a === re || sa(this.Ab.hc, a.toString());
                };
                h.ea = function (a) {
                    if (a === this) return !0;
                    if (a.L()) return !1;
                    if (this.C().ea(a.C()) && this.m.count() === a.m.count()) {
                        var b = this.ac(R);
                        a = a.ac(R);
                        for (var c = Ic(b), d = Ic(a); c && d; ) {
                            if (c.name !== d.name || !c.U.ea(d.U)) return !1;
                            c = Ic(b);
                            d = Ic(a);
                        }
                        return null === c && null === d;
                    }
                    return !1;
                };
                function Te(a, b) {
                    return b === re ? null : a.Ab.get(b.toString());
                }
                h.toString = function () {
                    return G(this.J(!0));
                };
                function Q(a, b) {
                    if (null === a) return H;
                    var c = null;
                    "object" === typeof a && ".priority" in a
                        ? (c = a[".priority"])
                        : "undefined" !== typeof b && (c = b);
                    O(
                        null === c ||
                            "string" === typeof c ||
                            "number" === typeof c ||
                            ("object" === typeof c && ".sv" in c),
                        "Invalid priority type found: " + typeof c
                    );
                    "object" === typeof a &&
                        ".value" in a &&
                        null !== a[".value"] &&
                        (a = a[".value"]);
                    if ("object" !== typeof a || ".sv" in a)
                        return new Yc(a, Q(c));
                    if (a instanceof Array) {
                        var d = H,
                            e = a;
                        v(e, function (a, b) {
                            if (y(e, b) && "." !== b.substring(0, 1)) {
                                var c = Q(a);
                                if (c.L() || !c.e()) d = d.W(b, c);
                            }
                        });
                        return d.ia(Q(c));
                    }
                    var f = [],
                        g = !1,
                        k = a;
                    Fb(k, function (a) {
                        if (
                            "string" !== typeof a ||
                            "." !== a.substring(0, 1)
                        ) {
                            var b = Q(k[a]);
                            b.e() ||
                                ((g = g || !b.C().e()), f.push(new L(a, b)));
                        }
                    });
                    if (0 == f.length) return H;
                    var m = Me(
                        f,
                        xc,
                        function (a) {
                            return a.name;
                        },
                        zc
                    );
                    if (g) {
                        var l = Me(f, Vd(R));
                        return new fe(
                            m,
                            Q(c),
                            new Ke({ ".priority": l }, { ".priority": R })
                        );
                    }
                    return new fe(m, Q(c), Oe);
                }
                var Ue = Math.log(2);
                function Ve(a) {
                    this.count = parseInt(Math.log(a + 1) / Ue, 10);
                    this.nf = this.count - 1;
                    this.ng =
                        (a + 1) & parseInt(Array(this.count + 1).join("1"), 2);
                }
                function We(a) {
                    var b = !(a.ng & (1 << a.nf));
                    a.nf--;
                    return b;
                }
                function Me(a, b, c, d) {
                    function e(b, d) {
                        var f = d - b;
                        if (0 == f) return null;
                        if (1 == f) {
                            var l = a[b],
                                t = c ? c(l) : l;
                            return new Kc(t, l.U, !1, null, null);
                        }
                        var l = parseInt(f / 2, 10) + b,
                            f = e(b, l),
                            A = e(l + 1, d),
                            l = a[l],
                            t = c ? c(l) : l;
                        return new Kc(t, l.U, !1, f, A);
                    }
                    a.sort(b);
                    var f = (function (b) {
                        function d(b, g) {
                            var k = t - b,
                                A = t;
                            t -= b;
                            var A = e(k + 1, A),
                                k = a[k],
                                I = c ? c(k) : k,
                                A = new Kc(I, k.U, g, null, A);
                            f ? (f.left = A) : (l = A);
                            f = A;
                        }
                        for (
                            var f = null, l = null, t = a.length, A = 0;
                            A < b.count;
                            ++A
                        ) {
                            var I = We(b),
                                Qd = Math.pow(2, b.count - (A + 1));
                            I ? d(Qd, !1) : (d(Qd, !1), d(Qd, !0));
                        }
                        return l;
                    })(new Ve(a.length));
                    return null !== f ? new Ec(d || b, f) : new Ec(d || b);
                }
                function Re(a) {
                    return "number" === typeof a
                        ? "number:" + Ad(a)
                        : "string:" + a;
                }
                function Pe(a) {
                    if (a.L()) {
                        var b = a.J();
                        O(
                            "string" === typeof b ||
                                "number" === typeof b ||
                                ("object" === typeof b && y(b, ".sv")),
                            "Priority must be a string or number."
                        );
                    } else O(a === we || a.e(), "priority of unexpected type.");
                    O(
                        a === we || a.C().e(),
                        "Priority nodes can't have a priority of their own."
                    );
                }
                var H = new fe(new Ec(zc), null, Oe);
                function Xe() {
                    fe.call(this, new Ec(zc), H, Oe);
                }
                ka(Xe, fe);
                h = Xe.prototype;
                h.Gc = function (a) {
                    return a === this ? 0 : 1;
                };
                h.ea = function (a) {
                    return a === this;
                };
                h.C = function () {
                    return this;
                };
                h.T = function () {
                    return H;
                };
                h.e = function () {
                    return !1;
                };
                var we = new Xe(),
                    ue = new L("[MIN_NAME]", H),
                    Ae = new L("[MAX_NAME]", we);
                function je(a, b) {
                    this.Q = a;
                    this.ae = b;
                }
                function ge(a, b, c, d) {
                    return new je(new Xb(b, c, d), a.ae);
                }
                function ke(a) {
                    return a.Q.ga ? a.Q.j() : null;
                }
                je.prototype.w = function () {
                    return this.ae;
                };
                function Yb(a) {
                    return a.ae.ga ? a.ae.j() : null;
                }
                function Ye(a, b) {
                    this.Y = a;
                    var c = a.n,
                        d = new Ld(c.g),
                        c = He(c) ? new Ld(c.g) : c.la ? new Sd(c) : new Md(c);
                    this.Nf = new Zd(c);
                    var e = b.w(),
                        f = b.Q,
                        g = d.ya(H, e.j(), null),
                        k = c.ya(H, f.j(), null);
                    this.Oa = new je(
                        new Xb(k, f.ga, c.Ra()),
                        new Xb(g, e.ga, d.Ra())
                    );
                    this.$a = [];
                    this.ug = new Fd(a);
                }
                function Ze(a) {
                    return a.Y;
                }
                h = Ye.prototype;
                h.w = function () {
                    return this.Oa.w().j();
                };
                h.kb = function (a) {
                    var b = Yb(this.Oa);
                    return b && (He(this.Y.n) || (!a.e() && !b.T(K(a)).e()))
                        ? b.S(a)
                        : null;
                };
                h.e = function () {
                    return 0 === this.$a.length;
                };
                h.Tb = function (a) {
                    this.$a.push(a);
                };
                h.nb = function (a, b) {
                    var c = [];
                    if (b) {
                        O(
                            null == a,
                            "A cancel should cancel all event registrations."
                        );
                        var d = this.Y.path;
                        Ma(this.$a, function (a) {
                            (a = a.lf(b, d)) && c.push(a);
                        });
                    }
                    if (a) {
                        for (var e = [], f = 0; f < this.$a.length; ++f) {
                            var g = this.$a[f];
                            if (!g.matches(a)) e.push(g);
                            else if (a.yf()) {
                                e = e.concat(this.$a.slice(f + 1));
                                break;
                            }
                        }
                        this.$a = e;
                    } else this.$a = [];
                    return c;
                };
                h.gb = function (a, b, c) {
                    a.type === be &&
                        null !== a.source.Lb &&
                        (O(
                            Yb(this.Oa),
                            "We should always have a full cache before handling merges"
                        ),
                        O(
                            ke(this.Oa),
                            "Missing event cache, even though we have a server cache"
                        ));
                    var d = this.Oa;
                    a = this.Nf.gb(d, a, b, c);
                    b = this.Nf;
                    c = a.me;
                    O(c.Q.j().Mc(b.X.g), "Event snap not indexed");
                    O(c.w().j().Mc(b.X.g), "Server snap not indexed");
                    O(
                        lc(a.me.w()) || !lc(d.w()),
                        "Once a server snap is complete, it should never go back"
                    );
                    this.Oa = a.me;
                    return $e(this, a.og, a.me.Q.j(), null);
                };
                function af(a, b) {
                    var c = a.Oa.Q,
                        d = [];
                    c.j().L() ||
                        c.j().R(R, function (a, b) {
                            d.push(new J("child_added", b, a));
                        });
                    c.ga && d.push(hc(c.j()));
                    return $e(a, d, c.j(), b);
                }
                function $e(a, b, c, d) {
                    return Gd(a.ug, b, c, d ? [d] : a.$a);
                }
                function bf(a, b, c) {
                    this.type = be;
                    this.source = a;
                    this.path = b;
                    this.children = c;
                }
                bf.prototype.$c = function (a) {
                    if (this.path.e())
                        return (
                            (a = this.children.subtree(new P(a))),
                            a.e()
                                ? null
                                : a.value
                                ? new Ac(this.source, M, a.value)
                                : new bf(this.source, M, a)
                        );
                    O(
                        K(this.path) === a,
                        "Can't get a merge for a child not on the path of the operation"
                    );
                    return new bf(this.source, N(this.path), this.children);
                };
                bf.prototype.toString = function () {
                    return (
                        "Operation(" +
                        this.path +
                        ": " +
                        this.source.toString() +
                        " merge: " +
                        this.children.toString() +
                        ")"
                    );
                };
                function cf(a, b) {
                    this.f = pd("p:rest:");
                    this.G = a;
                    this.Kb = b;
                    this.Ca = null;
                    this.ba = {};
                }
                function df(a, b) {
                    if (p(b)) return "tag$" + b;
                    O(
                        Ie(a.n),
                        "should have a tag if it's not a default query."
                    );
                    return a.path.toString();
                }
                h = cf.prototype;
                h.Cf = function (a, b, c, d) {
                    var e = a.path.toString();
                    this.f("Listen called for " + e + " " + a.wa());
                    var f = df(a, c),
                        g = {};
                    this.ba[f] = g;
                    a = Je(a.n);
                    var k = this;
                    ef(this, e + ".json", a, function (a, b) {
                        var t = b;
                        404 === a && (a = t = null);
                        null === a && k.Kb(e, t, !1, c);
                        z(k.ba, f) === g &&
                            d(
                                a
                                    ? 401 == a
                                        ? "permission_denied"
                                        : "rest_error:" + a
                                    : "ok",
                                null
                            );
                    });
                };
                h.$f = function (a, b) {
                    var c = df(a, b);
                    delete this.ba[c];
                };
                h.O = function (a, b) {
                    this.Ca = a;
                    var c = Cd(a),
                        d = c.data,
                        c = c.Ec && c.Ec.exp;
                    b && b("ok", { auth: d, expires: c });
                };
                h.je = function (a) {
                    this.Ca = null;
                    a("ok", null);
                };
                h.Qe = function () {};
                h.Gf = function () {};
                h.Md = function () {};
                h.put = function () {};
                h.Df = function () {};
                h.Ye = function () {};
                function ef(a, b, c, d) {
                    c = c || {};
                    c.format = "export";
                    a.Ca && (c.auth = a.Ca);
                    var e =
                        (a.G.ob ? "https://" : "http://") +
                        a.G.host +
                        b +
                        "?" +
                        Ib(c);
                    a.f("Sending REST request for " + e);
                    var f = new XMLHttpRequest();
                    f.onreadystatechange = function () {
                        if (d && 4 === f.readyState) {
                            a.f(
                                "REST Response for " + e + " received. status:",
                                f.status,
                                "response:",
                                f.responseText
                            );
                            var b = null;
                            if (200 <= f.status && 300 > f.status) {
                                try {
                                    b = Rb(f.responseText);
                                } catch (c) {
                                    S(
                                        "Failed to parse JSON response for " +
                                            e +
                                            ": " +
                                            f.responseText
                                    );
                                }
                                d(null, b);
                            } else
                                401 !== f.status &&
                                    404 !== f.status &&
                                    S(
                                        "Got unsuccessful REST response for " +
                                            e +
                                            " Status: " +
                                            f.status
                                    ),
                                    d(f.status);
                            d = null;
                        }
                    };
                    f.open("GET", e, !0);
                    f.send();
                }
                function ff(a) {
                    O(da(a) && 0 < a.length, "Requires a non-empty array");
                    this.fg = a;
                    this.Rc = {};
                }
                ff.prototype.ie = function (a, b) {
                    var c;
                    c = this.Rc[a] || [];
                    var d = c.length;
                    if (0 < d) {
                        for (var e = Array(d), f = 0; f < d; f++) e[f] = c[f];
                        c = e;
                    } else c = [];
                    for (d = 0; d < c.length; d++)
                        c[d].Dc.apply(
                            c[d].Qa,
                            Array.prototype.slice.call(arguments, 1)
                        );
                };
                ff.prototype.Ib = function (a, b, c) {
                    gf(this, a);
                    this.Rc[a] = this.Rc[a] || [];
                    this.Rc[a].push({ Dc: b, Qa: c });
                    (a = this.Ee(a)) && b.apply(c, a);
                };
                ff.prototype.mc = function (a, b, c) {
                    gf(this, a);
                    a = this.Rc[a] || [];
                    for (var d = 0; d < a.length; d++)
                        if (a[d].Dc === b && (!c || c === a[d].Qa)) {
                            a.splice(d, 1);
                            break;
                        }
                };
                function gf(a, b) {
                    O(
                        Ra(a.fg, function (a) {
                            return a === b;
                        }),
                        "Unknown event: " + b
                    );
                }
                var hf = (function () {
                    var a = 0,
                        b = [];
                    return function (c) {
                        var d = c === a;
                        a = c;
                        for (var e = Array(8), f = 7; 0 <= f; f--)
                            (e[f] =
                                "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(
                                    c % 64
                                )),
                                (c = Math.floor(c / 64));
                        O(0 === c, "Cannot push at time == 0");
                        c = e.join("");
                        if (d) {
                            for (f = 11; 0 <= f && 63 === b[f]; f--) b[f] = 0;
                            b[f]++;
                        } else
                            for (f = 0; 12 > f; f++)
                                b[f] = Math.floor(64 * Math.random());
                        for (f = 0; 12 > f; f++)
                            c +=
                                "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(
                                    b[f]
                                );
                        O(20 === c.length, "nextPushId: Length should be 20.");
                        return c;
                    };
                })();
                function jf() {
                    ff.call(this, ["online"]);
                    this.oc = !0;
                    if (
                        "undefined" !== typeof window &&
                        "undefined" !== typeof window.addEventListener
                    ) {
                        var a = this;
                        window.addEventListener(
                            "online",
                            function () {
                                a.oc || ((a.oc = !0), a.ie("online", !0));
                            },
                            !1
                        );
                        window.addEventListener(
                            "offline",
                            function () {
                                a.oc && ((a.oc = !1), a.ie("online", !1));
                            },
                            !1
                        );
                    }
                }
                ka(jf, ff);
                jf.prototype.Ee = function (a) {
                    O("online" === a, "Unknown event type: " + a);
                    return [this.oc];
                };
                ba(jf);
                function kf() {
                    ff.call(this, ["visible"]);
                    var a, b;
                    "undefined" !== typeof document &&
                        "undefined" !== typeof document.addEventListener &&
                        ("undefined" !== typeof document.hidden
                            ? ((b = "visibilitychange"), (a = "hidden"))
                            : "undefined" !== typeof document.mozHidden
                            ? ((b = "mozvisibilitychange"), (a = "mozHidden"))
                            : "undefined" !== typeof document.msHidden
                            ? ((b = "msvisibilitychange"), (a = "msHidden"))
                            : "undefined" !== typeof document.webkitHidden &&
                              ((b = "webkitvisibilitychange"),
                              (a = "webkitHidden")));
                    this.Sb = !0;
                    if (b) {
                        var c = this;
                        document.addEventListener(
                            b,
                            function () {
                                var b = !document[a];
                                b !== c.Sb && ((c.Sb = b), c.ie("visible", b));
                            },
                            !1
                        );
                    }
                }
                ka(kf, ff);
                kf.prototype.Ee = function (a) {
                    O("visible" === a, "Unknown event type: " + a);
                    return [this.Sb];
                };
                ba(kf);
                function P(a, b) {
                    if (1 == arguments.length) {
                        this.u = a.split("/");
                        for (var c = 0, d = 0; d < this.u.length; d++)
                            0 < this.u[d].length &&
                                ((this.u[c] = this.u[d]), c++);
                        this.u.length = c;
                        this.aa = 0;
                    } else (this.u = a), (this.aa = b);
                }
                function lf(a, b) {
                    var c = K(a);
                    if (null === c) return b;
                    if (c === K(b)) return lf(N(a), N(b));
                    throw Error(
                        "INTERNAL ERROR: innerPath (" +
                            b +
                            ") is not within outerPath (" +
                            a +
                            ")"
                    );
                }
                function mf(a, b) {
                    for (
                        var c = a.slice(), d = b.slice(), e = 0;
                        e < c.length && e < d.length;
                        e++
                    ) {
                        var f = yc(c[e], d[e]);
                        if (0 !== f) return f;
                    }
                    return c.length === d.length
                        ? 0
                        : c.length < d.length
                        ? -1
                        : 1;
                }
                function K(a) {
                    return a.aa >= a.u.length ? null : a.u[a.aa];
                }
                function le(a) {
                    return a.u.length - a.aa;
                }
                function N(a) {
                    var b = a.aa;
                    b < a.u.length && b++;
                    return new P(a.u, b);
                }
                function me(a) {
                    return a.aa < a.u.length ? a.u[a.u.length - 1] : null;
                }
                h = P.prototype;
                h.toString = function () {
                    for (var a = "", b = this.aa; b < this.u.length; b++)
                        "" !== this.u[b] && (a += "/" + this.u[b]);
                    return a || "/";
                };
                h.slice = function (a) {
                    return this.u.slice(this.aa + (a || 0));
                };
                h.parent = function () {
                    if (this.aa >= this.u.length) return null;
                    for (var a = [], b = this.aa; b < this.u.length - 1; b++)
                        a.push(this.u[b]);
                    return new P(a, 0);
                };
                h.o = function (a) {
                    for (var b = [], c = this.aa; c < this.u.length; c++)
                        b.push(this.u[c]);
                    if (a instanceof P)
                        for (c = a.aa; c < a.u.length; c++) b.push(a.u[c]);
                    else
                        for (a = a.split("/"), c = 0; c < a.length; c++)
                            0 < a[c].length && b.push(a[c]);
                    return new P(b, 0);
                };
                h.e = function () {
                    return this.aa >= this.u.length;
                };
                h.ea = function (a) {
                    if (le(this) !== le(a)) return !1;
                    for (
                        var b = this.aa, c = a.aa;
                        b <= this.u.length;
                        b++, c++
                    )
                        if (this.u[b] !== a.u[c]) return !1;
                    return !0;
                };
                h.contains = function (a) {
                    var b = this.aa,
                        c = a.aa;
                    if (le(this) > le(a)) return !1;
                    for (; b < this.u.length; ) {
                        if (this.u[b] !== a.u[c]) return !1;
                        ++b;
                        ++c;
                    }
                    return !0;
                };
                var M = new P("");
                function nf(a, b) {
                    this.Ua = a.slice();
                    this.Ka = Math.max(1, this.Ua.length);
                    this.pf = b;
                    for (var c = 0; c < this.Ua.length; c++)
                        this.Ka += Pb(this.Ua[c]);
                    of(this);
                }
                nf.prototype.push = function (a) {
                    0 < this.Ua.length && (this.Ka += 1);
                    this.Ua.push(a);
                    this.Ka += Pb(a);
                    of(this);
                };
                nf.prototype.pop = function () {
                    var a = this.Ua.pop();
                    this.Ka -= Pb(a);
                    0 < this.Ua.length && --this.Ka;
                };
                function of(a) {
                    if (768 < a.Ka)
                        throw Error(
                            a.pf +
                                "has a key path longer than 768 bytes (" +
                                a.Ka +
                                ")."
                        );
                    if (32 < a.Ua.length)
                        throw Error(
                            a.pf +
                                "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " +
                                pf(a)
                        );
                }
                function pf(a) {
                    return 0 == a.Ua.length
                        ? ""
                        : "in property '" + a.Ua.join(".") + "'";
                }
                function qf(a, b) {
                    this.value = a;
                    this.children = b || rf;
                }
                var rf = new Ec(function (a, b) {
                    return a === b ? 0 : a < b ? -1 : 1;
                });
                function sf(a) {
                    var b = qe;
                    v(a, function (a, d) {
                        b = b.set(new P(d), a);
                    });
                    return b;
                }
                h = qf.prototype;
                h.e = function () {
                    return null === this.value && this.children.e();
                };
                function tf(a, b, c) {
                    if (null != a.value && c(a.value))
                        return { path: M, value: a.value };
                    if (b.e()) return null;
                    var d = K(b);
                    a = a.children.get(d);
                    return null !== a
                        ? ((b = tf(a, N(b), c)),
                          null != b
                              ? { path: new P(d).o(b.path), value: b.value }
                              : null)
                        : null;
                }
                function uf(a, b) {
                    return tf(a, b, function () {
                        return !0;
                    });
                }
                h.subtree = function (a) {
                    if (a.e()) return this;
                    var b = this.children.get(K(a));
                    return null !== b ? b.subtree(N(a)) : qe;
                };
                h.set = function (a, b) {
                    if (a.e()) return new qf(b, this.children);
                    var c = K(a),
                        d = (this.children.get(c) || qe).set(N(a), b),
                        c = this.children.Sa(c, d);
                    return new qf(this.value, c);
                };
                h.remove = function (a) {
                    if (a.e())
                        return this.children.e()
                            ? qe
                            : new qf(null, this.children);
                    var b = K(a),
                        c = this.children.get(b);
                    return c
                        ? ((a = c.remove(N(a))),
                          (b = a.e()
                              ? this.children.remove(b)
                              : this.children.Sa(b, a)),
                          null === this.value && b.e()
                              ? qe
                              : new qf(this.value, b))
                        : this;
                };
                h.get = function (a) {
                    if (a.e()) return this.value;
                    var b = this.children.get(K(a));
                    return b ? b.get(N(a)) : null;
                };
                function pe(a, b, c) {
                    if (b.e()) return c;
                    var d = K(b);
                    b = pe(a.children.get(d) || qe, N(b), c);
                    d = b.e() ? a.children.remove(d) : a.children.Sa(d, b);
                    return new qf(a.value, d);
                }
                function vf(a, b) {
                    return wf(a, M, b);
                }
                function wf(a, b, c) {
                    var d = {};
                    a.children.ka(function (a, f) {
                        d[a] = wf(f, b.o(a), c);
                    });
                    return c(b, a.value, d);
                }
                function xf(a, b, c) {
                    return yf(a, b, M, c);
                }
                function yf(a, b, c, d) {
                    var e = a.value ? d(c, a.value) : !1;
                    if (e) return e;
                    if (b.e()) return null;
                    e = K(b);
                    return (a = a.children.get(e))
                        ? yf(a, N(b), c.o(e), d)
                        : null;
                }
                function zf(a, b, c) {
                    Af(a, b, M, c);
                }
                function Af(a, b, c, d) {
                    if (b.e()) return a;
                    a.value && d(c, a.value);
                    var e = K(b);
                    return (a = a.children.get(e))
                        ? Af(a, N(b), c.o(e), d)
                        : qe;
                }
                function ne(a, b) {
                    Bf(a, M, b);
                }
                function Bf(a, b, c) {
                    a.children.ka(function (a, e) {
                        Bf(e, b.o(a), c);
                    });
                    a.value && c(b, a.value);
                }
                function Cf(a, b) {
                    a.children.ka(function (a, d) {
                        d.value && b(a, d.value);
                    });
                }
                var qe = new qf(null);
                qf.prototype.toString = function () {
                    var a = {};
                    ne(this, function (b, c) {
                        a[b.toString()] = c.toString();
                    });
                    return G(a);
                };
                function Df(a, b, c) {
                    this.type = ee;
                    this.source = Ef;
                    this.path = a;
                    this.Ub = b;
                    this.Yd = c;
                }
                Df.prototype.$c = function (a) {
                    if (this.path.e()) {
                        if (null != this.Ub.value)
                            return (
                                O(
                                    this.Ub.children.e(),
                                    "affectedTree should not have overlapping affected paths."
                                ),
                                this
                            );
                        a = this.Ub.subtree(new P(a));
                        return new Df(M, a, this.Yd);
                    }
                    O(
                        K(this.path) === a,
                        "operationForChild called for unrelated child."
                    );
                    return new Df(N(this.path), this.Ub, this.Yd);
                };
                Df.prototype.toString = function () {
                    return (
                        "Operation(" +
                        this.path +
                        ": " +
                        this.source.toString() +
                        " ack write revert=" +
                        this.Yd +
                        " affectedTree=" +
                        this.Ub +
                        ")"
                    );
                };
                var Bc = 0,
                    be = 1,
                    ee = 2,
                    Dc = 3;
                function Ff(a, b, c, d) {
                    this.Ae = a;
                    this.tf = b;
                    this.Lb = c;
                    this.ef = d;
                    O(!d || b, "Tagged queries must be from server.");
                }
                var Ef = new Ff(!0, !1, null, !1),
                    Gf = new Ff(!1, !0, null, !1);
                Ff.prototype.toString = function () {
                    return this.Ae
                        ? "user"
                        : this.ef
                        ? "server(queryID=" + this.Lb + ")"
                        : "server";
                };
                function Hf(a) {
                    this.Z = a;
                }
                var If = new Hf(new qf(null));
                function Jf(a, b, c) {
                    if (b.e()) return new Hf(new qf(c));
                    var d = uf(a.Z, b);
                    if (null != d) {
                        var e = d.path,
                            d = d.value;
                        b = lf(e, b);
                        d = d.H(b, c);
                        return new Hf(a.Z.set(e, d));
                    }
                    a = pe(a.Z, b, new qf(c));
                    return new Hf(a);
                }
                function Kf(a, b, c) {
                    var d = a;
                    Fb(c, function (a, c) {
                        d = Jf(d, b.o(a), c);
                    });
                    return d;
                }
                Hf.prototype.Ud = function (a) {
                    if (a.e()) return If;
                    a = pe(this.Z, a, qe);
                    return new Hf(a);
                };
                function Lf(a, b) {
                    var c = uf(a.Z, b);
                    return null != c ? a.Z.get(c.path).S(lf(c.path, b)) : null;
                }
                function Mf(a) {
                    var b = [],
                        c = a.Z.value;
                    null != c
                        ? c.L() ||
                          c.R(R, function (a, c) {
                              b.push(new L(a, c));
                          })
                        : a.Z.children.ka(function (a, c) {
                              null != c.value && b.push(new L(a, c.value));
                          });
                    return b;
                }
                function Nf(a, b) {
                    if (b.e()) return a;
                    var c = Lf(a, b);
                    return null != c
                        ? new Hf(new qf(c))
                        : new Hf(a.Z.subtree(b));
                }
                Hf.prototype.e = function () {
                    return this.Z.e();
                };
                Hf.prototype.apply = function (a) {
                    return Of(M, this.Z, a);
                };
                function Of(a, b, c) {
                    if (null != b.value) return c.H(a, b.value);
                    var d = null;
                    b.children.ka(function (b, f) {
                        ".priority" === b
                            ? (O(
                                  null !== f.value,
                                  "Priority writes must always be leaf nodes"
                              ),
                              (d = f.value))
                            : (c = Of(a.o(b), f, c));
                    });
                    c.S(a).e() || null === d || (c = c.H(a.o(".priority"), d));
                    return c;
                }
                function Pf() {
                    this.V = If;
                    this.pa = [];
                    this.Pc = -1;
                }
                function Qf(a, b) {
                    for (var c = 0; c < a.pa.length; c++) {
                        var d = a.pa[c];
                        if (d.md === b) return d;
                    }
                    return null;
                }
                h = Pf.prototype;
                h.Ud = function (a) {
                    var b = Sa(this.pa, function (b) {
                        return b.md === a;
                    });
                    O(0 <= b, "removeWrite called with nonexistent writeId.");
                    var c = this.pa[b];
                    this.pa.splice(b, 1);
                    for (
                        var d = c.visible, e = !1, f = this.pa.length - 1;
                        d && 0 <= f;

                    ) {
                        var g = this.pa[f];
                        g.visible &&
                            (f >= b && Rf(g, c.path)
                                ? (d = !1)
                                : c.path.contains(g.path) && (e = !0));
                        f--;
                    }
                    if (d) {
                        if (e)
                            (this.V = Sf(this.pa, Tf, M)),
                                (this.Pc =
                                    0 < this.pa.length
                                        ? this.pa[this.pa.length - 1].md
                                        : -1);
                        else if (c.Ja) this.V = this.V.Ud(c.path);
                        else {
                            var k = this;
                            v(c.children, function (a, b) {
                                k.V = k.V.Ud(c.path.o(b));
                            });
                        }
                        return !0;
                    }
                    return !1;
                };
                h.Aa = function (a, b, c, d) {
                    if (c || d) {
                        var e = Nf(this.V, a);
                        return !d && e.e()
                            ? b
                            : d || null != b || null != Lf(e, M)
                            ? ((e = Sf(
                                  this.pa,
                                  function (b) {
                                      return (
                                          (b.visible || d) &&
                                          (!c || !(0 <= La(c, b.md))) &&
                                          (b.path.contains(a) ||
                                              a.contains(b.path))
                                      );
                                  },
                                  a
                              )),
                              (b = b || H),
                              e.apply(b))
                            : null;
                    }
                    e = Lf(this.V, a);
                    if (null != e) return e;
                    e = Nf(this.V, a);
                    return e.e()
                        ? b
                        : null != b || null != Lf(e, M)
                        ? ((b = b || H), e.apply(b))
                        : null;
                };
                h.Cc = function (a, b) {
                    var c = H,
                        d = Lf(this.V, a);
                    if (d)
                        d.L() ||
                            d.R(R, function (a, b) {
                                c = c.W(a, b);
                            });
                    else if (b) {
                        var e = Nf(this.V, a);
                        b.R(R, function (a, b) {
                            var d = Nf(e, new P(a)).apply(b);
                            c = c.W(a, d);
                        });
                        Ma(Mf(e), function (a) {
                            c = c.W(a.name, a.U);
                        });
                    } else
                        (e = Nf(this.V, a)),
                            Ma(Mf(e), function (a) {
                                c = c.W(a.name, a.U);
                            });
                    return c;
                };
                h.nd = function (a, b, c, d) {
                    O(
                        c || d,
                        "Either existingEventSnap or existingServerSnap must exist"
                    );
                    a = a.o(b);
                    if (null != Lf(this.V, a)) return null;
                    a = Nf(this.V, a);
                    return a.e() ? d.S(b) : a.apply(d.S(b));
                };
                h.Bc = function (a, b, c) {
                    a = a.o(b);
                    var d = Lf(this.V, a);
                    return null != d
                        ? d
                        : Wb(c, b)
                        ? Nf(this.V, a).apply(c.j().T(b))
                        : null;
                };
                h.xc = function (a) {
                    return Lf(this.V, a);
                };
                h.qe = function (a, b, c, d, e, f) {
                    var g;
                    a = Nf(this.V, a);
                    g = Lf(a, M);
                    if (null == g)
                        if (null != b) g = a.apply(b);
                        else return [];
                    g = g.pb(f);
                    if (g.e() || g.L()) return [];
                    b = [];
                    a = Vd(f);
                    e = e ? g.dc(c, f) : g.bc(c, f);
                    for (f = Ic(e); f && b.length < d; )
                        0 !== a(f, c) && b.push(f), (f = Ic(e));
                    return b;
                };
                function Rf(a, b) {
                    return a.Ja
                        ? a.path.contains(b)
                        : !!ta(a.children, function (c, d) {
                              return a.path.o(d).contains(b);
                          });
                }
                function Tf(a) {
                    return a.visible;
                }
                function Sf(a, b, c) {
                    for (var d = If, e = 0; e < a.length; ++e) {
                        var f = a[e];
                        if (b(f)) {
                            var g = f.path;
                            if (f.Ja)
                                c.contains(g)
                                    ? ((g = lf(c, g)), (d = Jf(d, g, f.Ja)))
                                    : g.contains(c) &&
                                      ((g = lf(g, c)),
                                      (d = Jf(d, M, f.Ja.S(g))));
                            else if (f.children)
                                if (c.contains(g))
                                    (g = lf(c, g)), (d = Kf(d, g, f.children));
                                else {
                                    if (g.contains(c))
                                        if (((g = lf(g, c)), g.e()))
                                            d = Kf(d, M, f.children);
                                        else if ((f = z(f.children, K(g))))
                                            (f = f.S(N(g))), (d = Jf(d, M, f));
                                }
                            else
                                throw jd(
                                    "WriteRecord should have .snap or .children"
                                );
                        }
                    }
                    return d;
                }
                function Uf(a, b) {
                    this.Qb = a;
                    this.Z = b;
                }
                h = Uf.prototype;
                h.Aa = function (a, b, c) {
                    return this.Z.Aa(this.Qb, a, b, c);
                };
                h.Cc = function (a) {
                    return this.Z.Cc(this.Qb, a);
                };
                h.nd = function (a, b, c) {
                    return this.Z.nd(this.Qb, a, b, c);
                };
                h.xc = function (a) {
                    return this.Z.xc(this.Qb.o(a));
                };
                h.qe = function (a, b, c, d, e) {
                    return this.Z.qe(this.Qb, a, b, c, d, e);
                };
                h.Bc = function (a, b) {
                    return this.Z.Bc(this.Qb, a, b);
                };
                h.o = function (a) {
                    return new Uf(this.Qb.o(a), this.Z);
                };
                function Vf() {
                    this.children = {};
                    this.pd = 0;
                    this.value = null;
                }
                function Wf(a, b, c) {
                    this.Jd = a ? a : "";
                    this.Ha = b ? b : null;
                    this.A = c ? c : new Vf();
                }
                function Xf(a, b) {
                    for (
                        var c = b instanceof P ? b : new P(b), d = a, e;
                        null !== (e = K(c));

                    )
                        (d = new Wf(e, d, z(d.A.children, e) || new Vf())),
                            (c = N(c));
                    return d;
                }
                h = Wf.prototype;
                h.Ea = function () {
                    return this.A.value;
                };
                function Yf(a, b) {
                    O(
                        "undefined" !== typeof b,
                        "Cannot set value to undefined"
                    );
                    a.A.value = b;
                    Zf(a);
                }
                h.clear = function () {
                    this.A.value = null;
                    this.A.children = {};
                    this.A.pd = 0;
                    Zf(this);
                };
                h.zd = function () {
                    return 0 < this.A.pd;
                };
                h.e = function () {
                    return null === this.Ea() && !this.zd();
                };
                h.R = function (a) {
                    var b = this;
                    v(this.A.children, function (c, d) {
                        a(new Wf(d, b, c));
                    });
                };
                function $f(a, b, c, d) {
                    c && !d && b(a);
                    a.R(function (a) {
                        $f(a, b, !0, d);
                    });
                    c && d && b(a);
                }
                function ag(a, b) {
                    for (var c = a.parent(); null !== c && !b(c); )
                        c = c.parent();
                }
                h.path = function () {
                    return new P(
                        null === this.Ha
                            ? this.Jd
                            : this.Ha.path() + "/" + this.Jd
                    );
                };
                h.name = function () {
                    return this.Jd;
                };
                h.parent = function () {
                    return this.Ha;
                };
                function Zf(a) {
                    if (null !== a.Ha) {
                        var b = a.Ha,
                            c = a.Jd,
                            d = a.e(),
                            e = y(b.A.children, c);
                        d && e
                            ? (delete b.A.children[c], b.A.pd--, Zf(b))
                            : d ||
                              e ||
                              ((b.A.children[c] = a.A), b.A.pd++, Zf(b));
                    }
                }
                var bg = /[\[\].#$\/\u0000-\u001F\u007F]/,
                    cg = /[\[\].#$\u0000-\u001F\u007F]/,
                    dg = /^[a-zA-Z][a-zA-Z._\-+]+$/;
                function eg(a) {
                    return q(a) && 0 !== a.length && !bg.test(a);
                }
                function fg(a) {
                    return (
                        null === a ||
                        q(a) ||
                        (fa(a) && !td(a)) ||
                        (ga(a) && y(a, ".sv"))
                    );
                }
                function gg(a, b, c, d) {
                    (d && !p(b)) || hg(E(a, 1, d), b, c);
                }
                function hg(a, b, c) {
                    c instanceof P && (c = new nf(c, a));
                    if (!p(b)) throw Error(a + "contains undefined " + pf(c));
                    if (r(b))
                        throw Error(
                            a +
                                "contains a function " +
                                pf(c) +
                                " with contents: " +
                                b.toString()
                        );
                    if (td(b))
                        throw Error(
                            a + "contains " + b.toString() + " " + pf(c)
                        );
                    if (q(b) && b.length > 10485760 / 3 && 10485760 < Pb(b))
                        throw Error(
                            a +
                                "contains a string greater than 10485760 utf8 bytes " +
                                pf(c) +
                                " ('" +
                                b.substring(0, 50) +
                                "...')"
                        );
                    if (ga(b)) {
                        var d = !1,
                            e = !1;
                        Fb(b, function (b, g) {
                            if (".value" === b) d = !0;
                            else if (
                                ".priority" !== b &&
                                ".sv" !== b &&
                                ((e = !0), !eg(b))
                            )
                                throw Error(
                                    a +
                                        " contains an invalid key (" +
                                        b +
                                        ") " +
                                        pf(c) +
                                        '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'
                                );
                            c.push(b);
                            hg(a, g, c);
                            c.pop();
                        });
                        if (d && e)
                            throw Error(
                                a +
                                    ' contains ".value" child ' +
                                    pf(c) +
                                    " in addition to actual children."
                            );
                    }
                }
                function ig(a, b) {
                    var c, d;
                    for (c = 0; c < b.length; c++) {
                        d = b[c];
                        for (var e = d.slice(), f = 0; f < e.length; f++)
                            if (
                                (".priority" !== e[f] || f !== e.length - 1) &&
                                !eg(e[f])
                            )
                                throw Error(
                                    a +
                                        "contains an invalid key (" +
                                        e[f] +
                                        ") in path " +
                                        d.toString() +
                                        '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"'
                                );
                    }
                    b.sort(mf);
                    e = null;
                    for (c = 0; c < b.length; c++) {
                        d = b[c];
                        if (null !== e && e.contains(d))
                            throw Error(
                                a +
                                    "contains a path " +
                                    e.toString() +
                                    " that is ancestor of another path " +
                                    d.toString()
                            );
                        e = d;
                    }
                }
                function jg(a, b, c) {
                    var d = E(a, 1, !1);
                    if (!ga(b) || da(b))
                        throw Error(
                            d +
                                " must be an object containing the children to replace."
                        );
                    var e = [];
                    Fb(b, function (a, b) {
                        var k = new P(a);
                        hg(d, b, c.o(k));
                        if (".priority" === me(k) && !fg(b))
                            throw Error(
                                d +
                                    "contains an invalid value for '" +
                                    k.toString() +
                                    "', which must be a valid Firebase priority (a string, finite number, server value, or null)."
                            );
                        e.push(k);
                    });
                    ig(d, e);
                }
                function kg(a, b, c) {
                    if (td(c))
                        throw Error(
                            E(a, b, !1) +
                                "is " +
                                c.toString() +
                                ", but must be a valid Firebase priority (a string, finite number, server value, or null)."
                        );
                    if (!fg(c))
                        throw Error(
                            E(a, b, !1) +
                                "must be a valid Firebase priority (a string, finite number, server value, or null)."
                        );
                }
                function lg(a, b, c) {
                    if (!c || p(b))
                        switch (b) {
                            case "value":
                            case "child_added":
                            case "child_removed":
                            case "child_changed":
                            case "child_moved":
                                break;
                            default:
                                throw Error(
                                    E(a, 1, c) +
                                        'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".'
                                );
                        }
                }
                function mg(a, b) {
                    if (p(b) && !eg(b))
                        throw Error(
                            E(a, 2, !0) +
                                'was an invalid key: "' +
                                b +
                                '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").'
                        );
                }
                function ng(a, b) {
                    if (!q(b) || 0 === b.length || cg.test(b))
                        throw Error(
                            E(a, 1, !1) +
                                'was an invalid path: "' +
                                b +
                                '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"'
                        );
                }
                function og(a, b) {
                    if (".info" === K(b))
                        throw Error(
                            a + " failed: Can't modify data under /.info/"
                        );
                }
                function pg(a, b) {
                    if (!q(b))
                        throw Error(
                            E(a, 1, !1) +
                                "must be a valid credential (a string)."
                        );
                }
                function qg(a, b, c) {
                    if (!q(c))
                        throw Error(E(a, b, !1) + "must be a valid string.");
                }
                function rg(a, b) {
                    qg(a, 1, b);
                    if (!dg.test(b))
                        throw Error(
                            E(a, 1, !1) +
                                "'" +
                                b +
                                "' is not a valid authentication provider."
                        );
                }
                function sg(a, b, c, d) {
                    if (!d || p(c))
                        if (!ga(c) || null === c)
                            throw Error(E(a, b, d) + "must be a valid object.");
                }
                function tg(a, b, c) {
                    if (!ga(b) || !y(b, c))
                        throw Error(
                            E(a, 1, !1) + 'must contain the key "' + c + '"'
                        );
                    if (!q(z(b, c)))
                        throw Error(
                            E(a, 1, !1) +
                                'must contain the key "' +
                                c +
                                '" with type "string"'
                        );
                }
                function ug() {
                    this.set = {};
                }
                h = ug.prototype;
                h.add = function (a, b) {
                    this.set[a] = null !== b ? b : !0;
                };
                h.contains = function (a) {
                    return y(this.set, a);
                };
                h.get = function (a) {
                    return this.contains(a) ? this.set[a] : void 0;
                };
                h.remove = function (a) {
                    delete this.set[a];
                };
                h.clear = function () {
                    this.set = {};
                };
                h.e = function () {
                    return va(this.set);
                };
                h.count = function () {
                    return oa(this.set);
                };
                function vg(a, b) {
                    v(a.set, function (a, d) {
                        b(d, a);
                    });
                }
                h.keys = function () {
                    var a = [];
                    v(this.set, function (b, c) {
                        a.push(c);
                    });
                    return a;
                };
                function Vc() {
                    this.m = this.B = null;
                }
                Vc.prototype.find = function (a) {
                    if (null != this.B) return this.B.S(a);
                    if (a.e() || null == this.m) return null;
                    var b = K(a);
                    a = N(a);
                    return this.m.contains(b) ? this.m.get(b).find(a) : null;
                };
                Vc.prototype.rc = function (a, b) {
                    if (a.e()) (this.B = b), (this.m = null);
                    else if (null !== this.B) this.B = this.B.H(a, b);
                    else {
                        null == this.m && (this.m = new ug());
                        var c = K(a);
                        this.m.contains(c) || this.m.add(c, new Vc());
                        c = this.m.get(c);
                        a = N(a);
                        c.rc(a, b);
                    }
                };
                function wg(a, b) {
                    if (b.e()) return (a.B = null), (a.m = null), !0;
                    if (null !== a.B) {
                        if (a.B.L()) return !1;
                        var c = a.B;
                        a.B = null;
                        c.R(R, function (b, c) {
                            a.rc(new P(b), c);
                        });
                        return wg(a, b);
                    }
                    return null !== a.m
                        ? ((c = K(b)),
                          (b = N(b)),
                          a.m.contains(c) && wg(a.m.get(c), b) && a.m.remove(c),
                          a.m.e() ? ((a.m = null), !0) : !1)
                        : !0;
                }
                function Wc(a, b, c) {
                    null !== a.B
                        ? c(b, a.B)
                        : a.R(function (a, e) {
                              var f = new P(b.toString() + "/" + a);
                              Wc(e, f, c);
                          });
                }
                Vc.prototype.R = function (a) {
                    null !== this.m &&
                        vg(this.m, function (b, c) {
                            a(b, c);
                        });
                };
                var xg = "auth.firebase.com";
                function yg(a, b, c) {
                    this.qd = a || {};
                    this.he = b || {};
                    this.fb = c || {};
                    this.qd.remember || (this.qd.remember = "default");
                }
                var zg = ["remember", "redirectTo"];
                function Ag(a) {
                    var b = {},
                        c = {};
                    Fb(a || {}, function (a, e) {
                        0 <= La(zg, a) ? (b[a] = e) : (c[a] = e);
                    });
                    return new yg(b, {}, c);
                }
                function Bg(a, b) {
                    this.Ue = ["session", a.Rd, a.lc].join(":");
                    this.ee = b;
                }
                Bg.prototype.set = function (a, b) {
                    if (!b)
                        if (this.ee.length) b = this.ee[0];
                        else
                            throw Error(
                                "fb.login.SessionManager : No storage options available!"
                            );
                    b.set(this.Ue, a);
                };
                Bg.prototype.get = function () {
                    var a = Oa(this.ee, u(this.Bg, this)),
                        a = Na(a, function (a) {
                            return null !== a;
                        });
                    Va(a, function (a, c) {
                        return Dd(c.token) - Dd(a.token);
                    });
                    return 0 < a.length ? a.shift() : null;
                };
                Bg.prototype.Bg = function (a) {
                    try {
                        var b = a.get(this.Ue);
                        if (b && b.token) return b;
                    } catch (c) {}
                    return null;
                };
                Bg.prototype.clear = function () {
                    var a = this;
                    Ma(this.ee, function (b) {
                        b.remove(a.Ue);
                    });
                };
                function Cg() {
                    return "undefined" !== typeof navigator &&
                        "string" === typeof navigator.userAgent
                        ? navigator.userAgent
                        : "";
                }
                function Dg() {
                    return (
                        "undefined" !== typeof window &&
                        !!(
                            window.cordova ||
                            window.phonegap ||
                            window.PhoneGap
                        ) &&
                        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(
                            Cg()
                        )
                    );
                }
                function Eg() {
                    return (
                        "undefined" !== typeof location &&
                        /^file:\//.test(location.href)
                    );
                }
                function Fg(a) {
                    var b = Cg();
                    if ("" === b) return !1;
                    if ("Microsoft Internet Explorer" === navigator.appName) {
                        if (
                            (b = b.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/)) &&
                            1 < b.length
                        )
                            return parseFloat(b[1]) >= a;
                    } else if (
                        -1 < b.indexOf("Trident") &&
                        (b = b.match(/rv:([0-9]{2,2}[\.0-9]{0,})/)) &&
                        1 < b.length
                    )
                        return parseFloat(b[1]) >= a;
                    return !1;
                }
                function Gg() {
                    var a = window.opener.frames,
                        b;
                    for (b = a.length - 1; 0 <= b; b--)
                        try {
                            if (
                                a[b].location.protocol ===
                                    window.location.protocol &&
                                a[b].location.host === window.location.host &&
                                "__winchan_relay_frame" === a[b].name
                            )
                                return a[b];
                        } catch (c) {}
                    return null;
                }
                function Hg(a, b, c) {
                    a.attachEvent
                        ? a.attachEvent("on" + b, c)
                        : a.addEventListener && a.addEventListener(b, c, !1);
                }
                function Ig(a, b, c) {
                    a.detachEvent
                        ? a.detachEvent("on" + b, c)
                        : a.removeEventListener &&
                          a.removeEventListener(b, c, !1);
                }
                function Jg(a) {
                    /^https?:\/\//.test(a) || (a = window.location.href);
                    var b = /^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(a);
                    return b ? b[1] : a;
                }
                function Kg(a) {
                    var b = "";
                    try {
                        a = a.replace(/.*\?/, "");
                        var c = Jb(a);
                        c &&
                            y(c, "__firebase_request_key") &&
                            (b = z(c, "__firebase_request_key"));
                    } catch (d) {}
                    return b;
                }
                function Lg() {
                    try {
                        var a = document.location.hash.replace(
                                /&__firebase_request_key=([a-zA-z0-9]*)/,
                                ""
                            ),
                            a = a.replace(/\?$/, ""),
                            a = a.replace(/^#+$/, "");
                        document.location.hash = a;
                    } catch (b) {}
                }
                function Mg() {
                    var a = sd(xg);
                    return a.scheme + "://" + a.host + "/v2";
                }
                function Ng(a) {
                    return Mg() + "/" + a + "/auth/channel";
                }
                function Og(a) {
                    var b = this;
                    this.hb = a;
                    this.fe = "*";
                    Fg(8)
                        ? (this.Uc = this.Cd = Gg())
                        : ((this.Uc = window.opener), (this.Cd = window));
                    if (!b.Uc) throw "Unable to find relay frame";
                    Hg(this.Cd, "message", u(this.nc, this));
                    Hg(this.Cd, "message", u(this.Ff, this));
                    try {
                        Pg(this, { a: "ready" });
                    } catch (c) {
                        Hg(this.Uc, "load", function () {
                            Pg(b, { a: "ready" });
                        });
                    }
                    Hg(window, "unload", u(this.Mg, this));
                }
                function Pg(a, b) {
                    b = G(b);
                    Fg(8) ? a.Uc.doPost(b, a.fe) : a.Uc.postMessage(b, a.fe);
                }
                Og.prototype.nc = function (a) {
                    var b = this,
                        c;
                    try {
                        c = Rb(a.data);
                    } catch (d) {}
                    c &&
                        "request" === c.a &&
                        (Ig(window, "message", this.nc),
                        (this.fe = a.origin),
                        this.hb &&
                            setTimeout(function () {
                                b.hb(b.fe, c.d, function (a, c) {
                                    b.mg = !c;
                                    b.hb = void 0;
                                    Pg(b, {
                                        a: "response",
                                        d: a,
                                        forceKeepWindowOpen: c,
                                    });
                                });
                            }, 0));
                };
                Og.prototype.Mg = function () {
                    try {
                        Ig(this.Cd, "message", this.Ff);
                    } catch (a) {}
                    this.hb &&
                        (Pg(this, { a: "error", d: "unknown closed window" }),
                        (this.hb = void 0));
                    try {
                        window.close();
                    } catch (b) {}
                };
                Og.prototype.Ff = function (a) {
                    if (this.mg && "die" === a.data)
                        try {
                            window.close();
                        } catch (b) {}
                };
                function Qg(a) {
                    this.tc = Fa() + Fa() + Fa();
                    this.Kf = a;
                }
                Qg.prototype.open = function (a, b) {
                    cd.set("redirect_request_id", this.tc);
                    cd.set("redirect_request_id", this.tc);
                    b.requestId = this.tc;
                    b.redirectTo = b.redirectTo || window.location.href;
                    a += (/\?/.test(a) ? "" : "?") + Ib(b);
                    window.location = a;
                };
                Qg.isAvailable = function () {
                    return !Eg() && !Dg();
                };
                Qg.prototype.Fc = function () {
                    return "redirect";
                };
                var Rg = {
                    NETWORK_ERROR: "Unable to contact the Firebase server.",
                    SERVER_ERROR: "An unknown server error occurred.",
                    TRANSPORT_UNAVAILABLE:
                        "There are no login transports available for the requested method.",
                    REQUEST_INTERRUPTED:
                        "The browser redirected the page before the login request could complete.",
                    USER_CANCELLED: "The user cancelled authentication.",
                };
                function Sg(a) {
                    var b = Error(z(Rg, a), a);
                    b.code = a;
                    return b;
                }
                function Tg(a) {
                    var b;
                    (b = !a.window_features) ||
                        ((b = Cg()),
                        (b =
                            -1 !== b.indexOf("Fennec/") ||
                            (-1 !== b.indexOf("Firefox/") &&
                                -1 !== b.indexOf("Android"))));
                    b && (a.window_features = void 0);
                    a.window_name || (a.window_name = "_blank");
                    this.options = a;
                }
                Tg.prototype.open = function (a, b, c) {
                    function d(a) {
                        g && (document.body.removeChild(g), (g = void 0));
                        t && (t = clearInterval(t));
                        Ig(window, "message", e);
                        Ig(window, "unload", d);
                        if (l && !a)
                            try {
                                l.close();
                            } catch (b) {
                                k.postMessage("die", m);
                            }
                        l = k = void 0;
                    }
                    function e(a) {
                        if (a.origin === m)
                            try {
                                var b = Rb(a.data);
                                "ready" === b.a
                                    ? k.postMessage(A, m)
                                    : "error" === b.a
                                    ? (d(!1), c && (c(b.d), (c = null)))
                                    : "response" === b.a &&
                                      (d(b.forceKeepWindowOpen),
                                      c && (c(null, b.d), (c = null)));
                            } catch (e) {}
                    }
                    var f = Fg(8),
                        g,
                        k;
                    if (!this.options.relay_url)
                        return c(
                            Error(
                                "invalid arguments: origin of url and relay_url must match"
                            )
                        );
                    var m = Jg(a);
                    if (m !== Jg(this.options.relay_url))
                        c &&
                            setTimeout(function () {
                                c(
                                    Error(
                                        "invalid arguments: origin of url and relay_url must match"
                                    )
                                );
                            }, 0);
                    else {
                        f &&
                            ((g = document.createElement("iframe")),
                            g.setAttribute("src", this.options.relay_url),
                            (g.style.display = "none"),
                            g.setAttribute("name", "__winchan_relay_frame"),
                            document.body.appendChild(g),
                            (k = g.contentWindow));
                        a += (/\?/.test(a) ? "" : "?") + Ib(b);
                        var l = window.open(
                            a,
                            this.options.window_name,
                            this.options.window_features
                        );
                        k || (k = l);
                        var t = setInterval(function () {
                                l &&
                                    l.closed &&
                                    (d(!1),
                                    c && (c(Sg("USER_CANCELLED")), (c = null)));
                            }, 500),
                            A = G({ a: "request", d: b });
                        Hg(window, "unload", d);
                        Hg(window, "message", e);
                    }
                };
                Tg.isAvailable = function () {
                    var a;
                    if ((a = "postMessage" in window && !Eg()))
                        (a =
                            Dg() ||
                            ("undefined" !== typeof navigator &&
                                (!!Cg().match(/Windows Phone/) ||
                                    (!!window.Windows &&
                                        /^ms-appx:/.test(location.href))))) ||
                            ((a = Cg()),
                            (a =
                                "undefined" !== typeof navigator &&
                                "undefined" !== typeof window &&
                                !!(
                                    a.match(
                                        /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i
                                    ) ||
                                    a.match(/CriOS/) ||
                                    a.match(/Twitter for iPhone/) ||
                                    a.match(/FBAN\/FBIOS/) ||
                                    window.navigator.standalone
                                ))),
                            (a = !a);
                    return a && !Cg().match(/PhantomJS/);
                };
                Tg.prototype.Fc = function () {
                    return "popup";
                };
                function Ug(a) {
                    a.method || (a.method = "GET");
                    a.headers || (a.headers = {});
                    a.headers.content_type ||
                        (a.headers.content_type = "application/json");
                    a.headers.content_type =
                        a.headers.content_type.toLowerCase();
                    this.options = a;
                }
                Ug.prototype.open = function (a, b, c) {
                    function d() {
                        c && (c(Sg("REQUEST_INTERRUPTED")), (c = null));
                    }
                    var e = new XMLHttpRequest(),
                        f = this.options.method.toUpperCase(),
                        g;
                    Hg(window, "beforeunload", d);
                    e.onreadystatechange = function () {
                        if (c && 4 === e.readyState) {
                            var a;
                            if (200 <= e.status && 300 > e.status) {
                                try {
                                    a = Rb(e.responseText);
                                } catch (b) {}
                                c(null, a);
                            } else
                                500 <= e.status && 600 > e.status
                                    ? c(Sg("SERVER_ERROR"))
                                    : c(Sg("NETWORK_ERROR"));
                            c = null;
                            Ig(window, "beforeunload", d);
                        }
                    };
                    if ("GET" === f)
                        (a += (/\?/.test(a) ? "" : "?") + Ib(b)), (g = null);
                    else {
                        var k = this.options.headers.content_type;
                        "application/json" === k && (g = G(b));
                        "application/x-www-form-urlencoded" === k &&
                            (g = Ib(b));
                    }
                    e.open(f, a, !0);
                    a = {
                        "X-Requested-With": "XMLHttpRequest",
                        Accept: "application/json;text/plain",
                    };
                    ya(a, this.options.headers);
                    for (var m in a) e.setRequestHeader(m, a[m]);
                    e.send(g);
                };
                Ug.isAvailable = function () {
                    var a;
                    if ((a = !!window.XMLHttpRequest))
                        (a = Cg()),
                            (a =
                                !(a.match(/MSIE/) || a.match(/Trident/)) ||
                                Fg(10));
                    return a;
                };
                Ug.prototype.Fc = function () {
                    return "json";
                };
                function Vg(a) {
                    this.tc = Fa() + Fa() + Fa();
                    this.Kf = a;
                }
                Vg.prototype.open = function (a, b, c) {
                    function d() {
                        c && (c(Sg("USER_CANCELLED")), (c = null));
                    }
                    var e = this,
                        f = sd(xg),
                        g;
                    b.requestId = this.tc;
                    b.redirectTo =
                        f.scheme + "://" + f.host + "/blank/page.html";
                    a += /\?/.test(a) ? "" : "?";
                    a += Ib(b);
                    (g = window.open(a, "_blank", "location=no")) &&
                    r(g.addEventListener)
                        ? (g.addEventListener("loadstart", function (a) {
                              var b;
                              if ((b = a && a.url))
                                  a: {
                                      try {
                                          var l = document.createElement("a");
                                          l.href = a.url;
                                          b =
                                              l.host === f.host &&
                                              "/blank/page.html" === l.pathname;
                                          break a;
                                      } catch (t) {}
                                      b = !1;
                                  }
                              b &&
                                  ((a = Kg(a.url)),
                                  g.removeEventListener("exit", d),
                                  g.close(),
                                  (a = new yg(null, null, {
                                      requestId: e.tc,
                                      requestKey: a,
                                  })),
                                  e.Kf.requestWithCredential(
                                      "/auth/session",
                                      a,
                                      c
                                  ),
                                  (c = null));
                          }),
                          g.addEventListener("exit", d))
                        : c(Sg("TRANSPORT_UNAVAILABLE"));
                };
                Vg.isAvailable = function () {
                    return Dg();
                };
                Vg.prototype.Fc = function () {
                    return "redirect";
                };
                function Wg(a) {
                    a.callback_parameter || (a.callback_parameter = "callback");
                    this.options = a;
                    window.__firebase_auth_jsonp =
                        window.__firebase_auth_jsonp || {};
                }
                Wg.prototype.open = function (a, b, c) {
                    function d() {
                        c && (c(Sg("REQUEST_INTERRUPTED")), (c = null));
                    }
                    function e() {
                        setTimeout(function () {
                            window.__firebase_auth_jsonp[f] = void 0;
                            va(window.__firebase_auth_jsonp) &&
                                (window.__firebase_auth_jsonp = void 0);
                            try {
                                var a = document.getElementById(f);
                                a && a.parentNode.removeChild(a);
                            } catch (b) {}
                        }, 1);
                        Ig(window, "beforeunload", d);
                    }
                    var f =
                        "fn" +
                        new Date().getTime() +
                        Math.floor(99999 * Math.random());
                    b[this.options.callback_parameter] =
                        "__firebase_auth_jsonp." + f;
                    a += (/\?/.test(a) ? "" : "?") + Ib(b);
                    Hg(window, "beforeunload", d);
                    window.__firebase_auth_jsonp[f] = function (a) {
                        c && (c(null, a), (c = null));
                        e();
                    };
                    Xg(f, a, c);
                };
                function Xg(a, b, c) {
                    setTimeout(function () {
                        try {
                            var d = document.createElement("script");
                            d.type = "text/javascript";
                            d.id = a;
                            d.async = !0;
                            d.src = b;
                            d.onerror = function () {
                                var b = document.getElementById(a);
                                null !== b && b.parentNode.removeChild(b);
                                c && c(Sg("NETWORK_ERROR"));
                            };
                            var e = document.getElementsByTagName("head");
                            (e && 0 != e.length
                                ? e[0]
                                : document.documentElement
                            ).appendChild(d);
                        } catch (f) {
                            c && c(Sg("NETWORK_ERROR"));
                        }
                    }, 0);
                }
                Wg.isAvailable = function () {
                    return (
                        "undefined" !== typeof document &&
                        null != document.createElement
                    );
                };
                Wg.prototype.Fc = function () {
                    return "json";
                };
                function Yg(a, b, c, d) {
                    ff.call(this, ["auth_status"]);
                    this.G = a;
                    this.hf = b;
                    this.hh = c;
                    this.Pe = d;
                    this.wc = new Bg(a, [bd, cd]);
                    this.qb = null;
                    this.We = !1;
                    Zg(this);
                }
                ka(Yg, ff);
                h = Yg.prototype;
                h.Be = function () {
                    return this.qb || null;
                };
                function Zg(a) {
                    cd.get("redirect_request_id") && $g(a);
                    var b = a.wc.get();
                    b && b.token
                        ? (ah(a, b),
                          a.hf(
                              b.token,
                              function (c, d) {
                                  bh(a, c, d, !1, b.token, b);
                              },
                              function (b, d) {
                                  ch(a, "resumeSession()", b, d);
                              }
                          ))
                        : ah(a, null);
                }
                function dh(a, b, c, d, e, f) {
                    "firebaseio-demo.com" === a.G.domain &&
                        S(
                            "Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com."
                        );
                    a.hf(
                        b,
                        function (f, k) {
                            bh(a, f, k, !0, b, c, d || {}, e);
                        },
                        function (b, c) {
                            ch(a, "auth()", b, c, f);
                        }
                    );
                }
                function eh(a, b) {
                    a.wc.clear();
                    ah(a, null);
                    a.hh(function (a, d) {
                        if ("ok" === a) T(b, null);
                        else {
                            var e = (a || "error").toUpperCase(),
                                f = e;
                            d && (f += ": " + d);
                            f = Error(f);
                            f.code = e;
                            T(b, f);
                        }
                    });
                }
                function bh(a, b, c, d, e, f, g, k) {
                    "ok" === b
                        ? (d &&
                              ((b = c.auth),
                              (f.auth = b),
                              (f.expires = c.expires),
                              (f.token = Ed(e) ? e : ""),
                              (c = null),
                              b && y(b, "uid")
                                  ? (c = z(b, "uid"))
                                  : y(f, "uid") && (c = z(f, "uid")),
                              (f.uid = c),
                              (c = "custom"),
                              b && y(b, "provider")
                                  ? (c = z(b, "provider"))
                                  : y(f, "provider") && (c = z(f, "provider")),
                              (f.provider = c),
                              a.wc.clear(),
                              Ed(e) &&
                                  ((g = g || {}),
                                  (c = bd),
                                  "sessionOnly" === g.remember && (c = cd),
                                  "none" !== g.remember && a.wc.set(f, c)),
                              ah(a, f)),
                          T(k, null, f))
                        : (a.wc.clear(),
                          ah(a, null),
                          (f = a = (b || "error").toUpperCase()),
                          c && (f += ": " + c),
                          (f = Error(f)),
                          (f.code = a),
                          T(k, f));
                }
                function ch(a, b, c, d, e) {
                    S(b + " was canceled: " + d);
                    a.wc.clear();
                    ah(a, null);
                    a = Error(d);
                    a.code = c.toUpperCase();
                    T(e, a);
                }
                function fh(a, b, c, d, e) {
                    gh(a);
                    c = new yg(d || {}, {}, c || {});
                    hh(a, [Ug, Wg], "/auth/" + b, c, e);
                }
                function ih(a, b, c, d) {
                    gh(a);
                    var e = [Tg, Vg];
                    c = Ag(c);
                    var f = 625;
                    "anonymous" === b || "password" === b
                        ? setTimeout(function () {
                              T(d, Sg("TRANSPORT_UNAVAILABLE"));
                          }, 0)
                        : ("github" === b && (f = 1025),
                          (c.he.window_features =
                              "menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=" +
                              f +
                              ",top=" +
                              ("object" === typeof screen
                                  ? 0.5 * (screen.height - 625)
                                  : 0) +
                              ",left=" +
                              ("object" === typeof screen
                                  ? 0.5 * (screen.width - f)
                                  : 0)),
                          (c.he.relay_url = Ng(a.G.lc)),
                          (c.he.requestWithCredential = u(a.uc, a)),
                          hh(a, e, "/auth/" + b, c, d));
                }
                function $g(a) {
                    var b = cd.get("redirect_request_id");
                    if (b) {
                        var c = cd.get("redirect_client_options");
                        cd.remove("redirect_request_id");
                        cd.remove("redirect_client_options");
                        var d = [Ug, Wg],
                            b = {
                                requestId: b,
                                requestKey: Kg(document.location.hash),
                            },
                            c = new yg(c, {}, b);
                        a.We = !0;
                        Lg();
                        hh(
                            a,
                            d,
                            "/auth/session",
                            c,
                            function () {
                                this.We = !1;
                            }.bind(a)
                        );
                    }
                }
                h.ve = function (a, b) {
                    gh(this);
                    var c = Ag(a);
                    c.fb._method = "POST";
                    this.uc("/users", c, function (a, c) {
                        a ? T(b, a) : T(b, a, c);
                    });
                };
                h.Xe = function (a, b) {
                    var c = this;
                    gh(this);
                    var d = "/users/" + encodeURIComponent(a.email),
                        e = Ag(a);
                    e.fb._method = "DELETE";
                    this.uc(d, e, function (a, d) {
                        !a &&
                            d &&
                            d.uid &&
                            c.qb &&
                            c.qb.uid &&
                            c.qb.uid === d.uid &&
                            eh(c);
                        T(b, a);
                    });
                };
                h.se = function (a, b) {
                    gh(this);
                    var c =
                            "/users/" +
                            encodeURIComponent(a.email) +
                            "/password",
                        d = Ag(a);
                    d.fb._method = "PUT";
                    d.fb.password = a.newPassword;
                    this.uc(c, d, function (a) {
                        T(b, a);
                    });
                };
                h.re = function (a, b) {
                    gh(this);
                    var c =
                            "/users/" +
                            encodeURIComponent(a.oldEmail) +
                            "/email",
                        d = Ag(a);
                    d.fb._method = "PUT";
                    d.fb.email = a.newEmail;
                    d.fb.password = a.password;
                    this.uc(c, d, function (a) {
                        T(b, a);
                    });
                };
                h.Ze = function (a, b) {
                    gh(this);
                    var c =
                            "/users/" +
                            encodeURIComponent(a.email) +
                            "/password",
                        d = Ag(a);
                    d.fb._method = "POST";
                    this.uc(c, d, function (a) {
                        T(b, a);
                    });
                };
                h.uc = function (a, b, c) {
                    jh(this, [Ug, Wg], a, b, c);
                };
                function hh(a, b, c, d, e) {
                    jh(a, b, c, d, function (b, c) {
                        !b && c && c.token && c.uid
                            ? dh(a, c.token, c, d.qd, function (a, b) {
                                  a ? T(e, a) : T(e, null, b);
                              })
                            : T(e, b || Sg("UNKNOWN_ERROR"));
                    });
                }
                function jh(a, b, c, d, e) {
                    b = Na(b, function (a) {
                        return (
                            "function" === typeof a.isAvailable &&
                            a.isAvailable()
                        );
                    });
                    0 === b.length
                        ? setTimeout(function () {
                              T(e, Sg("TRANSPORT_UNAVAILABLE"));
                          }, 0)
                        : ((b = new (b.shift())(d.he)),
                          (d = Gb(d.fb)),
                          (d.v = "js-" + Eb),
                          (d.transport = b.Fc()),
                          (d.suppress_status_codes = !0),
                          (a = Mg() + "/" + a.G.lc + c),
                          b.open(a, d, function (a, b) {
                              if (a) T(e, a);
                              else if (b && b.error) {
                                  var c = Error(b.error.message);
                                  c.code = b.error.code;
                                  c.details = b.error.details;
                                  T(e, c);
                              } else T(e, null, b);
                          }));
                }
                function ah(a, b) {
                    var c = null !== a.qb || null !== b;
                    a.qb = b;
                    c && a.ie("auth_status", b);
                    a.Pe(null !== b);
                }
                h.Ee = function (a) {
                    O(
                        "auth_status" === a,
                        'initial event must be of type "auth_status"'
                    );
                    return this.We ? null : [this.qb];
                };
                function gh(a) {
                    var b = a.G;
                    if (
                        "firebaseio.com" !== b.domain &&
                        "firebaseio-demo.com" !== b.domain &&
                        "auth.firebase.com" === xg
                    )
                        throw Error(
                            "This custom Firebase server ('" +
                                a.G.domain +
                                "') does not support delegated login."
                        );
                }
                var gd = "websocket",
                    hd = "long_polling";
                function kh(a) {
                    this.nc = a;
                    this.Qd = [];
                    this.Wb = 0;
                    this.te = -1;
                    this.Jb = null;
                }
                function lh(a, b, c) {
                    a.te = b;
                    a.Jb = c;
                    a.te < a.Wb && (a.Jb(), (a.Jb = null));
                }
                function mh(a, b, c) {
                    for (a.Qd[b] = c; a.Qd[a.Wb]; ) {
                        var d = a.Qd[a.Wb];
                        delete a.Qd[a.Wb];
                        for (var e = 0; e < d.length; ++e)
                            if (d[e]) {
                                var f = a;
                                gc(function () {
                                    f.nc(d[e]);
                                });
                            }
                        if (a.Wb === a.te) {
                            a.Jb && (clearTimeout(a.Jb), a.Jb(), (a.Jb = null));
                            break;
                        }
                        a.Wb++;
                    }
                }
                function nh(a, b, c, d) {
                    this.ue = a;
                    this.f = pd(a);
                    this.rb = this.sb = 0;
                    this.Xa = uc(b);
                    this.Xf = c;
                    this.Kc = !1;
                    this.Fb = d;
                    this.ld = function (a) {
                        return fd(b, hd, a);
                    };
                }
                var oh, ph;
                nh.prototype.open = function (a, b) {
                    this.mf = 0;
                    this.na = b;
                    this.Ef = new kh(a);
                    this.Db = !1;
                    var c = this;
                    this.ub = setTimeout(function () {
                        c.f("Timed out trying to connect.");
                        c.bb();
                        c.ub = null;
                    }, Math.floor(3e4));
                    ud(function () {
                        if (!c.Db) {
                            c.Wa = new qh(
                                function (a, b, d, k, m) {
                                    rh(c, arguments);
                                    if (c.Wa)
                                        if (
                                            (c.ub &&
                                                (clearTimeout(c.ub),
                                                (c.ub = null)),
                                            (c.Kc = !0),
                                            "start" == a)
                                        )
                                            (c.id = b), (c.Mf = d);
                                        else if ("close" === a)
                                            b
                                                ? ((c.Wa.$d = !1),
                                                  lh(c.Ef, b, function () {
                                                      c.bb();
                                                  }))
                                                : c.bb();
                                        else
                                            throw Error(
                                                "Unrecognized command received: " +
                                                    a
                                            );
                                },
                                function (a, b) {
                                    rh(c, arguments);
                                    mh(c.Ef, a, b);
                                },
                                function () {
                                    c.bb();
                                },
                                c.ld
                            );
                            var a = { start: "t" };
                            a.ser = Math.floor(1e8 * Math.random());
                            c.Wa.ke && (a.cb = c.Wa.ke);
                            a.v = "5";
                            c.Xf && (a.s = c.Xf);
                            c.Fb && (a.ls = c.Fb);
                            "undefined" !== typeof location &&
                                location.href &&
                                -1 !==
                                    location.href.indexOf("firebaseio.com") &&
                                (a.r = "f");
                            a = c.ld(a);
                            c.f("Connecting via long-poll to " + a);
                            sh(c.Wa, a, function () {});
                        }
                    });
                };
                nh.prototype.start = function () {
                    var a = this.Wa,
                        b = this.Mf;
                    a.Fg = this.id;
                    a.Gg = b;
                    for (a.oe = !0; th(a); );
                    a = this.id;
                    b = this.Mf;
                    this.kc = document.createElement("iframe");
                    var c = { dframe: "t" };
                    c.id = a;
                    c.pw = b;
                    this.kc.src = this.ld(c);
                    this.kc.style.display = "none";
                    document.body.appendChild(this.kc);
                };
                nh.isAvailable = function () {
                    return (
                        oh ||
                        (!ph &&
                            "undefined" !== typeof document &&
                            null != document.createElement &&
                            !(
                                "object" === typeof window &&
                                window.chrome &&
                                window.chrome.extension &&
                                !/^chrome/.test(window.location.href)
                            ) &&
                            !(
                                "object" === typeof Windows &&
                                "object" === typeof Windows.jh
                            ) &&
                            !0)
                    );
                };
                h = nh.prototype;
                h.Hd = function () {};
                h.fd = function () {
                    this.Db = !0;
                    this.Wa && (this.Wa.close(), (this.Wa = null));
                    this.kc &&
                        (document.body.removeChild(this.kc), (this.kc = null));
                    this.ub && (clearTimeout(this.ub), (this.ub = null));
                };
                h.bb = function () {
                    this.Db ||
                        (this.f("Longpoll is closing itself"),
                        this.fd(),
                        this.na && (this.na(this.Kc), (this.na = null)));
                };
                h.close = function () {
                    this.Db || (this.f("Longpoll is being closed."), this.fd());
                };
                h.send = function (a) {
                    a = G(a);
                    this.sb += a.length;
                    rc(this.Xa, "bytes_sent", a.length);
                    a = Ob(a);
                    a = nb(a, !0);
                    a = yd(a, 1840);
                    for (var b = 0; b < a.length; b++) {
                        var c = this.Wa;
                        c.cd.push({ Xg: this.mf, gh: a.length, of: a[b] });
                        c.oe && th(c);
                        this.mf++;
                    }
                };
                function rh(a, b) {
                    var c = G(b).length;
                    a.rb += c;
                    rc(a.Xa, "bytes_received", c);
                }
                function qh(a, b, c, d) {
                    this.ld = d;
                    this.lb = c;
                    this.Te = new ug();
                    this.cd = [];
                    this.we = Math.floor(1e8 * Math.random());
                    this.$d = !0;
                    this.ke = id();
                    window["pLPCommand" + this.ke] = a;
                    window["pRTLPCB" + this.ke] = b;
                    a = document.createElement("iframe");
                    a.style.display = "none";
                    if (document.body) {
                        document.body.appendChild(a);
                        try {
                            a.contentWindow.document ||
                                fc("No IE domain setting required");
                        } catch (e) {
                            a.src =
                                "javascript:void((function(){document.open();document.domain='" +
                                document.domain +
                                "';document.close();})())";
                        }
                    } else
                        throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
                    a.contentDocument
                        ? (a.jb = a.contentDocument)
                        : a.contentWindow
                        ? (a.jb = a.contentWindow.document)
                        : a.document && (a.jb = a.document);
                    this.Ga = a;
                    a = "";
                    this.Ga.src &&
                        "javascript:" === this.Ga.src.substr(0, 11) &&
                        (a =
                            '<script>document.domain="' +
                            document.domain +
                            '";\x3c/script>');
                    a = "<html><body>" + a + "</body></html>";
                    try {
                        this.Ga.jb.open(),
                            this.Ga.jb.write(a),
                            this.Ga.jb.close();
                    } catch (f) {
                        fc("frame writing exception"),
                            f.stack && fc(f.stack),
                            fc(f);
                    }
                }
                qh.prototype.close = function () {
                    this.oe = !1;
                    if (this.Ga) {
                        this.Ga.jb.body.innerHTML = "";
                        var a = this;
                        setTimeout(function () {
                            null !== a.Ga &&
                                (document.body.removeChild(a.Ga),
                                (a.Ga = null));
                        }, Math.floor(0));
                    }
                    var b = this.lb;
                    b && ((this.lb = null), b());
                };
                function th(a) {
                    if (
                        a.oe &&
                        a.$d &&
                        a.Te.count() < (0 < a.cd.length ? 2 : 1)
                    ) {
                        a.we++;
                        var b = {};
                        b.id = a.Fg;
                        b.pw = a.Gg;
                        b.ser = a.we;
                        for (var b = a.ld(b), c = "", d = 0; 0 < a.cd.length; )
                            if (1870 >= a.cd[0].of.length + 30 + c.length) {
                                var e = a.cd.shift(),
                                    c =
                                        c +
                                        "&seg" +
                                        d +
                                        "=" +
                                        e.Xg +
                                        "&ts" +
                                        d +
                                        "=" +
                                        e.gh +
                                        "&d" +
                                        d +
                                        "=" +
                                        e.of;
                                d++;
                            } else break;
                        uh(a, b + c, a.we);
                        return !0;
                    }
                    return !1;
                }
                function uh(a, b, c) {
                    function d() {
                        a.Te.remove(c);
                        th(a);
                    }
                    a.Te.add(c, 1);
                    var e = setTimeout(d, Math.floor(25e3));
                    sh(a, b, function () {
                        clearTimeout(e);
                        d();
                    });
                }
                function sh(a, b, c) {
                    setTimeout(function () {
                        try {
                            if (a.$d) {
                                var d = a.Ga.jb.createElement("script");
                                d.type = "text/javascript";
                                d.async = !0;
                                d.src = b;
                                d.onload = d.onreadystatechange = function () {
                                    var a = d.readyState;
                                    (a && "loaded" !== a && "complete" !== a) ||
                                        ((d.onload = d.onreadystatechange =
                                            null),
                                        d.parentNode &&
                                            d.parentNode.removeChild(d),
                                        c());
                                };
                                d.onerror = function () {
                                    fc("Long-poll script failed to load: " + b);
                                    a.$d = !1;
                                    a.close();
                                };
                                a.Ga.jb.body.appendChild(d);
                            }
                        } catch (e) {}
                    }, Math.floor(1));
                }
                var vh = null;
                "undefined" !== typeof MozWebSocket
                    ? (vh = MozWebSocket)
                    : "undefined" !== typeof WebSocket && (vh = WebSocket);
                function wh(a, b, c, d) {
                    this.ue = a;
                    this.f = pd(this.ue);
                    this.frames = this.Nc = null;
                    this.rb = this.sb = this.ff = 0;
                    this.Xa = uc(b);
                    a = { v: "5" };
                    "undefined" !== typeof location &&
                        location.href &&
                        -1 !== location.href.indexOf("firebaseio.com") &&
                        (a.r = "f");
                    c && (a.s = c);
                    d && (a.ls = d);
                    this.jf = fd(b, gd, a);
                }
                var xh;
                wh.prototype.open = function (a, b) {
                    this.lb = b;
                    this.Kg = a;
                    this.f("Websocket connecting to " + this.jf);
                    this.Kc = !1;
                    bd.set("previous_websocket_failure", !0);
                    try {
                        this.La = new vh(this.jf);
                    } catch (c) {
                        this.f("Error instantiating WebSocket.");
                        var d = c.message || c.data;
                        d && this.f(d);
                        this.bb();
                        return;
                    }
                    var e = this;
                    this.La.onopen = function () {
                        e.f("Websocket connected.");
                        e.Kc = !0;
                    };
                    this.La.onclose = function () {
                        e.f("Websocket connection was disconnected.");
                        e.La = null;
                        e.bb();
                    };
                    this.La.onmessage = function (a) {
                        if (null !== e.La)
                            if (
                                ((a = a.data),
                                (e.rb += a.length),
                                rc(e.Xa, "bytes_received", a.length),
                                yh(e),
                                null !== e.frames)
                            )
                                zh(e, a);
                            else {
                                a: {
                                    O(
                                        null === e.frames,
                                        "We already have a frame buffer"
                                    );
                                    if (6 >= a.length) {
                                        var b = Number(a);
                                        if (!isNaN(b)) {
                                            e.ff = b;
                                            e.frames = [];
                                            a = null;
                                            break a;
                                        }
                                    }
                                    e.ff = 1;
                                    e.frames = [];
                                }
                                null !== a && zh(e, a);
                            }
                    };
                    this.La.onerror = function (a) {
                        e.f("WebSocket error.  Closing connection.");
                        (a = a.message || a.data) && e.f(a);
                        e.bb();
                    };
                };
                wh.prototype.start = function () {};
                wh.isAvailable = function () {
                    var a = !1;
                    if (
                        "undefined" !== typeof navigator &&
                        navigator.userAgent
                    ) {
                        var b = navigator.userAgent.match(
                            /Android ([0-9]{0,}\.[0-9]{0,})/
                        );
                        b && 1 < b.length && 4.4 > parseFloat(b[1]) && (a = !0);
                    }
                    return !a && null !== vh && !xh;
                };
                wh.responsesRequiredToBeHealthy = 2;
                wh.healthyTimeout = 3e4;
                h = wh.prototype;
                h.Hd = function () {
                    bd.remove("previous_websocket_failure");
                };
                function zh(a, b) {
                    a.frames.push(b);
                    if (a.frames.length == a.ff) {
                        var c = a.frames.join("");
                        a.frames = null;
                        c = Rb(c);
                        a.Kg(c);
                    }
                }
                h.send = function (a) {
                    yh(this);
                    a = G(a);
                    this.sb += a.length;
                    rc(this.Xa, "bytes_sent", a.length);
                    a = yd(a, 16384);
                    1 < a.length && Ah(this, String(a.length));
                    for (var b = 0; b < a.length; b++) Ah(this, a[b]);
                };
                h.fd = function () {
                    this.Db = !0;
                    this.Nc && (clearInterval(this.Nc), (this.Nc = null));
                    this.La && (this.La.close(), (this.La = null));
                };
                h.bb = function () {
                    this.Db ||
                        (this.f("WebSocket is closing itself"),
                        this.fd(),
                        this.lb && (this.lb(this.Kc), (this.lb = null)));
                };
                h.close = function () {
                    this.Db || (this.f("WebSocket is being closed"), this.fd());
                };
                function yh(a) {
                    clearInterval(a.Nc);
                    a.Nc = setInterval(function () {
                        a.La && Ah(a, "0");
                        yh(a);
                    }, Math.floor(45e3));
                }
                function Ah(a, b) {
                    try {
                        a.La.send(b);
                    } catch (c) {
                        a.f(
                            "Exception thrown from WebSocket.send():",
                            c.message || c.data,
                            "Closing connection."
                        ),
                            setTimeout(u(a.bb, a), 0);
                    }
                }
                function Bh(a) {
                    Ch(this, a);
                }
                var Dh = [nh, wh];
                function Ch(a, b) {
                    var c = wh && wh.isAvailable(),
                        d =
                            c &&
                            !(
                                bd.Af ||
                                !0 === bd.get("previous_websocket_failure")
                            );
                    b.ih &&
                        (c ||
                            S(
                                "wss:// URL used, but browser isn't known to support websockets.  Trying anyway."
                            ),
                        (d = !0));
                    if (d) a.jd = [wh];
                    else {
                        var e = (a.jd = []);
                        zd(Dh, function (a, b) {
                            b && b.isAvailable() && e.push(b);
                        });
                    }
                }
                function Eh(a) {
                    if (0 < a.jd.length) return a.jd[0];
                    throw Error("No transports available");
                }
                function Fh(a, b, c, d, e, f, g) {
                    this.id = a;
                    this.f = pd("c:" + this.id + ":");
                    this.nc = c;
                    this.Zc = d;
                    this.na = e;
                    this.Re = f;
                    this.G = b;
                    this.Pd = [];
                    this.kf = 0;
                    this.Wf = new Bh(b);
                    this.N = 0;
                    this.Fb = g;
                    this.f("Connection created");
                    Gh(this);
                }
                function Gh(a) {
                    var b = Eh(a.Wf);
                    a.K = new b("c:" + a.id + ":" + a.kf++, a.G, void 0, a.Fb);
                    a.Ve = b.responsesRequiredToBeHealthy || 0;
                    var c = Hh(a, a.K),
                        d = Ih(a, a.K);
                    a.kd = a.K;
                    a.ed = a.K;
                    a.F = null;
                    a.Eb = !1;
                    setTimeout(function () {
                        a.K && a.K.open(c, d);
                    }, Math.floor(0));
                    b = b.healthyTimeout || 0;
                    0 < b &&
                        (a.Bd = setTimeout(function () {
                            a.Bd = null;
                            a.Eb ||
                                (a.K && 102400 < a.K.rb
                                    ? (a.f(
                                          "Connection exceeded healthy timeout but has received " +
                                              a.K.rb +
                                              " bytes.  Marking connection healthy."
                                      ),
                                      (a.Eb = !0),
                                      a.K.Hd())
                                    : a.K && 10240 < a.K.sb
                                    ? a.f(
                                          "Connection exceeded healthy timeout but has sent " +
                                              a.K.sb +
                                              " bytes.  Leaving connection alive."
                                      )
                                    : (a.f(
                                          "Closing unhealthy connection after timeout."
                                      ),
                                      a.close()));
                        }, Math.floor(b)));
                }
                function Ih(a, b) {
                    return function (c) {
                        b === a.K
                            ? ((a.K = null),
                              c || 0 !== a.N
                                  ? 1 === a.N &&
                                    a.f("Realtime connection lost.")
                                  : (a.f("Realtime connection failed."),
                                    "s-" === a.G.ab.substr(0, 2) &&
                                        (bd.remove("host:" + a.G.host),
                                        (a.G.ab = a.G.host))),
                              a.close())
                            : b === a.F
                            ? (a.f("Secondary connection lost."),
                              (c = a.F),
                              (a.F = null),
                              (a.kd !== c && a.ed !== c) || a.close())
                            : a.f("closing an old connection");
                    };
                }
                function Hh(a, b) {
                    return function (c) {
                        if (2 != a.N)
                            if (b === a.ed) {
                                var d = wd("t", c);
                                c = wd("d", c);
                                if ("c" == d) {
                                    if (((d = wd("t", c)), "d" in c))
                                        if (((c = c.d), "h" === d)) {
                                            var d = c.ts,
                                                e = c.v,
                                                f = c.h;
                                            a.Uf = c.s;
                                            ed(a.G, f);
                                            0 == a.N &&
                                                (a.K.start(),
                                                Jh(a, a.K, d),
                                                "5" !== e &&
                                                    S(
                                                        "Protocol version mismatch detected"
                                                    ),
                                                (c = a.Wf),
                                                (c =
                                                    1 < c.jd.length
                                                        ? c.jd[1]
                                                        : null) && Kh(a, c));
                                        } else if ("n" === d) {
                                            a.f(
                                                "recvd end transmission on primary"
                                            );
                                            a.ed = a.F;
                                            for (c = 0; c < a.Pd.length; ++c)
                                                a.Ld(a.Pd[c]);
                                            a.Pd = [];
                                            Lh(a);
                                        } else
                                            "s" === d
                                                ? (a.f(
                                                      "Connection shutdown command received. Shutting down..."
                                                  ),
                                                  a.Re &&
                                                      (a.Re(c), (a.Re = null)),
                                                  (a.na = null),
                                                  a.close())
                                                : "r" === d
                                                ? (a.f(
                                                      "Reset packet received.  New host: " +
                                                          c
                                                  ),
                                                  ed(a.G, c),
                                                  1 === a.N
                                                      ? a.close()
                                                      : (Mh(a), Gh(a)))
                                                : "e" === d
                                                ? qd("Server Error: " + c)
                                                : "o" === d
                                                ? (a.f("got pong on primary."),
                                                  Nh(a),
                                                  Oh(a))
                                                : qd(
                                                      "Unknown control packet command: " +
                                                          d
                                                  );
                                } else "d" == d && a.Ld(c);
                            } else if (b === a.F)
                                if (
                                    ((d = wd("t", c)),
                                    (c = wd("d", c)),
                                    "c" == d)
                                )
                                    "t" in c &&
                                        ((c = c.t),
                                        "a" === c
                                            ? Ph(a)
                                            : "r" === c
                                            ? (a.f(
                                                  "Got a reset on secondary, closing it"
                                              ),
                                              a.F.close(),
                                              (a.kd !== a.F && a.ed !== a.F) ||
                                                  a.close())
                                            : "o" === c &&
                                              (a.f("got pong on secondary."),
                                              a.Tf--,
                                              Ph(a)));
                                else if ("d" == d) a.Pd.push(c);
                                else
                                    throw Error("Unknown protocol layer: " + d);
                            else a.f("message on old connection");
                    };
                }
                Fh.prototype.Ia = function (a) {
                    Qh(this, { t: "d", d: a });
                };
                function Lh(a) {
                    a.kd === a.F &&
                        a.ed === a.F &&
                        (a.f(
                            "cleaning up and promoting a connection: " + a.F.ue
                        ),
                        (a.K = a.F),
                        (a.F = null));
                }
                function Ph(a) {
                    0 >= a.Tf
                        ? (a.f("Secondary connection is healthy."),
                          (a.Eb = !0),
                          a.F.Hd(),
                          a.F.start(),
                          a.f("sending client ack on secondary"),
                          a.F.send({ t: "c", d: { t: "a", d: {} } }),
                          a.f("Ending transmission on primary"),
                          a.K.send({ t: "c", d: { t: "n", d: {} } }),
                          (a.kd = a.F),
                          Lh(a))
                        : (a.f("sending ping on secondary."),
                          a.F.send({ t: "c", d: { t: "p", d: {} } }));
                }
                Fh.prototype.Ld = function (a) {
                    Nh(this);
                    this.nc(a);
                };
                function Nh(a) {
                    a.Eb ||
                        (a.Ve--,
                        0 >= a.Ve &&
                            (a.f("Primary connection is healthy."),
                            (a.Eb = !0),
                            a.K.Hd()));
                }
                function Kh(a, b) {
                    a.F = new b("c:" + a.id + ":" + a.kf++, a.G, a.Uf);
                    a.Tf = b.responsesRequiredToBeHealthy || 0;
                    a.F.open(Hh(a, a.F), Ih(a, a.F));
                    setTimeout(function () {
                        a.F &&
                            (a.f("Timed out trying to upgrade."), a.F.close());
                    }, Math.floor(6e4));
                }
                function Jh(a, b, c) {
                    a.f("Realtime connection established.");
                    a.K = b;
                    a.N = 1;
                    a.Zc && (a.Zc(c, a.Uf), (a.Zc = null));
                    0 === a.Ve
                        ? (a.f("Primary connection is healthy."), (a.Eb = !0))
                        : setTimeout(function () {
                              Oh(a);
                          }, Math.floor(5e3));
                }
                function Oh(a) {
                    a.Eb ||
                        1 !== a.N ||
                        (a.f("sending ping on primary."),
                        Qh(a, { t: "c", d: { t: "p", d: {} } }));
                }
                function Qh(a, b) {
                    if (1 !== a.N) throw "Connection is not connected";
                    a.kd.send(b);
                }
                Fh.prototype.close = function () {
                    2 !== this.N &&
                        (this.f("Closing realtime connection."),
                        (this.N = 2),
                        Mh(this),
                        this.na && (this.na(), (this.na = null)));
                };
                function Mh(a) {
                    a.f("Shutting down all connections");
                    a.K && (a.K.close(), (a.K = null));
                    a.F && (a.F.close(), (a.F = null));
                    a.Bd && (clearTimeout(a.Bd), (a.Bd = null));
                }
                function Rh(a, b, c, d) {
                    this.id = Sh++;
                    this.f = pd("p:" + this.id + ":");
                    this.Bf = this.Ie = !1;
                    this.ba = {};
                    this.sa = [];
                    this.ad = 0;
                    this.Yc = [];
                    this.qa = !1;
                    this.eb = 1e3;
                    this.Id = 3e5;
                    this.Kb = b;
                    this.Xc = c;
                    this.Se = d;
                    this.G = a;
                    this.wb = this.Ca = this.Ma = this.Fb = this.$e = null;
                    this.Sb = !1;
                    this.Wd = {};
                    this.Wg = 0;
                    this.rf = !0;
                    this.Oc = this.Ke = null;
                    Th(this, 0);
                    kf.yb().Ib("visible", this.Ng, this);
                    -1 === a.host.indexOf("fblocal") &&
                        jf.yb().Ib("online", this.Lg, this);
                }
                var Sh = 0,
                    Uh = 0;
                h = Rh.prototype;
                h.Ia = function (a, b, c) {
                    var d = ++this.Wg;
                    a = { r: d, a: a, b: b };
                    this.f(G(a));
                    O(
                        this.qa,
                        "sendRequest call when we're not connected not allowed."
                    );
                    this.Ma.Ia(a);
                    c && (this.Wd[d] = c);
                };
                h.Cf = function (a, b, c, d) {
                    var e = a.wa(),
                        f = a.path.toString();
                    this.f("Listen called for " + f + " " + e);
                    this.ba[f] = this.ba[f] || {};
                    O(
                        Ie(a.n) || !He(a.n),
                        "listen() called for non-default but complete query"
                    );
                    O(
                        !this.ba[f][e],
                        "listen() called twice for same path/queryId."
                    );
                    a = { I: d, Ad: b, Tg: a, tag: c };
                    this.ba[f][e] = a;
                    this.qa && Vh(this, a);
                };
                function Vh(a, b) {
                    var c = b.Tg,
                        d = c.path.toString(),
                        e = c.wa();
                    a.f("Listen on " + d + " for " + e);
                    var f = { p: d };
                    b.tag && ((f.q = Ge(c.n)), (f.t = b.tag));
                    f.h = b.Ad();
                    a.Ia("q", f, function (f) {
                        var k = f.d,
                            m = f.s;
                        if (k && "object" === typeof k && y(k, "w")) {
                            var l = z(k, "w");
                            da(l) &&
                                0 <= La(l, "no_index") &&
                                S(
                                    "Using an unspecified index. Consider adding " +
                                        ('".indexOn": "' +
                                            c.n.g.toString() +
                                            '"') +
                                        " at " +
                                        c.path.toString() +
                                        " to your security rules for better performance"
                                );
                        }
                        (a.ba[d] && a.ba[d][e]) === b &&
                            (a.f("listen response", f),
                            "ok" !== m && Wh(a, d, e),
                            b.I && b.I(m, k));
                    });
                }
                h.O = function (a, b, c) {
                    this.Ca = { rg: a, sf: !1, Dc: b, od: c };
                    this.f("Authenticating using credential: " + a);
                    Xh(this);
                    (b = 40 == a.length) ||
                        ((a = Cd(a).Ec),
                        (b = "object" === typeof a && !0 === z(a, "admin")));
                    b &&
                        (this.f(
                            "Admin auth credential detected.  Reducing max reconnect time."
                        ),
                        (this.Id = 3e4));
                };
                h.je = function (a) {
                    this.Ca = null;
                    this.qa &&
                        this.Ia("unauth", {}, function (b) {
                            a(b.s, b.d);
                        });
                };
                function Xh(a) {
                    var b = a.Ca;
                    a.qa &&
                        b &&
                        a.Ia("auth", { cred: b.rg }, function (c) {
                            var d = c.s;
                            c = c.d || "error";
                            "ok" !== d && a.Ca === b && (a.Ca = null);
                            b.sf
                                ? "ok" !== d && b.od && b.od(d, c)
                                : ((b.sf = !0), b.Dc && b.Dc(d, c));
                        });
                }
                h.$f = function (a, b) {
                    var c = a.path.toString(),
                        d = a.wa();
                    this.f("Unlisten called for " + c + " " + d);
                    O(
                        Ie(a.n) || !He(a.n),
                        "unlisten() called for non-default but complete query"
                    );
                    if (Wh(this, c, d) && this.qa) {
                        var e = Ge(a.n);
                        this.f("Unlisten on " + c + " for " + d);
                        c = { p: c };
                        b && ((c.q = e), (c.t = b));
                        this.Ia("n", c);
                    }
                };
                h.Qe = function (a, b, c) {
                    this.qa
                        ? Yh(this, "o", a, b, c)
                        : this.Yc.push({ bd: a, action: "o", data: b, I: c });
                };
                h.Gf = function (a, b, c) {
                    this.qa
                        ? Yh(this, "om", a, b, c)
                        : this.Yc.push({ bd: a, action: "om", data: b, I: c });
                };
                h.Md = function (a, b) {
                    this.qa
                        ? Yh(this, "oc", a, null, b)
                        : this.Yc.push({
                              bd: a,
                              action: "oc",
                              data: null,
                              I: b,
                          });
                };
                function Yh(a, b, c, d, e) {
                    c = { p: c, d: d };
                    a.f("onDisconnect " + b, c);
                    a.Ia(b, c, function (a) {
                        e &&
                            setTimeout(function () {
                                e(a.s, a.d);
                            }, Math.floor(0));
                    });
                }
                h.put = function (a, b, c, d) {
                    Zh(this, "p", a, b, c, d);
                };
                h.Df = function (a, b, c, d) {
                    Zh(this, "m", a, b, c, d);
                };
                function Zh(a, b, c, d, e, f) {
                    d = { p: c, d: d };
                    p(f) && (d.h = f);
                    a.sa.push({ action: b, Pf: d, I: e });
                    a.ad++;
                    b = a.sa.length - 1;
                    a.qa ? $h(a, b) : a.f("Buffering put: " + c);
                }
                function $h(a, b) {
                    var c = a.sa[b].action,
                        d = a.sa[b].Pf,
                        e = a.sa[b].I;
                    a.sa[b].Ug = a.qa;
                    a.Ia(c, d, function (d) {
                        a.f(c + " response", d);
                        delete a.sa[b];
                        a.ad--;
                        0 === a.ad && (a.sa = []);
                        e && e(d.s, d.d);
                    });
                }
                h.Ye = function (a) {
                    this.qa &&
                        ((a = { c: a }),
                        this.f("reportStats", a),
                        this.Ia("s", a, function (a) {
                            "ok" !== a.s &&
                                this.f(
                                    "reportStats",
                                    "Error sending stats: " + a.d
                                );
                        }));
                };
                h.Ld = function (a) {
                    if ("r" in a) {
                        this.f("from server: " + G(a));
                        var b = a.r,
                            c = this.Wd[b];
                        c && (delete this.Wd[b], c(a.b));
                    } else {
                        if ("error" in a)
                            throw (
                                "A server-side error has occurred: " + a.error
                            );
                        "a" in a &&
                            ((b = a.a),
                            (c = a.b),
                            this.f("handleServerMessage", b, c),
                            "d" === b
                                ? this.Kb(c.p, c.d, !1, c.t)
                                : "m" === b
                                ? this.Kb(c.p, c.d, !0, c.t)
                                : "c" === b
                                ? ai(this, c.p, c.q)
                                : "ac" === b
                                ? ((a = c.s),
                                  (b = c.d),
                                  (c = this.Ca),
                                  (this.Ca = null),
                                  c && c.od && c.od(a, b))
                                : "sd" === b
                                ? this.$e
                                    ? this.$e(c)
                                    : "msg" in c &&
                                      "undefined" !== typeof console &&
                                      console.log(
                                          "FIREBASE: " +
                                              c.msg.replace(
                                                  "\n",
                                                  "\nFIREBASE: "
                                              )
                                      )
                                : qd(
                                      "Unrecognized action received from server: " +
                                          G(b) +
                                          "\nAre you using the latest client?"
                                  ));
                    }
                };
                h.Zc = function (a, b) {
                    this.f("connection ready");
                    this.qa = !0;
                    this.Oc = new Date().getTime();
                    this.Se({ serverTimeOffset: a - new Date().getTime() });
                    this.Fb = b;
                    if (this.rf) {
                        var c = {};
                        c["sdk.js." + Eb.replace(/\./g, "-")] = 1;
                        Dg()
                            ? (c["framework.cordova"] = 1)
                            : "object" === typeof navigator &&
                              "ReactNative" === navigator.product &&
                              (c["framework.reactnative"] = 1);
                        this.Ye(c);
                    }
                    bi(this);
                    this.rf = !1;
                    this.Xc(!0);
                };
                function Th(a, b) {
                    O(
                        !a.Ma,
                        "Scheduling a connect when we're already connected/ing?"
                    );
                    a.wb && clearTimeout(a.wb);
                    a.wb = setTimeout(function () {
                        a.wb = null;
                        ci(a);
                    }, Math.floor(b));
                }
                h.Ng = function (a) {
                    a &&
                        !this.Sb &&
                        this.eb === this.Id &&
                        (this.f("Window became visible.  Reducing delay."),
                        (this.eb = 1e3),
                        this.Ma || Th(this, 0));
                    this.Sb = a;
                };
                h.Lg = function (a) {
                    a
                        ? (this.f("Browser went online."),
                          (this.eb = 1e3),
                          this.Ma || Th(this, 0))
                        : (this.f("Browser went offline.  Killing connection."),
                          this.Ma && this.Ma.close());
                };
                h.If = function () {
                    this.f("data client disconnected");
                    this.qa = !1;
                    this.Ma = null;
                    for (var a = 0; a < this.sa.length; a++) {
                        var b = this.sa[a];
                        b &&
                            "h" in b.Pf &&
                            b.Ug &&
                            (b.I && b.I("disconnect"),
                            delete this.sa[a],
                            this.ad--);
                    }
                    0 === this.ad && (this.sa = []);
                    this.Wd = {};
                    di(this) &&
                        (this.Sb
                            ? this.Oc &&
                              (3e4 < new Date().getTime() - this.Oc &&
                                  (this.eb = 1e3),
                              (this.Oc = null))
                            : (this.f(
                                  "Window isn't visible.  Delaying reconnect."
                              ),
                              (this.eb = this.Id),
                              (this.Ke = new Date().getTime())),
                        (a = Math.max(
                            0,
                            this.eb - (new Date().getTime() - this.Ke)
                        )),
                        (a *= Math.random()),
                        this.f("Trying to reconnect in " + a + "ms"),
                        Th(this, a),
                        (this.eb = Math.min(this.Id, 1.3 * this.eb)));
                    this.Xc(!1);
                };
                function ci(a) {
                    if (di(a)) {
                        a.f("Making a connection attempt");
                        a.Ke = new Date().getTime();
                        a.Oc = null;
                        var b = u(a.Ld, a),
                            c = u(a.Zc, a),
                            d = u(a.If, a),
                            e = a.id + ":" + Uh++;
                        a.Ma = new Fh(
                            e,
                            a.G,
                            b,
                            c,
                            d,
                            function (b) {
                                S(b + " (" + a.G.toString() + ")");
                                a.Bf = !0;
                            },
                            a.Fb
                        );
                    }
                }
                h.Cb = function () {
                    this.Ie = !0;
                    this.Ma
                        ? this.Ma.close()
                        : (this.wb && (clearTimeout(this.wb), (this.wb = null)),
                          this.qa && this.If());
                };
                h.vc = function () {
                    this.Ie = !1;
                    this.eb = 1e3;
                    this.Ma || Th(this, 0);
                };
                function ai(a, b, c) {
                    c = c
                        ? Oa(c, function (a) {
                              return xd(a);
                          }).join("$")
                        : "default";
                    (a = Wh(a, b, c)) && a.I && a.I("permission_denied");
                }
                function Wh(a, b, c) {
                    b = new P(b).toString();
                    var d;
                    p(a.ba[b])
                        ? ((d = a.ba[b][c]),
                          delete a.ba[b][c],
                          0 === oa(a.ba[b]) && delete a.ba[b])
                        : (d = void 0);
                    return d;
                }
                function bi(a) {
                    Xh(a);
                    v(a.ba, function (b) {
                        v(b, function (b) {
                            Vh(a, b);
                        });
                    });
                    for (var b = 0; b < a.sa.length; b++) a.sa[b] && $h(a, b);
                    for (; a.Yc.length; )
                        (b = a.Yc.shift()), Yh(a, b.action, b.bd, b.data, b.I);
                }
                function di(a) {
                    var b;
                    b = jf.yb().oc;
                    return !a.Bf && !a.Ie && b;
                }
                var U = {
                    zg: function () {
                        oh = xh = !0;
                    },
                };
                U.forceLongPolling = U.zg;
                U.Ag = function () {
                    ph = !0;
                };
                U.forceWebSockets = U.Ag;
                U.$g = function (a, b) {
                    a.k.Va.$e = b;
                };
                U.setSecurityDebugCallback = U.$g;
                U.bf = function (a, b) {
                    a.k.bf(b);
                };
                U.stats = U.bf;
                U.cf = function (a, b) {
                    a.k.cf(b);
                };
                U.statsIncrementCounter = U.cf;
                U.ud = function (a) {
                    return a.k.ud;
                };
                U.dataUpdateCount = U.ud;
                U.Dg = function (a, b) {
                    a.k.He = b;
                };
                U.interceptServerData = U.Dg;
                U.Jg = function (a) {
                    new Og(a);
                };
                U.onPopupOpen = U.Jg;
                U.Yg = function (a) {
                    xg = a;
                };
                U.setAuthenticationServer = U.Yg;
                function ei(a, b) {
                    this.committed = a;
                    this.snapshot = b;
                }
                function V(a, b) {
                    this.dd = a;
                    this.ta = b;
                }
                V.prototype.cancel = function (a) {
                    D("Firebase.onDisconnect().cancel", 0, 1, arguments.length);
                    F("Firebase.onDisconnect().cancel", 1, a, !0);
                    var b = new B();
                    this.dd.Md(this.ta, C(b, a));
                    return b.D;
                };
                V.prototype.cancel = V.prototype.cancel;
                V.prototype.remove = function (a) {
                    D("Firebase.onDisconnect().remove", 0, 1, arguments.length);
                    og("Firebase.onDisconnect().remove", this.ta);
                    F("Firebase.onDisconnect().remove", 1, a, !0);
                    var b = new B();
                    fi(this.dd, this.ta, null, C(b, a));
                    return b.D;
                };
                V.prototype.remove = V.prototype.remove;
                V.prototype.set = function (a, b) {
                    D("Firebase.onDisconnect().set", 1, 2, arguments.length);
                    og("Firebase.onDisconnect().set", this.ta);
                    gg("Firebase.onDisconnect().set", a, this.ta, !1);
                    F("Firebase.onDisconnect().set", 2, b, !0);
                    var c = new B();
                    fi(this.dd, this.ta, a, C(c, b));
                    return c.D;
                };
                V.prototype.set = V.prototype.set;
                V.prototype.Ob = function (a, b, c) {
                    D(
                        "Firebase.onDisconnect().setWithPriority",
                        2,
                        3,
                        arguments.length
                    );
                    og("Firebase.onDisconnect().setWithPriority", this.ta);
                    gg(
                        "Firebase.onDisconnect().setWithPriority",
                        a,
                        this.ta,
                        !1
                    );
                    kg("Firebase.onDisconnect().setWithPriority", 2, b);
                    F("Firebase.onDisconnect().setWithPriority", 3, c, !0);
                    var d = new B();
                    gi(this.dd, this.ta, a, b, C(d, c));
                    return d.D;
                };
                V.prototype.setWithPriority = V.prototype.Ob;
                V.prototype.update = function (a, b) {
                    D("Firebase.onDisconnect().update", 1, 2, arguments.length);
                    og("Firebase.onDisconnect().update", this.ta);
                    if (da(a)) {
                        for (var c = {}, d = 0; d < a.length; ++d)
                            c["" + d] = a[d];
                        a = c;
                        S(
                            "Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children."
                        );
                    }
                    jg("Firebase.onDisconnect().update", a, this.ta);
                    F("Firebase.onDisconnect().update", 2, b, !0);
                    c = new B();
                    hi(this.dd, this.ta, a, C(c, b));
                    return c.D;
                };
                V.prototype.update = V.prototype.update;
                function W(a, b, c) {
                    this.A = a;
                    this.Y = b;
                    this.g = c;
                }
                W.prototype.J = function () {
                    D("Firebase.DataSnapshot.val", 0, 0, arguments.length);
                    return this.A.J();
                };
                W.prototype.val = W.prototype.J;
                W.prototype.qf = function () {
                    D(
                        "Firebase.DataSnapshot.exportVal",
                        0,
                        0,
                        arguments.length
                    );
                    return this.A.J(!0);
                };
                W.prototype.exportVal = W.prototype.qf;
                W.prototype.xg = function () {
                    D("Firebase.DataSnapshot.exists", 0, 0, arguments.length);
                    return !this.A.e();
                };
                W.prototype.exists = W.prototype.xg;
                W.prototype.o = function (a) {
                    D("Firebase.DataSnapshot.child", 0, 1, arguments.length);
                    fa(a) && (a = String(a));
                    ng("Firebase.DataSnapshot.child", a);
                    var b = new P(a),
                        c = this.Y.o(b);
                    return new W(this.A.S(b), c, R);
                };
                W.prototype.child = W.prototype.o;
                W.prototype.Fa = function (a) {
                    D("Firebase.DataSnapshot.hasChild", 1, 1, arguments.length);
                    ng("Firebase.DataSnapshot.hasChild", a);
                    var b = new P(a);
                    return !this.A.S(b).e();
                };
                W.prototype.hasChild = W.prototype.Fa;
                W.prototype.C = function () {
                    D(
                        "Firebase.DataSnapshot.getPriority",
                        0,
                        0,
                        arguments.length
                    );
                    return this.A.C().J();
                };
                W.prototype.getPriority = W.prototype.C;
                W.prototype.forEach = function (a) {
                    D("Firebase.DataSnapshot.forEach", 1, 1, arguments.length);
                    F("Firebase.DataSnapshot.forEach", 1, a, !1);
                    if (this.A.L()) return !1;
                    var b = this;
                    return !!this.A.R(this.g, function (c, d) {
                        return a(new W(d, b.Y.o(c), R));
                    });
                };
                W.prototype.forEach = W.prototype.forEach;
                W.prototype.zd = function () {
                    D(
                        "Firebase.DataSnapshot.hasChildren",
                        0,
                        0,
                        arguments.length
                    );
                    return this.A.L() ? !1 : !this.A.e();
                };
                W.prototype.hasChildren = W.prototype.zd;
                W.prototype.name = function () {
                    S(
                        "Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead."
                    );
                    D("Firebase.DataSnapshot.name", 0, 0, arguments.length);
                    return this.key();
                };
                W.prototype.name = W.prototype.name;
                W.prototype.key = function () {
                    D("Firebase.DataSnapshot.key", 0, 0, arguments.length);
                    return this.Y.key();
                };
                W.prototype.key = W.prototype.key;
                W.prototype.Hb = function () {
                    D(
                        "Firebase.DataSnapshot.numChildren",
                        0,
                        0,
                        arguments.length
                    );
                    return this.A.Hb();
                };
                W.prototype.numChildren = W.prototype.Hb;
                W.prototype.Mb = function () {
                    D("Firebase.DataSnapshot.ref", 0, 0, arguments.length);
                    return this.Y;
                };
                W.prototype.ref = W.prototype.Mb;
                function ii(a, b, c) {
                    this.Vb = a;
                    this.tb = b;
                    this.vb = c || null;
                }
                h = ii.prototype;
                h.Qf = function (a) {
                    return "value" === a;
                };
                h.createEvent = function (a, b) {
                    var c = b.n.g;
                    return new jc("value", this, new W(a.Na, b.Mb(), c));
                };
                h.Zb = function (a) {
                    var b = this.vb;
                    if ("cancel" === a.De()) {
                        O(
                            this.tb,
                            "Raising a cancel event on a listener with no cancel callback"
                        );
                        var c = this.tb;
                        return function () {
                            c.call(b, a.error);
                        };
                    }
                    var d = this.Vb;
                    return function () {
                        d.call(b, a.be);
                    };
                };
                h.lf = function (a, b) {
                    return this.tb ? new kc(this, a, b) : null;
                };
                h.matches = function (a) {
                    return a instanceof ii
                        ? a.Vb && this.Vb
                            ? a.Vb === this.Vb && a.vb === this.vb
                            : !0
                        : !1;
                };
                h.yf = function () {
                    return null !== this.Vb;
                };
                function ji(a, b, c) {
                    this.ja = a;
                    this.tb = b;
                    this.vb = c;
                }
                h = ji.prototype;
                h.Qf = function (a) {
                    a = "children_added" === a ? "child_added" : a;
                    return (
                        ("children_removed" === a ? "child_removed" : a) in
                        this.ja
                    );
                };
                h.lf = function (a, b) {
                    return this.tb ? new kc(this, a, b) : null;
                };
                h.createEvent = function (a, b) {
                    O(null != a.Za, "Child events should have a childName.");
                    var c = b.Mb().o(a.Za);
                    return new jc(a.type, this, new W(a.Na, c, b.n.g), a.Td);
                };
                h.Zb = function (a) {
                    var b = this.vb;
                    if ("cancel" === a.De()) {
                        O(
                            this.tb,
                            "Raising a cancel event on a listener with no cancel callback"
                        );
                        var c = this.tb;
                        return function () {
                            c.call(b, a.error);
                        };
                    }
                    var d = this.ja[a.wd];
                    return function () {
                        d.call(b, a.be, a.Td);
                    };
                };
                h.matches = function (a) {
                    if (a instanceof ji) {
                        if (!this.ja || !a.ja) return !0;
                        if (this.vb === a.vb) {
                            var b = oa(a.ja);
                            if (b === oa(this.ja)) {
                                if (1 === b) {
                                    var b = pa(a.ja),
                                        c = pa(this.ja);
                                    return (
                                        c === b &&
                                        (!a.ja[b] ||
                                            !this.ja[c] ||
                                            a.ja[b] === this.ja[c])
                                    );
                                }
                                return na(this.ja, function (b, c) {
                                    return a.ja[c] === b;
                                });
                            }
                        }
                    }
                    return !1;
                };
                h.yf = function () {
                    return null !== this.ja;
                };
                function ki() {
                    this.za = {};
                }
                h = ki.prototype;
                h.e = function () {
                    return va(this.za);
                };
                h.gb = function (a, b, c) {
                    var d = a.source.Lb;
                    if (null !== d)
                        return (
                            (d = z(this.za, d)),
                            O(
                                null != d,
                                "SyncTree gave us an op for an invalid query."
                            ),
                            d.gb(a, b, c)
                        );
                    var e = [];
                    v(this.za, function (d) {
                        e = e.concat(d.gb(a, b, c));
                    });
                    return e;
                };
                h.Tb = function (a, b, c, d, e) {
                    var f = a.wa(),
                        g = z(this.za, f);
                    if (!g) {
                        var g = c.Aa(e ? d : null),
                            k = !1;
                        g
                            ? (k = !0)
                            : ((g = d instanceof fe ? c.Cc(d) : H), (k = !1));
                        g = new Ye(
                            a,
                            new je(new Xb(g, k, !1), new Xb(d, e, !1))
                        );
                        this.za[f] = g;
                    }
                    g.Tb(b);
                    return af(g, b);
                };
                h.nb = function (a, b, c) {
                    var d = a.wa(),
                        e = [],
                        f = [],
                        g = null != li(this);
                    if ("default" === d) {
                        var k = this;
                        v(this.za, function (a, d) {
                            f = f.concat(a.nb(b, c));
                            a.e() && (delete k.za[d], He(a.Y.n) || e.push(a.Y));
                        });
                    } else {
                        var m = z(this.za, d);
                        m &&
                            ((f = f.concat(m.nb(b, c))),
                            m.e() &&
                                (delete this.za[d], He(m.Y.n) || e.push(m.Y)));
                    }
                    g && null == li(this) && e.push(new X(a.k, a.path));
                    return { Vg: e, vg: f };
                };
                function mi(a) {
                    return Na(qa(a.za), function (a) {
                        return !He(a.Y.n);
                    });
                }
                h.kb = function (a) {
                    var b = null;
                    v(this.za, function (c) {
                        b = b || c.kb(a);
                    });
                    return b;
                };
                function ni(a, b) {
                    if (He(b.n)) return li(a);
                    var c = b.wa();
                    return z(a.za, c);
                }
                function li(a) {
                    return (
                        ua(a.za, function (a) {
                            return He(a.Y.n);
                        }) || null
                    );
                }
                function oi(a) {
                    this.va = qe;
                    this.mb = new Pf();
                    this.df = {};
                    this.qc = {};
                    this.Qc = a;
                }
                function pi(a, b, c, d, e) {
                    var f = a.mb,
                        g = e;
                    O(d > f.Pc, "Stacking an older write on top of newer ones");
                    p(g) || (g = !0);
                    f.pa.push({ path: b, Ja: c, md: d, visible: g });
                    g && (f.V = Jf(f.V, b, c));
                    f.Pc = d;
                    return e ? qi(a, new Ac(Ef, b, c)) : [];
                }
                function ri(a, b, c, d) {
                    var e = a.mb;
                    O(d > e.Pc, "Stacking an older merge on top of newer ones");
                    e.pa.push({ path: b, children: c, md: d, visible: !0 });
                    e.V = Kf(e.V, b, c);
                    e.Pc = d;
                    c = sf(c);
                    return qi(a, new bf(Ef, b, c));
                }
                function si(a, b, c) {
                    c = c || !1;
                    var d = Qf(a.mb, b);
                    if (a.mb.Ud(b)) {
                        var e = qe;
                        null != d.Ja
                            ? (e = e.set(M, !0))
                            : Fb(d.children, function (a, b) {
                                  e = e.set(new P(a), b);
                              });
                        return qi(a, new Df(d.path, e, c));
                    }
                    return [];
                }
                function ti(a, b, c) {
                    c = sf(c);
                    return qi(a, new bf(Gf, b, c));
                }
                function ui(a, b, c, d) {
                    d = vi(a, d);
                    if (null != d) {
                        var e = wi(d);
                        d = e.path;
                        e = e.Lb;
                        b = lf(d, b);
                        c = new Ac(new Ff(!1, !0, e, !0), b, c);
                        return xi(a, d, c);
                    }
                    return [];
                }
                function yi(a, b, c, d) {
                    if ((d = vi(a, d))) {
                        var e = wi(d);
                        d = e.path;
                        e = e.Lb;
                        b = lf(d, b);
                        c = sf(c);
                        c = new bf(new Ff(!1, !0, e, !0), b, c);
                        return xi(a, d, c);
                    }
                    return [];
                }
                oi.prototype.Tb = function (a, b) {
                    var c = a.path,
                        d = null,
                        e = !1;
                    zf(this.va, c, function (a, b) {
                        var f = lf(a, c);
                        d = d || b.kb(f);
                        e = e || null != li(b);
                    });
                    var f = this.va.get(c);
                    f
                        ? ((e = e || null != li(f)), (d = d || f.kb(M)))
                        : ((f = new ki()), (this.va = this.va.set(c, f)));
                    var g;
                    null != d
                        ? (g = !0)
                        : ((g = !1),
                          (d = H),
                          Cf(this.va.subtree(c), function (a, b) {
                              var c = b.kb(M);
                              c && (d = d.W(a, c));
                          }));
                    var k = null != ni(f, a);
                    if (!k && !He(a.n)) {
                        var m = zi(a);
                        O(
                            !(m in this.qc),
                            "View does not exist, but we have a tag"
                        );
                        var l = Ai++;
                        this.qc[m] = l;
                        this.df["_" + l] = m;
                    }
                    g = f.Tb(a, b, new Uf(c, this.mb), d, g);
                    k || e || ((f = ni(f, a)), (g = g.concat(Bi(this, a, f))));
                    return g;
                };
                oi.prototype.nb = function (a, b, c) {
                    var d = a.path,
                        e = this.va.get(d),
                        f = [];
                    if (e && ("default" === a.wa() || null != ni(e, a))) {
                        f = e.nb(a, b, c);
                        e.e() && (this.va = this.va.remove(d));
                        e = f.Vg;
                        f = f.vg;
                        b =
                            -1 !==
                            Sa(e, function (a) {
                                return He(a.n);
                            });
                        var g = xf(this.va, d, function (a, b) {
                            return null != li(b);
                        });
                        if (b && !g && ((d = this.va.subtree(d)), !d.e()))
                            for (var d = Ci(d), k = 0; k < d.length; ++k) {
                                var m = d[k],
                                    l = m.Y,
                                    m = Di(this, m);
                                this.Qc.af(Ei(l), Fi(this, l), m.Ad, m.I);
                            }
                        if (!g && 0 < e.length && !c)
                            if (b) this.Qc.de(Ei(a), null);
                            else {
                                var t = this;
                                Ma(e, function (a) {
                                    a.wa();
                                    var b = t.qc[zi(a)];
                                    t.Qc.de(Ei(a), b);
                                });
                            }
                        Gi(this, e);
                    }
                    return f;
                };
                oi.prototype.Aa = function (a, b) {
                    var c = this.mb,
                        d = xf(this.va, a, function (b, c) {
                            var d = lf(b, a);
                            if ((d = c.kb(d))) return d;
                        });
                    return c.Aa(a, d, b, !0);
                };
                function Ci(a) {
                    return vf(a, function (a, c, d) {
                        if (c && null != li(c)) return [li(c)];
                        var e = [];
                        c && (e = mi(c));
                        v(d, function (a) {
                            e = e.concat(a);
                        });
                        return e;
                    });
                }
                function Gi(a, b) {
                    for (var c = 0; c < b.length; ++c) {
                        var d = b[c];
                        if (!He(d.n)) {
                            var d = zi(d),
                                e = a.qc[d];
                            delete a.qc[d];
                            delete a.df["_" + e];
                        }
                    }
                }
                function Ei(a) {
                    return He(a.n) && !Ie(a.n) ? a.Mb() : a;
                }
                function Bi(a, b, c) {
                    var d = b.path,
                        e = Fi(a, b);
                    c = Di(a, c);
                    b = a.Qc.af(Ei(b), e, c.Ad, c.I);
                    d = a.va.subtree(d);
                    if (e)
                        O(
                            null == li(d.value),
                            "If we're adding a query, it shouldn't be shadowed"
                        );
                    else
                        for (
                            e = vf(d, function (a, b, c) {
                                if (!a.e() && b && null != li(b))
                                    return [Ze(li(b))];
                                var d = [];
                                b &&
                                    (d = d.concat(
                                        Oa(mi(b), function (a) {
                                            return a.Y;
                                        })
                                    ));
                                v(c, function (a) {
                                    d = d.concat(a);
                                });
                                return d;
                            }),
                                d = 0;
                            d < e.length;
                            ++d
                        )
                            (c = e[d]), a.Qc.de(Ei(c), Fi(a, c));
                    return b;
                }
                function Di(a, b) {
                    var c = b.Y,
                        d = Fi(a, c);
                    return {
                        Ad: function () {
                            return (b.w() || H).hash();
                        },
                        I: function (b) {
                            if ("ok" === b) {
                                if (d) {
                                    var f = c.path;
                                    if ((b = vi(a, d))) {
                                        var g = wi(b);
                                        b = g.path;
                                        g = g.Lb;
                                        f = lf(b, f);
                                        f = new Cc(new Ff(!1, !0, g, !0), f);
                                        b = xi(a, b, f);
                                    } else b = [];
                                } else b = qi(a, new Cc(Gf, c.path));
                                return b;
                            }
                            f = "Unknown Error";
                            "too_big" === b
                                ? (f =
                                      "The data requested exceeds the maximum size that can be accessed with a single request.")
                                : "permission_denied" == b
                                ? (f =
                                      "Client doesn't have permission to access the desired data.")
                                : "unavailable" == b &&
                                  (f = "The service is unavailable");
                            f = Error(
                                b + " at " + c.path.toString() + ": " + f
                            );
                            f.code = b.toUpperCase();
                            return a.nb(c, null, f);
                        },
                    };
                }
                function zi(a) {
                    return a.path.toString() + "$" + a.wa();
                }
                function wi(a) {
                    var b = a.indexOf("$");
                    O(-1 !== b && b < a.length - 1, "Bad queryKey.");
                    return { Lb: a.substr(b + 1), path: new P(a.substr(0, b)) };
                }
                function vi(a, b) {
                    var c = a.df,
                        d = "_" + b;
                    return d in c ? c[d] : void 0;
                }
                function Fi(a, b) {
                    var c = zi(b);
                    return z(a.qc, c);
                }
                var Ai = 1;
                function xi(a, b, c) {
                    var d = a.va.get(b);
                    O(
                        d,
                        "Missing sync point for query tag that we're tracking"
                    );
                    return d.gb(c, new Uf(b, a.mb), null);
                }
                function qi(a, b) {
                    return Hi(a, b, a.va, null, new Uf(M, a.mb));
                }
                function Hi(a, b, c, d, e) {
                    if (b.path.e()) return Ii(a, b, c, d, e);
                    var f = c.get(M);
                    null == d && null != f && (d = f.kb(M));
                    var g = [],
                        k = K(b.path),
                        m = b.$c(k);
                    if ((c = c.children.get(k)) && m)
                        var l = d ? d.T(k) : null,
                            k = e.o(k),
                            g = g.concat(Hi(a, m, c, l, k));
                    f && (g = g.concat(f.gb(b, e, d)));
                    return g;
                }
                function Ii(a, b, c, d, e) {
                    var f = c.get(M);
                    null == d && null != f && (d = f.kb(M));
                    var g = [];
                    c.children.ka(function (c, f) {
                        var l = d ? d.T(c) : null,
                            t = e.o(c),
                            A = b.$c(c);
                        A && (g = g.concat(Ii(a, A, f, l, t)));
                    });
                    f && (g = g.concat(f.gb(b, e, d)));
                    return g;
                }
                function Ji(a, b) {
                    this.G = a;
                    this.Xa = uc(a);
                    this.hd = null;
                    this.fa = new Zb();
                    this.Kd = 1;
                    this.Va = null;
                    b ||
                    0 <=
                        (
                            ("object" === typeof window &&
                                window.navigator &&
                                window.navigator.userAgent) ||
                            ""
                        ).search(
                            /googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i
                        )
                        ? ((this.da = new cf(this.G, u(this.Kb, this))),
                          setTimeout(u(this.Xc, this, !0), 0))
                        : (this.da = this.Va =
                              new Rh(
                                  this.G,
                                  u(this.Kb, this),
                                  u(this.Xc, this),
                                  u(this.Se, this)
                              ));
                    this.dh = vc(
                        a,
                        u(function () {
                            return new pc(this.Xa, this.da);
                        }, this)
                    );
                    this.yc = new Wf();
                    this.Ge = new Sb();
                    var c = this;
                    this.Fd = new oi({
                        af: function (a, b, f, g) {
                            b = [];
                            f = c.Ge.j(a.path);
                            f.e() ||
                                ((b = qi(c.Fd, new Ac(Gf, a.path, f))),
                                setTimeout(function () {
                                    g("ok");
                                }, 0));
                            return b;
                        },
                        de: aa,
                    });
                    Ki(this, "connected", !1);
                    this.na = new Vc();
                    this.O = new Yg(
                        a,
                        u(this.da.O, this.da),
                        u(this.da.je, this.da),
                        u(this.Pe, this)
                    );
                    this.ud = 0;
                    this.He = null;
                    this.M = new oi({
                        af: function (a, b, f, g) {
                            c.da.Cf(a, f, b, function (b, e) {
                                var f = g(b, e);
                                dc(c.fa, a.path, f);
                            });
                            return [];
                        },
                        de: function (a, b) {
                            c.da.$f(a, b);
                        },
                    });
                }
                h = Ji.prototype;
                h.toString = function () {
                    return (this.G.ob ? "https://" : "http://") + this.G.host;
                };
                h.name = function () {
                    return this.G.lc;
                };
                function Li(a) {
                    a = a.Ge.j(new P(".info/serverTimeOffset")).J() || 0;
                    return new Date().getTime() + a;
                }
                function Mi(a) {
                    a = a = { timestamp: Li(a) };
                    a.timestamp = a.timestamp || new Date().getTime();
                    return a;
                }
                h.Kb = function (a, b, c, d) {
                    this.ud++;
                    var e = new P(a);
                    b = this.He ? this.He(a, b) : b;
                    a = [];
                    d
                        ? c
                            ? ((b = ma(b, function (a) {
                                  return Q(a);
                              })),
                              (a = yi(this.M, e, b, d)))
                            : ((b = Q(b)), (a = ui(this.M, e, b, d)))
                        : c
                        ? ((d = ma(b, function (a) {
                              return Q(a);
                          })),
                          (a = ti(this.M, e, d)))
                        : ((d = Q(b)), (a = qi(this.M, new Ac(Gf, e, d))));
                    d = e;
                    0 < a.length && (d = Ni(this, e));
                    dc(this.fa, d, a);
                };
                h.Xc = function (a) {
                    Ki(this, "connected", a);
                    !1 === a && Oi(this);
                };
                h.Se = function (a) {
                    var b = this;
                    zd(a, function (a, d) {
                        Ki(b, d, a);
                    });
                };
                h.Pe = function (a) {
                    Ki(this, "authenticated", a);
                };
                function Ki(a, b, c) {
                    b = new P("/.info/" + b);
                    c = Q(c);
                    var d = a.Ge;
                    d.Zd = d.Zd.H(b, c);
                    c = qi(a.Fd, new Ac(Gf, b, c));
                    dc(a.fa, b, c);
                }
                h.Ob = function (a, b, c, d) {
                    this.f("set", { path: a.toString(), value: b, mh: c });
                    var e = Mi(this);
                    b = Q(b, c);
                    var e = Xc(b, e),
                        f = this.Kd++,
                        e = pi(this.M, a, e, f, !0);
                    $b(this.fa, e);
                    var g = this;
                    this.da.put(a.toString(), b.J(!0), function (b, c) {
                        var e = "ok" === b;
                        e || S("set at " + a + " failed: " + b);
                        e = si(g.M, f, !e);
                        dc(g.fa, a, e);
                        Pi(d, b, c);
                    });
                    e = Qi(this, a);
                    Ni(this, e);
                    dc(this.fa, e, []);
                };
                h.update = function (a, b, c) {
                    this.f("update", { path: a.toString(), value: b });
                    var d = !0,
                        e = Mi(this),
                        f = {};
                    v(b, function (a, b) {
                        d = !1;
                        var c = Q(a);
                        f[b] = Xc(c, e);
                    });
                    if (d)
                        fc(
                            "update() called with empty data.  Don't do anything."
                        ),
                            Pi(c, "ok");
                    else {
                        var g = this.Kd++,
                            k = ri(this.M, a, f, g);
                        $b(this.fa, k);
                        var m = this;
                        this.da.Df(a.toString(), b, function (b, d) {
                            var e = "ok" === b;
                            e || S("update at " + a + " failed: " + b);
                            var e = si(m.M, g, !e),
                                f = a;
                            0 < e.length && (f = Ni(m, a));
                            dc(m.fa, f, e);
                            Pi(c, b, d);
                        });
                        b = Qi(this, a);
                        Ni(this, b);
                        dc(this.fa, a, []);
                    }
                };
                function Oi(a) {
                    a.f("onDisconnectEvents");
                    var b = Mi(a),
                        c = [];
                    Wc(Uc(a.na, b), M, function (b, e) {
                        c = c.concat(qi(a.M, new Ac(Gf, b, e)));
                        var f = Qi(a, b);
                        Ni(a, f);
                    });
                    a.na = new Vc();
                    dc(a.fa, M, c);
                }
                h.Md = function (a, b) {
                    var c = this;
                    this.da.Md(a.toString(), function (d, e) {
                        "ok" === d && wg(c.na, a);
                        Pi(b, d, e);
                    });
                };
                function fi(a, b, c, d) {
                    var e = Q(c);
                    a.da.Qe(b.toString(), e.J(!0), function (c, g) {
                        "ok" === c && a.na.rc(b, e);
                        Pi(d, c, g);
                    });
                }
                function gi(a, b, c, d, e) {
                    var f = Q(c, d);
                    a.da.Qe(b.toString(), f.J(!0), function (c, d) {
                        "ok" === c && a.na.rc(b, f);
                        Pi(e, c, d);
                    });
                }
                function hi(a, b, c, d) {
                    var e = !0,
                        f;
                    for (f in c) e = !1;
                    e
                        ? (fc(
                              "onDisconnect().update() called with empty data.  Don't do anything."
                          ),
                          Pi(d, "ok"))
                        : a.da.Gf(b.toString(), c, function (e, f) {
                              if ("ok" === e)
                                  for (var m in c) {
                                      var l = Q(c[m]);
                                      a.na.rc(b.o(m), l);
                                  }
                              Pi(d, e, f);
                          });
                }
                function Ri(a, b, c) {
                    c = ".info" === K(b.path) ? a.Fd.Tb(b, c) : a.M.Tb(b, c);
                    bc(a.fa, b.path, c);
                }
                h.Cb = function () {
                    this.Va && this.Va.Cb();
                };
                h.vc = function () {
                    this.Va && this.Va.vc();
                };
                h.bf = function (a) {
                    if ("undefined" !== typeof console) {
                        a
                            ? (this.hd || (this.hd = new oc(this.Xa)),
                              (a = this.hd.get()))
                            : (a = this.Xa.get());
                        var b = Pa(
                                ra(a),
                                function (a, b) {
                                    return Math.max(b.length, a);
                                },
                                0
                            ),
                            c;
                        for (c in a) {
                            for (var d = a[c], e = c.length; e < b + 2; e++)
                                c += " ";
                            console.log(c + d);
                        }
                    }
                };
                h.cf = function (a) {
                    rc(this.Xa, a);
                    this.dh.Vf[a] = !0;
                };
                h.f = function (a) {
                    var b = "";
                    this.Va && (b = this.Va.id + ":");
                    fc(b, arguments);
                };
                function Pi(a, b, c) {
                    a &&
                        gc(function () {
                            if ("ok" == b) a(null);
                            else {
                                var d = (b || "error").toUpperCase(),
                                    e = d;
                                c && (e += ": " + c);
                                e = Error(e);
                                e.code = d;
                                a(e);
                            }
                        });
                }
                function Si(a, b, c, d, e) {
                    function f() {}
                    a.f("transaction on " + b);
                    var g = new X(a, b);
                    g.Ib("value", f);
                    c = {
                        path: b,
                        update: c,
                        I: d,
                        status: null,
                        Lf: id(),
                        gf: e,
                        Sf: 0,
                        le: function () {
                            g.mc("value", f);
                        },
                        ne: null,
                        Da: null,
                        rd: null,
                        sd: null,
                        td: null,
                    };
                    d = a.M.Aa(b, void 0) || H;
                    c.rd = d;
                    d = c.update(d.J());
                    if (p(d)) {
                        hg("transaction failed: Data returned ", d, c.path);
                        c.status = 1;
                        e = Xf(a.yc, b);
                        var k = e.Ea() || [];
                        k.push(c);
                        Yf(e, k);
                        "object" === typeof d && null !== d && y(d, ".priority")
                            ? ((k = z(d, ".priority")),
                              O(
                                  fg(k),
                                  "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null."
                              ))
                            : (k = (a.M.Aa(b) || H).C().J());
                        e = Mi(a);
                        d = Q(d, k);
                        e = Xc(d, e);
                        c.sd = d;
                        c.td = e;
                        c.Da = a.Kd++;
                        c = pi(a.M, b, e, c.Da, c.gf);
                        dc(a.fa, b, c);
                        Ti(a);
                    } else
                        c.le(),
                            (c.sd = null),
                            (c.td = null),
                            c.I &&
                                ((a = new W(c.rd, new X(a, c.path), R)),
                                c.I(null, !1, a));
                }
                function Ti(a, b) {
                    var c = b || a.yc;
                    b || Ui(a, c);
                    if (null !== c.Ea()) {
                        var d = Vi(a, c);
                        O(
                            0 < d.length,
                            "Sending zero length transaction queue"
                        );
                        Qa(d, function (a) {
                            return 1 === a.status;
                        }) && Wi(a, c.path(), d);
                    } else
                        c.zd() &&
                            c.R(function (b) {
                                Ti(a, b);
                            });
                }
                function Wi(a, b, c) {
                    for (
                        var d = Oa(c, function (a) {
                                return a.Da;
                            }),
                            e = a.M.Aa(b, d) || H,
                            d = e,
                            e = e.hash(),
                            f = 0;
                        f < c.length;
                        f++
                    ) {
                        var g = c[f];
                        O(
                            1 === g.status,
                            "tryToSendTransactionQueue_: items in queue should all be run."
                        );
                        g.status = 2;
                        g.Sf++;
                        var k = lf(b, g.path),
                            d = d.H(k, g.sd);
                    }
                    d = d.J(!0);
                    a.da.put(
                        b.toString(),
                        d,
                        function (d) {
                            a.f("transaction put response", {
                                path: b.toString(),
                                status: d,
                            });
                            var e = [];
                            if ("ok" === d) {
                                d = [];
                                for (f = 0; f < c.length; f++) {
                                    c[f].status = 3;
                                    e = e.concat(si(a.M, c[f].Da));
                                    if (c[f].I) {
                                        var g = c[f].td,
                                            k = new X(a, c[f].path);
                                        d.push(
                                            u(
                                                c[f].I,
                                                null,
                                                null,
                                                !0,
                                                new W(g, k, R)
                                            )
                                        );
                                    }
                                    c[f].le();
                                }
                                Ui(a, Xf(a.yc, b));
                                Ti(a);
                                dc(a.fa, b, e);
                                for (f = 0; f < d.length; f++) gc(d[f]);
                            } else {
                                if ("datastale" === d)
                                    for (f = 0; f < c.length; f++)
                                        c[f].status = 4 === c[f].status ? 5 : 1;
                                else
                                    for (
                                        S(
                                            "transaction at " +
                                                b.toString() +
                                                " failed: " +
                                                d
                                        ),
                                            f = 0;
                                        f < c.length;
                                        f++
                                    )
                                        (c[f].status = 5), (c[f].ne = d);
                                Ni(a, b);
                            }
                        },
                        e
                    );
                }
                function Ni(a, b) {
                    var c = Xi(a, b),
                        d = c.path(),
                        c = Vi(a, c);
                    Yi(a, c, d);
                    return d;
                }
                function Yi(a, b, c) {
                    if (0 !== b.length) {
                        for (
                            var d = [],
                                e = [],
                                f = Oa(b, function (a) {
                                    return a.Da;
                                }),
                                g = 0;
                            g < b.length;
                            g++
                        ) {
                            var k = b[g],
                                m = lf(c, k.path),
                                l = !1,
                                t;
                            O(
                                null !== m,
                                "rerunTransactionsUnderNode_: relativePath should not be null."
                            );
                            if (5 === k.status)
                                (l = !0),
                                    (t = k.ne),
                                    (e = e.concat(si(a.M, k.Da, !0)));
                            else if (1 === k.status)
                                if (25 <= k.Sf)
                                    (l = !0),
                                        (t = "maxretry"),
                                        (e = e.concat(si(a.M, k.Da, !0)));
                                else {
                                    var A = a.M.Aa(k.path, f) || H;
                                    k.rd = A;
                                    var I = b[g].update(A.J());
                                    p(I)
                                        ? (hg(
                                              "transaction failed: Data returned ",
                                              I,
                                              k.path
                                          ),
                                          (m = Q(I)),
                                          ("object" === typeof I &&
                                              null != I &&
                                              y(I, ".priority")) ||
                                              (m = m.ia(A.C())),
                                          (A = k.Da),
                                          (I = Mi(a)),
                                          (I = Xc(m, I)),
                                          (k.sd = m),
                                          (k.td = I),
                                          (k.Da = a.Kd++),
                                          Ta(f, A),
                                          (e = e.concat(
                                              pi(a.M, k.path, I, k.Da, k.gf)
                                          )),
                                          (e = e.concat(si(a.M, A, !0))))
                                        : ((l = !0),
                                          (t = "nodata"),
                                          (e = e.concat(si(a.M, k.Da, !0))));
                                }
                            dc(a.fa, c, e);
                            e = [];
                            l &&
                                ((b[g].status = 3),
                                setTimeout(b[g].le, Math.floor(0)),
                                b[g].I &&
                                    ("nodata" === t
                                        ? ((k = new X(a, b[g].path)),
                                          d.push(
                                              u(
                                                  b[g].I,
                                                  null,
                                                  null,
                                                  !1,
                                                  new W(b[g].rd, k, R)
                                              )
                                          ))
                                        : d.push(
                                              u(
                                                  b[g].I,
                                                  null,
                                                  Error(t),
                                                  !1,
                                                  null
                                              )
                                          )));
                        }
                        Ui(a, a.yc);
                        for (g = 0; g < d.length; g++) gc(d[g]);
                        Ti(a);
                    }
                }
                function Xi(a, b) {
                    for (
                        var c, d = a.yc;
                        null !== (c = K(b)) && null === d.Ea();

                    )
                        (d = Xf(d, c)), (b = N(b));
                    return d;
                }
                function Vi(a, b) {
                    var c = [];
                    Zi(a, b, c);
                    c.sort(function (a, b) {
                        return a.Lf - b.Lf;
                    });
                    return c;
                }
                function Zi(a, b, c) {
                    var d = b.Ea();
                    if (null !== d)
                        for (var e = 0; e < d.length; e++) c.push(d[e]);
                    b.R(function (b) {
                        Zi(a, b, c);
                    });
                }
                function Ui(a, b) {
                    var c = b.Ea();
                    if (c) {
                        for (var d = 0, e = 0; e < c.length; e++)
                            3 !== c[e].status && ((c[d] = c[e]), d++);
                        c.length = d;
                        Yf(b, 0 < c.length ? c : null);
                    }
                    b.R(function (b) {
                        Ui(a, b);
                    });
                }
                function Qi(a, b) {
                    var c = Xi(a, b).path(),
                        d = Xf(a.yc, b);
                    ag(d, function (b) {
                        $i(a, b);
                    });
                    $i(a, d);
                    $f(d, function (b) {
                        $i(a, b);
                    });
                    return c;
                }
                function $i(a, b) {
                    var c = b.Ea();
                    if (null !== c) {
                        for (
                            var d = [], e = [], f = -1, g = 0;
                            g < c.length;
                            g++
                        )
                            4 !== c[g].status &&
                                (2 === c[g].status
                                    ? (O(
                                          f === g - 1,
                                          "All SENT items should be at beginning of queue."
                                      ),
                                      (f = g),
                                      (c[g].status = 4),
                                      (c[g].ne = "set"))
                                    : (O(
                                          1 === c[g].status,
                                          "Unexpected transaction status in abort"
                                      ),
                                      c[g].le(),
                                      (e = e.concat(si(a.M, c[g].Da, !0))),
                                      c[g].I &&
                                          d.push(
                                              u(
                                                  c[g].I,
                                                  null,
                                                  Error("set"),
                                                  !1,
                                                  null
                                              )
                                          )));
                        -1 === f ? Yf(b, null) : (c.length = f + 1);
                        dc(a.fa, b.path(), e);
                        for (g = 0; g < d.length; g++) gc(d[g]);
                    }
                }
                function aj() {
                    this.sc = {};
                    this.ag = !1;
                }
                aj.prototype.Cb = function () {
                    for (var a in this.sc) this.sc[a].Cb();
                };
                aj.prototype.vc = function () {
                    for (var a in this.sc) this.sc[a].vc();
                };
                aj.prototype.ze = function () {
                    this.ag = !0;
                };
                ba(aj);
                aj.prototype.interrupt = aj.prototype.Cb;
                aj.prototype.resume = aj.prototype.vc;
                function Y(a, b, c, d) {
                    this.k = a;
                    this.path = b;
                    this.n = c;
                    this.pc = d;
                }
                function bj(a) {
                    var b = null,
                        c = null;
                    a.oa && (b = Od(a));
                    a.ra && (c = Rd(a));
                    if (a.g === re) {
                        if (a.oa) {
                            if ("[MIN_NAME]" != Nd(a))
                                throw Error(
                                    "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo()."
                                );
                            if ("string" !== typeof b)
                                throw Error(
                                    "Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string."
                                );
                        }
                        if (a.ra) {
                            if ("[MAX_NAME]" != Pd(a))
                                throw Error(
                                    "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo()."
                                );
                            if ("string" !== typeof c)
                                throw Error(
                                    "Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string."
                                );
                        }
                    } else if (a.g === R) {
                        if ((null != b && !fg(b)) || (null != c && !fg(c)))
                            throw Error(
                                "Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string)."
                            );
                    } else if (
                        (O(
                            a.g instanceof ve || a.g === Be,
                            "unknown index type."
                        ),
                        (null != b && "object" === typeof b) ||
                            (null != c && "object" === typeof c))
                    )
                        throw Error(
                            "Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object."
                        );
                }
                function cj(a) {
                    if (a.oa && a.ra && a.la && (!a.la || "" === a.Rb))
                        throw Error(
                            "Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead."
                        );
                }
                function dj(a, b) {
                    if (!0 === a.pc)
                        throw Error(
                            b + ": You can't combine multiple orderBy calls."
                        );
                }
                h = Y.prototype;
                h.Mb = function () {
                    D("Query.ref", 0, 0, arguments.length);
                    return new X(this.k, this.path);
                };
                h.Ib = function (a, b, c, d) {
                    D("Query.on", 2, 4, arguments.length);
                    lg("Query.on", a, !1);
                    F("Query.on", 2, b, !1);
                    var e = ej("Query.on", c, d);
                    if ("value" === a)
                        Ri(
                            this.k,
                            this,
                            new ii(b, e.cancel || null, e.Qa || null)
                        );
                    else {
                        var f = {};
                        f[a] = b;
                        Ri(this.k, this, new ji(f, e.cancel, e.Qa));
                    }
                    return b;
                };
                h.mc = function (a, b, c) {
                    D("Query.off", 0, 3, arguments.length);
                    lg("Query.off", a, !0);
                    F("Query.off", 2, b, !0);
                    Qb("Query.off", 3, c);
                    var d = null,
                        e = null;
                    "value" === a
                        ? (d = new ii(b || null, null, c || null))
                        : a &&
                          (b && ((e = {}), (e[a] = b)),
                          (d = new ji(e, null, c || null)));
                    e = this.k;
                    d =
                        ".info" === K(this.path)
                            ? e.Fd.nb(this, d)
                            : e.M.nb(this, d);
                    bc(e.fa, this.path, d);
                };
                h.Og = function (a, b) {
                    function c(k) {
                        f &&
                            ((f = !1),
                            e.mc(a, c),
                            b && b.call(d.Qa, k),
                            g.resolve(k));
                    }
                    D("Query.once", 1, 4, arguments.length);
                    lg("Query.once", a, !1);
                    F("Query.once", 2, b, !0);
                    var d = ej("Query.once", arguments[2], arguments[3]),
                        e = this,
                        f = !0,
                        g = new B();
                    Nb(g.D);
                    this.Ib(a, c, function (b) {
                        e.mc(a, c);
                        d.cancel && d.cancel.call(d.Qa, b);
                        g.reject(b);
                    });
                    return g.D;
                };
                h.Le = function (a) {
                    S(
                        "Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead."
                    );
                    D("Query.limit", 1, 1, arguments.length);
                    if (!fa(a) || Math.floor(a) !== a || 0 >= a)
                        throw Error(
                            "Query.limit: First argument must be a positive integer."
                        );
                    if (this.n.la)
                        throw Error(
                            "Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast."
                        );
                    var b = this.n.Le(a);
                    cj(b);
                    return new Y(this.k, this.path, b, this.pc);
                };
                h.Me = function (a) {
                    D("Query.limitToFirst", 1, 1, arguments.length);
                    if (!fa(a) || Math.floor(a) !== a || 0 >= a)
                        throw Error(
                            "Query.limitToFirst: First argument must be a positive integer."
                        );
                    if (this.n.la)
                        throw Error(
                            "Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast)."
                        );
                    return new Y(this.k, this.path, this.n.Me(a), this.pc);
                };
                h.Ne = function (a) {
                    D("Query.limitToLast", 1, 1, arguments.length);
                    if (!fa(a) || Math.floor(a) !== a || 0 >= a)
                        throw Error(
                            "Query.limitToLast: First argument must be a positive integer."
                        );
                    if (this.n.la)
                        throw Error(
                            "Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast)."
                        );
                    return new Y(this.k, this.path, this.n.Ne(a), this.pc);
                };
                h.Pg = function (a) {
                    D("Query.orderByChild", 1, 1, arguments.length);
                    if ("$key" === a)
                        throw Error(
                            'Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.'
                        );
                    if ("$priority" === a)
                        throw Error(
                            'Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.'
                        );
                    if ("$value" === a)
                        throw Error(
                            'Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.'
                        );
                    ng("Query.orderByChild", a);
                    dj(this, "Query.orderByChild");
                    var b = new P(a);
                    if (b.e())
                        throw Error(
                            "Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead."
                        );
                    b = new ve(b);
                    b = Fe(this.n, b);
                    bj(b);
                    return new Y(this.k, this.path, b, !0);
                };
                h.Qg = function () {
                    D("Query.orderByKey", 0, 0, arguments.length);
                    dj(this, "Query.orderByKey");
                    var a = Fe(this.n, re);
                    bj(a);
                    return new Y(this.k, this.path, a, !0);
                };
                h.Rg = function () {
                    D("Query.orderByPriority", 0, 0, arguments.length);
                    dj(this, "Query.orderByPriority");
                    var a = Fe(this.n, R);
                    bj(a);
                    return new Y(this.k, this.path, a, !0);
                };
                h.Sg = function () {
                    D("Query.orderByValue", 0, 0, arguments.length);
                    dj(this, "Query.orderByValue");
                    var a = Fe(this.n, Be);
                    bj(a);
                    return new Y(this.k, this.path, a, !0);
                };
                h.ce = function (a, b) {
                    D("Query.startAt", 0, 2, arguments.length);
                    gg("Query.startAt", a, this.path, !0);
                    mg("Query.startAt", b);
                    var c = this.n.ce(a, b);
                    cj(c);
                    bj(c);
                    if (this.n.oa)
                        throw Error(
                            "Query.startAt: Starting point was already set (by another call to startAt or equalTo)."
                        );
                    p(a) || (b = a = null);
                    return new Y(this.k, this.path, c, this.pc);
                };
                h.vd = function (a, b) {
                    D("Query.endAt", 0, 2, arguments.length);
                    gg("Query.endAt", a, this.path, !0);
                    mg("Query.endAt", b);
                    var c = this.n.vd(a, b);
                    cj(c);
                    bj(c);
                    if (this.n.ra)
                        throw Error(
                            "Query.endAt: Ending point was already set (by another call to endAt or equalTo)."
                        );
                    return new Y(this.k, this.path, c, this.pc);
                };
                h.tg = function (a, b) {
                    D("Query.equalTo", 1, 2, arguments.length);
                    gg("Query.equalTo", a, this.path, !1);
                    mg("Query.equalTo", b);
                    if (this.n.oa)
                        throw Error(
                            "Query.equalTo: Starting point was already set (by another call to endAt or equalTo)."
                        );
                    if (this.n.ra)
                        throw Error(
                            "Query.equalTo: Ending point was already set (by another call to endAt or equalTo)."
                        );
                    return this.ce(a, b).vd(a, b);
                };
                h.toString = function () {
                    D("Query.toString", 0, 0, arguments.length);
                    for (
                        var a = this.path, b = "", c = a.aa;
                        c < a.u.length;
                        c++
                    )
                        "" !== a.u[c] &&
                            (b += "/" + encodeURIComponent(String(a.u[c])));
                    return this.k.toString() + (b || "/");
                };
                h.wa = function () {
                    var a = xd(Ge(this.n));
                    return "{}" === a ? "default" : a;
                };
                function ej(a, b, c) {
                    var d = { cancel: null, Qa: null };
                    if (b && c)
                        (d.cancel = b),
                            F(a, 3, d.cancel, !0),
                            (d.Qa = c),
                            Qb(a, 4, d.Qa);
                    else if (b)
                        if ("object" === typeof b && null !== b) d.Qa = b;
                        else if ("function" === typeof b) d.cancel = b;
                        else
                            throw Error(
                                E(a, 3, !0) +
                                    " must either be a cancel callback or a context object."
                            );
                    return d;
                }
                Y.prototype.ref = Y.prototype.Mb;
                Y.prototype.on = Y.prototype.Ib;
                Y.prototype.off = Y.prototype.mc;
                Y.prototype.once = Y.prototype.Og;
                Y.prototype.limit = Y.prototype.Le;
                Y.prototype.limitToFirst = Y.prototype.Me;
                Y.prototype.limitToLast = Y.prototype.Ne;
                Y.prototype.orderByChild = Y.prototype.Pg;
                Y.prototype.orderByKey = Y.prototype.Qg;
                Y.prototype.orderByPriority = Y.prototype.Rg;
                Y.prototype.orderByValue = Y.prototype.Sg;
                Y.prototype.startAt = Y.prototype.ce;
                Y.prototype.endAt = Y.prototype.vd;
                Y.prototype.equalTo = Y.prototype.tg;
                Y.prototype.toString = Y.prototype.toString;
                var Z = {};
                Z.zc = Rh;
                Z.DataConnection = Z.zc;
                Rh.prototype.bh = function (a, b) {
                    this.Ia("q", { p: a }, b);
                };
                Z.zc.prototype.simpleListen = Z.zc.prototype.bh;
                Rh.prototype.sg = function (a, b) {
                    this.Ia("echo", { d: a }, b);
                };
                Z.zc.prototype.echo = Z.zc.prototype.sg;
                Rh.prototype.interrupt = Rh.prototype.Cb;
                Z.dg = Fh;
                Z.RealTimeConnection = Z.dg;
                Fh.prototype.sendRequest = Fh.prototype.Ia;
                Fh.prototype.close = Fh.prototype.close;
                Z.Cg = function (a) {
                    var b = Rh.prototype.put;
                    Rh.prototype.put = function (c, d, e, f) {
                        p(f) && (f = a());
                        b.call(this, c, d, e, f);
                    };
                    return function () {
                        Rh.prototype.put = b;
                    };
                };
                Z.hijackHash = Z.Cg;
                Z.cg = dd;
                Z.ConnectionTarget = Z.cg;
                Z.wa = function (a) {
                    return a.wa();
                };
                Z.queryIdentifier = Z.wa;
                Z.Eg = function (a) {
                    return a.k.Va.ba;
                };
                Z.listens = Z.Eg;
                Z.ze = function (a) {
                    a.ze();
                };
                Z.forceRestClient = Z.ze;
                function X(a, b) {
                    var c, d, e;
                    if (a instanceof Ji) (c = a), (d = b);
                    else {
                        D("new Firebase", 1, 2, arguments.length);
                        d = sd(arguments[0]);
                        c = d.eh;
                        "firebase" === d.domain &&
                            rd(
                                d.host +
                                    " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"
                            );
                        (c && "undefined" != c) ||
                            rd(
                                "Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"
                            );
                        d.ob ||
                            ("undefined" !== typeof window &&
                                window.location &&
                                window.location.protocol &&
                                -1 !==
                                    window.location.protocol.indexOf(
                                        "https:"
                                    ) &&
                                S(
                                    "Insecure Firebase access from a secure page. Please use https in calls to new Firebase()."
                                ));
                        c = new dd(
                            d.host,
                            d.ob,
                            c,
                            "ws" === d.scheme || "wss" === d.scheme
                        );
                        d = new P(d.bd);
                        e = d.toString();
                        var f;
                        !(f = !q(c.host) || 0 === c.host.length || !eg(c.lc)) &&
                            (f = 0 !== e.length) &&
                            (e && (e = e.replace(/^\/*\.info(\/|$)/, "/")),
                            (f = !(q(e) && 0 !== e.length && !cg.test(e))));
                        if (f)
                            throw Error(
                                E("new Firebase", 1, !1) +
                                    'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".'
                            );
                        if (b)
                            if (b instanceof aj) e = b;
                            else if (q(b)) (e = aj.yb()), (c.Rd = b);
                            else
                                throw Error(
                                    "Expected a valid Firebase.Context for second argument to new Firebase()"
                                );
                        else e = aj.yb();
                        f = c.toString();
                        var g = z(e.sc, f);
                        g || ((g = new Ji(c, e.ag)), (e.sc[f] = g));
                        c = g;
                    }
                    Y.call(this, c, d, De, !1);
                    this.then = void 0;
                    this["catch"] = void 0;
                }
                ka(X, Y);
                var fj = X,
                    gj = ["Firebase"],
                    hj = n;
                gj[0] in hj || !hj.execScript || hj.execScript("var " + gj[0]);
                for (var ij; gj.length && (ij = gj.shift()); )
                    !gj.length && p(fj)
                        ? (hj[ij] = fj)
                        : (hj = hj[ij] ? hj[ij] : (hj[ij] = {}));
                X.goOffline = function () {
                    D("Firebase.goOffline", 0, 0, arguments.length);
                    aj.yb().Cb();
                };
                X.goOnline = function () {
                    D("Firebase.goOnline", 0, 0, arguments.length);
                    aj.yb().vc();
                };
                X.enableLogging = od;
                X.ServerValue = { TIMESTAMP: { ".sv": "timestamp" } };
                X.SDK_VERSION = Eb;
                X.INTERNAL = U;
                X.Context = aj;
                X.TEST_ACCESS = Z;
                X.prototype.name = function () {
                    S(
                        "Firebase.name() being deprecated. Please use Firebase.key() instead."
                    );
                    D("Firebase.name", 0, 0, arguments.length);
                    return this.key();
                };
                X.prototype.name = X.prototype.name;
                X.prototype.key = function () {
                    D("Firebase.key", 0, 0, arguments.length);
                    return this.path.e() ? null : me(this.path);
                };
                X.prototype.key = X.prototype.key;
                X.prototype.o = function (a) {
                    D("Firebase.child", 1, 1, arguments.length);
                    if (fa(a)) a = String(a);
                    else if (!(a instanceof P))
                        if (null === K(this.path)) {
                            var b = a;
                            b && (b = b.replace(/^\/*\.info(\/|$)/, "/"));
                            ng("Firebase.child", b);
                        } else ng("Firebase.child", a);
                    return new X(this.k, this.path.o(a));
                };
                X.prototype.child = X.prototype.o;
                X.prototype.parent = function () {
                    D("Firebase.parent", 0, 0, arguments.length);
                    var a = this.path.parent();
                    return null === a ? null : new X(this.k, a);
                };
                X.prototype.parent = X.prototype.parent;
                X.prototype.root = function () {
                    D("Firebase.ref", 0, 0, arguments.length);
                    for (var a = this; null !== a.parent(); ) a = a.parent();
                    return a;
                };
                X.prototype.root = X.prototype.root;
                X.prototype.set = function (a, b) {
                    D("Firebase.set", 1, 2, arguments.length);
                    og("Firebase.set", this.path);
                    gg("Firebase.set", a, this.path, !1);
                    F("Firebase.set", 2, b, !0);
                    var c = new B();
                    this.k.Ob(this.path, a, null, C(c, b));
                    return c.D;
                };
                X.prototype.set = X.prototype.set;
                X.prototype.update = function (a, b) {
                    D("Firebase.update", 1, 2, arguments.length);
                    og("Firebase.update", this.path);
                    if (da(a)) {
                        for (var c = {}, d = 0; d < a.length; ++d)
                            c["" + d] = a[d];
                        a = c;
                        S(
                            "Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children."
                        );
                    }
                    jg("Firebase.update", a, this.path);
                    F("Firebase.update", 2, b, !0);
                    c = new B();
                    this.k.update(this.path, a, C(c, b));
                    return c.D;
                };
                X.prototype.update = X.prototype.update;
                X.prototype.Ob = function (a, b, c) {
                    D("Firebase.setWithPriority", 2, 3, arguments.length);
                    og("Firebase.setWithPriority", this.path);
                    gg("Firebase.setWithPriority", a, this.path, !1);
                    kg("Firebase.setWithPriority", 2, b);
                    F("Firebase.setWithPriority", 3, c, !0);
                    if (".length" === this.key() || ".keys" === this.key())
                        throw (
                            "Firebase.setWithPriority failed: " +
                            this.key() +
                            " is a read-only object."
                        );
                    var d = new B();
                    this.k.Ob(this.path, a, b, C(d, c));
                    return d.D;
                };
                X.prototype.setWithPriority = X.prototype.Ob;
                X.prototype.remove = function (a) {
                    D("Firebase.remove", 0, 1, arguments.length);
                    og("Firebase.remove", this.path);
                    F("Firebase.remove", 1, a, !0);
                    return this.set(null, a);
                };
                X.prototype.remove = X.prototype.remove;
                X.prototype.transaction = function (a, b, c) {
                    D("Firebase.transaction", 1, 3, arguments.length);
                    og("Firebase.transaction", this.path);
                    F("Firebase.transaction", 1, a, !1);
                    F("Firebase.transaction", 2, b, !0);
                    if (p(c) && "boolean" != typeof c)
                        throw Error(
                            E("Firebase.transaction", 3, !0) +
                                "must be a boolean."
                        );
                    if (".length" === this.key() || ".keys" === this.key())
                        throw (
                            "Firebase.transaction failed: " +
                            this.key() +
                            " is a read-only object."
                        );
                    "undefined" === typeof c && (c = !0);
                    var d = new B();
                    r(b) && Nb(d.D);
                    Si(
                        this.k,
                        this.path,
                        a,
                        function (a, c, g) {
                            a ? d.reject(a) : d.resolve(new ei(c, g));
                            r(b) && b(a, c, g);
                        },
                        c
                    );
                    return d.D;
                };
                X.prototype.transaction = X.prototype.transaction;
                X.prototype.Zg = function (a, b) {
                    D("Firebase.setPriority", 1, 2, arguments.length);
                    og("Firebase.setPriority", this.path);
                    kg("Firebase.setPriority", 1, a);
                    F("Firebase.setPriority", 2, b, !0);
                    var c = new B();
                    this.k.Ob(this.path.o(".priority"), a, null, C(c, b));
                    return c.D;
                };
                X.prototype.setPriority = X.prototype.Zg;
                X.prototype.push = function (a, b) {
                    D("Firebase.push", 0, 2, arguments.length);
                    og("Firebase.push", this.path);
                    gg("Firebase.push", a, this.path, !0);
                    F("Firebase.push", 2, b, !0);
                    var c = Li(this.k),
                        d = hf(c),
                        c = this.o(d);
                    if (null != a) {
                        var e = this,
                            f = c.set(a, b).then(function () {
                                return e.o(d);
                            });
                        c.then = u(f.then, f);
                        c["catch"] = u(f.then, f, void 0);
                        r(b) && Nb(f);
                    }
                    return c;
                };
                X.prototype.push = X.prototype.push;
                X.prototype.lb = function () {
                    og("Firebase.onDisconnect", this.path);
                    return new V(this.k, this.path);
                };
                X.prototype.onDisconnect = X.prototype.lb;
                X.prototype.O = function (a, b, c) {
                    S(
                        "FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead."
                    );
                    D("Firebase.auth", 1, 3, arguments.length);
                    pg("Firebase.auth", a);
                    F("Firebase.auth", 2, b, !0);
                    F("Firebase.auth", 3, b, !0);
                    var d = new B();
                    dh(this.k.O, a, {}, { remember: "none" }, C(d, b), c);
                    return d.D;
                };
                X.prototype.auth = X.prototype.O;
                X.prototype.je = function (a) {
                    D("Firebase.unauth", 0, 1, arguments.length);
                    F("Firebase.unauth", 1, a, !0);
                    var b = new B();
                    eh(this.k.O, C(b, a));
                    return b.D;
                };
                X.prototype.unauth = X.prototype.je;
                X.prototype.Be = function () {
                    D("Firebase.getAuth", 0, 0, arguments.length);
                    return this.k.O.Be();
                };
                X.prototype.getAuth = X.prototype.Be;
                X.prototype.Ig = function (a, b) {
                    D("Firebase.onAuth", 1, 2, arguments.length);
                    F("Firebase.onAuth", 1, a, !1);
                    Qb("Firebase.onAuth", 2, b);
                    this.k.O.Ib("auth_status", a, b);
                };
                X.prototype.onAuth = X.prototype.Ig;
                X.prototype.Hg = function (a, b) {
                    D("Firebase.offAuth", 1, 2, arguments.length);
                    F("Firebase.offAuth", 1, a, !1);
                    Qb("Firebase.offAuth", 2, b);
                    this.k.O.mc("auth_status", a, b);
                };
                X.prototype.offAuth = X.prototype.Hg;
                X.prototype.hg = function (a, b, c) {
                    D("Firebase.authWithCustomToken", 1, 3, arguments.length);
                    2 === arguments.length && Hb(b) && ((c = b), (b = void 0));
                    pg("Firebase.authWithCustomToken", a);
                    F("Firebase.authWithCustomToken", 2, b, !0);
                    sg("Firebase.authWithCustomToken", 3, c, !0);
                    var d = new B();
                    dh(this.k.O, a, {}, c || {}, C(d, b));
                    return d.D;
                };
                X.prototype.authWithCustomToken = X.prototype.hg;
                X.prototype.ig = function (a, b, c) {
                    D("Firebase.authWithOAuthPopup", 1, 3, arguments.length);
                    2 === arguments.length && Hb(b) && ((c = b), (b = void 0));
                    rg("Firebase.authWithOAuthPopup", a);
                    F("Firebase.authWithOAuthPopup", 2, b, !0);
                    sg("Firebase.authWithOAuthPopup", 3, c, !0);
                    var d = new B();
                    ih(this.k.O, a, c, C(d, b));
                    return d.D;
                };
                X.prototype.authWithOAuthPopup = X.prototype.ig;
                X.prototype.jg = function (a, b, c) {
                    D("Firebase.authWithOAuthRedirect", 1, 3, arguments.length);
                    2 === arguments.length && Hb(b) && ((c = b), (b = void 0));
                    rg("Firebase.authWithOAuthRedirect", a);
                    F("Firebase.authWithOAuthRedirect", 2, b, !1);
                    sg("Firebase.authWithOAuthRedirect", 3, c, !0);
                    var d = new B(),
                        e = this.k.O,
                        f = c,
                        g = C(d, b);
                    gh(e);
                    var k = [Qg],
                        f = Ag(f);
                    "anonymous" === a || "firebase" === a
                        ? T(g, Sg("TRANSPORT_UNAVAILABLE"))
                        : (cd.set("redirect_client_options", f.qd),
                          hh(e, k, "/auth/" + a, f, g));
                    return d.D;
                };
                X.prototype.authWithOAuthRedirect = X.prototype.jg;
                X.prototype.kg = function (a, b, c, d) {
                    D("Firebase.authWithOAuthToken", 2, 4, arguments.length);
                    3 === arguments.length && Hb(c) && ((d = c), (c = void 0));
                    rg("Firebase.authWithOAuthToken", a);
                    F("Firebase.authWithOAuthToken", 3, c, !0);
                    sg("Firebase.authWithOAuthToken", 4, d, !0);
                    var e = new B();
                    q(b)
                        ? (qg("Firebase.authWithOAuthToken", 2, b),
                          fh(
                              this.k.O,
                              a + "/token",
                              { access_token: b },
                              d,
                              C(e, c)
                          ))
                        : (sg("Firebase.authWithOAuthToken", 2, b, !1),
                          fh(this.k.O, a + "/token", b, d, C(e, c)));
                    return e.D;
                };
                X.prototype.authWithOAuthToken = X.prototype.kg;
                X.prototype.gg = function (a, b) {
                    D("Firebase.authAnonymously", 0, 2, arguments.length);
                    1 === arguments.length && Hb(a) && ((b = a), (a = void 0));
                    F("Firebase.authAnonymously", 1, a, !0);
                    sg("Firebase.authAnonymously", 2, b, !0);
                    var c = new B();
                    fh(this.k.O, "anonymous", {}, b, C(c, a));
                    return c.D;
                };
                X.prototype.authAnonymously = X.prototype.gg;
                X.prototype.lg = function (a, b, c) {
                    D("Firebase.authWithPassword", 1, 3, arguments.length);
                    2 === arguments.length && Hb(b) && ((c = b), (b = void 0));
                    sg("Firebase.authWithPassword", 1, a, !1);
                    tg("Firebase.authWithPassword", a, "email");
                    tg("Firebase.authWithPassword", a, "password");
                    F("Firebase.authWithPassword", 2, b, !0);
                    sg("Firebase.authWithPassword", 3, c, !0);
                    var d = new B();
                    fh(this.k.O, "password", a, c, C(d, b));
                    return d.D;
                };
                X.prototype.authWithPassword = X.prototype.lg;
                X.prototype.ve = function (a, b) {
                    D("Firebase.createUser", 1, 2, arguments.length);
                    sg("Firebase.createUser", 1, a, !1);
                    tg("Firebase.createUser", a, "email");
                    tg("Firebase.createUser", a, "password");
                    F("Firebase.createUser", 2, b, !0);
                    var c = new B();
                    this.k.O.ve(a, C(c, b));
                    return c.D;
                };
                X.prototype.createUser = X.prototype.ve;
                X.prototype.Xe = function (a, b) {
                    D("Firebase.removeUser", 1, 2, arguments.length);
                    sg("Firebase.removeUser", 1, a, !1);
                    tg("Firebase.removeUser", a, "email");
                    tg("Firebase.removeUser", a, "password");
                    F("Firebase.removeUser", 2, b, !0);
                    var c = new B();
                    this.k.O.Xe(a, C(c, b));
                    return c.D;
                };
                X.prototype.removeUser = X.prototype.Xe;
                X.prototype.se = function (a, b) {
                    D("Firebase.changePassword", 1, 2, arguments.length);
                    sg("Firebase.changePassword", 1, a, !1);
                    tg("Firebase.changePassword", a, "email");
                    tg("Firebase.changePassword", a, "oldPassword");
                    tg("Firebase.changePassword", a, "newPassword");
                    F("Firebase.changePassword", 2, b, !0);
                    var c = new B();
                    this.k.O.se(a, C(c, b));
                    return c.D;
                };
                X.prototype.changePassword = X.prototype.se;
                X.prototype.re = function (a, b) {
                    D("Firebase.changeEmail", 1, 2, arguments.length);
                    sg("Firebase.changeEmail", 1, a, !1);
                    tg("Firebase.changeEmail", a, "oldEmail");
                    tg("Firebase.changeEmail", a, "newEmail");
                    tg("Firebase.changeEmail", a, "password");
                    F("Firebase.changeEmail", 2, b, !0);
                    var c = new B();
                    this.k.O.re(a, C(c, b));
                    return c.D;
                };
                X.prototype.changeEmail = X.prototype.re;
                X.prototype.Ze = function (a, b) {
                    D("Firebase.resetPassword", 1, 2, arguments.length);
                    sg("Firebase.resetPassword", 1, a, !1);
                    tg("Firebase.resetPassword", a, "email");
                    F("Firebase.resetPassword", 2, b, !0);
                    var c = new B();
                    this.k.O.Ze(a, C(c, b));
                    return c.D;
                };
                X.prototype.resetPassword = X.prototype.Ze;
            })();
        </script>
    </head>
    <body id="body">
        <input id="button-start" value="Start" type="submit" />

        <script src="app.js" type="text/javascript" charset="utf-8"></script>
    </body>
</html>
